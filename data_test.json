[
    {
        "contract_address": "0xf207ccfe6d1b90b0b7817ce2d5d262af1514e37b",
        "function_name": "refund",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function refund() external onlyAfter(endTime) {\n        if (softCapReached) revert();\n        if (refunded[msg.sender]) revert();\n        uint balance = token.balanceOf(msg.sender);\n        if (balance == 0) revert();\n        uint refund = balance / price;\n        if (refund > this.balance) {\n            refund = this.balance;\n        }\n        if (!msg.sender.send(refund)) revert();\n        refunded[msg.sender] = true;\n        weiRefunded = weiRefunded.add(refund);\n        Refunded(msg.sender, refund);\n    }"
    },
    {
        "contract_address": "0xf207ccfe6d1b90b0b7817ce2d5d262af1514e37b",
        "function_name": "withdraw",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function withdraw() onlyOwner {\n        if (!softCapReached) revert();\n        if (!beneficiary.send(collected)) revert();\n        token.transfer(beneficiary, token.balanceOf(this));\n        crowdsaleFinished = true;\n    }"
    },
    {
        "contract_address": "0xf209c9e2d743242e58bafda6dc3f59008ab8d8ed",
        "function_name": "hasClosed",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function hasClosed() public view returns (bool) {\n        return block.timestamp > closingTime;\n    }"
    },
    {
        "contract_address": "0xf211128cc6d925a3a328647cf78b322b51429c53",
        "function_name": "buyFor",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyFor(address _buyer)\n        public\n        payable\n    {\n        updateLastActive(_buyer);\n        uint256 _buyPrice = getBuyPrice();\n        uint256 ethAmount = msg.value;\n        pInvestedSum[_buyer] += ethAmount;\n        uint256 onePercent = ethAmount / 100;\n        uint256 fund = onePercent.mul(fundPercent);\n        uint256 dividends = onePercent.mul(divPercent);\n        uint256 toRef = onePercent.mul(refPercent);\n        uint256 tax = fund + dividends + toRef;\n        uint256 taxedAmount = ethAmount.sub(tax);\n        totalBuyVolume = totalBuyVolume + ethAmount;\n        totalBuyVolumeInDay[getToday()] += ethAmount;\n        distributeTax(_buyer, fund, dividends, toRef);\n        if (autoBuy) devTeamAutoBuy(taxedAmount, _buyPrice);\n        uint256 curEthBalance = ethBalance(_buyer);\n        uint256 _rDividends = getRDividends(_buyer);\n        uint256 _todayDividends = getTodayDividendsByAddress(_buyer);\n        mintToken(_buyer, taxedAmount, _buyPrice);\n        updateCredit(_buyer, curEthBalance, _rDividends, _todayDividends);\n    }"
    },
    {
        "contract_address": "0xf211128cc6d925a3a328647cf78b322b51429c53",
        "function_name": "pushDividends",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function pushDividends()\n        public\n        payable\n    {\n        uint256 ethAmount = msg.value;\n        uint256 dividends = ethAmount * divPercent / (divPercent + fundPercent);\n        uint256 fund = ethAmount.sub(dividends);\n        uint256 _buyPrice = getBuyPrice();\n        distributeTax(msg.sender, fund, dividends, 0);\n        if (autoBuy) devTeamAutoBuy(0, _buyPrice);\n    }"
    },
    {
        "contract_address": "0xf211128cc6d925a3a328647cf78b322b51429c53",
        "function_name": "buyFor",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyFor(address _buyer)\n        public\n        payable\n    {\n        updateLastActive(_buyer);\n        uint256 _buyPrice = getBuyPrice();\n        uint256 ethAmount = msg.value;\n        pInvestedSum[_buyer] += ethAmount;\n        uint256 onePercent = ethAmount / 100;\n        uint256 fund = onePercent.mul(fundPercent);\n        uint256 dividends = onePercent.mul(divPercent);\n        uint256 toRef = onePercent.mul(refPercent);\n        uint256 tax = fund + dividends + toRef;\n        uint256 taxedAmount = ethAmount.sub(tax);\n        totalBuyVolume = totalBuyVolume + ethAmount;\n        totalBuyVolumeInDay[getToday()] += ethAmount;\n        distributeTax(_buyer, fund, dividends, toRef);\n        if (autoBuy) devTeamAutoBuy(taxedAmount, _buyPrice);\n        uint256 curEthBalance = ethBalance(_buyer);\n        uint256 _rDividends = getRDividends(_buyer);\n        uint256 _todayDividends = getTodayDividendsByAddress(_buyer);\n        mintToken(_buyer, taxedAmount, _buyPrice);\n        updateCredit(_buyer, curEthBalance, _rDividends, _todayDividends);\n    }"
    },
    {
        "contract_address": "0xf211128cc6d925a3a328647cf78b322b51429c53",
        "function_name": "buyFor",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyFor(address _buyer)\n        public\n        payable\n    {\n        updateLastActive(_buyer);\n        uint256 _buyPrice = getBuyPrice();\n        uint256 ethAmount = msg.value;\n        pInvestedSum[_buyer] += ethAmount;\n        uint256 onePercent = ethAmount / 100;\n        uint256 fund = onePercent.mul(fundPercent);\n        uint256 dividends = onePercent.mul(divPercent);\n        uint256 toRef = onePercent.mul(refPercent);\n        uint256 tax = fund + dividends + toRef;\n        uint256 taxedAmount = ethAmount.sub(tax);\n        totalBuyVolume = totalBuyVolume + ethAmount;\n        totalBuyVolumeInDay[getToday()] += ethAmount;\n        distributeTax(_buyer, fund, dividends, toRef);\n        if (autoBuy) devTeamAutoBuy(taxedAmount, _buyPrice);\n        uint256 curEthBalance = ethBalance(_buyer);\n        uint256 _rDividends = getRDividends(_buyer);\n        uint256 _todayDividends = getTodayDividendsByAddress(_buyer);\n        mintToken(_buyer, taxedAmount, _buyPrice);\n        updateCredit(_buyer, curEthBalance, _rDividends, _todayDividends);\n    }"
    },
    {
        "contract_address": "0xf211128cc6d925a3a328647cf78b322b51429c53",
        "function_name": "sell",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function sell(uint256 _tokenAmount)\n        public\n        onlyTokenHolders()\n    {\n        updateLastActive(msg.sender);\n        address seller = msg.sender;\n        uint256 curEthBalance = ethBalance(seller);\n        uint256 _rDividends = getRDividends(seller);\n        uint256 _todayDividends = getTodayDividendsByAddress(seller);\n        uint256 ethAmount = burnToken(seller, _tokenAmount);\n        uint256 fund = ethAmount.mul(fundPercent) / 100;\n        uint256 taxedAmount = ethAmount.sub(fund);\n        totalSellVolume = totalSellVolume + ethAmount;\n        totalSellVolumeInDay[getToday()] += ethAmount;\n        curEthBalance = curEthBalance.add(taxedAmount);\n        fromSellingAmount[seller] += taxedAmount;\n        updateCredit(seller, curEthBalance, _rDividends, _todayDividends);\n        distributeTax(msg.sender, fund, 0, 0);\n    }"
    },
    {
        "contract_address": "0xf211128cc6d925a3a328647cf78b322b51429c53",
        "function_name": "sell",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function sell(uint256 _tokenAmount)\n        public\n        onlyTokenHolders()\n    {\n        updateLastActive(msg.sender);\n        address seller = msg.sender;\n        uint256 curEthBalance = ethBalance(seller);\n        uint256 _rDividends = getRDividends(seller);\n        uint256 _todayDividends = getTodayDividendsByAddress(seller);\n        uint256 ethAmount = burnToken(seller, _tokenAmount);\n        uint256 fund = ethAmount.mul(fundPercent) / 100;\n        uint256 taxedAmount = ethAmount.sub(fund);\n        totalSellVolume = totalSellVolume + ethAmount;\n        totalSellVolumeInDay[getToday()] += ethAmount;\n        curEthBalance = curEthBalance.add(taxedAmount);\n        fromSellingAmount[seller] += taxedAmount;\n        updateCredit(seller, curEthBalance, _rDividends, _todayDividends);\n        distributeTax(msg.sender, fund, 0, 0);\n    }"
    },
    {
        "contract_address": "0xf211128cc6d925a3a328647cf78b322b51429c53",
        "function_name": "transferFrom",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function transferFrom(address _from, address _to, uint256 _tokenAmount)\n        public\n        returns(bool)\n    {\n        updateAllowed(_from, _to, _tokenAmount);\n        updateLastActive(_from);\n        updateLastActive(_to);\n        uint256 curEthBalance_from = ethBalance(_from);\n        uint256 _rDividends_from = getRDividends(_from);\n        uint256 _todayDividends_from = getTodayDividendsByAddress(_from);\n        uint256 curEthBalance_to = ethBalance(_to);\n        uint256 _rDividends_to = getRDividends(_to);\n        uint256 _todayDividends_to = getTodayDividendsByAddress(_to);\n        uint256 taxedTokenAmount = _tokenAmount;\n        balances[_from] -= taxedTokenAmount;\n        balances[_to] += taxedTokenAmount;\n        updateCredit(_from, curEthBalance_from, _rDividends_from, _todayDividends_from);\n        updateCredit(_to, curEthBalance_to, _rDividends_to, _todayDividends_to);\n        emit Transfer(_from, _to, taxedTokenAmount);\n        return true;\n    }"
    },
    {
        "contract_address": "0xf211128cc6d925a3a328647cf78b322b51429c53",
        "function_name": "transferFrom",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function transferFrom(address _from, address _to, uint256 _tokenAmount)\n        public\n        returns(bool)\n    {\n        updateAllowed(_from, _to, _tokenAmount);\n        updateLastActive(_from);\n        updateLastActive(_to);\n        uint256 curEthBalance_from = ethBalance(_from);\n        uint256 _rDividends_from = getRDividends(_from);\n        uint256 _todayDividends_from = getTodayDividendsByAddress(_from);\n        uint256 curEthBalance_to = ethBalance(_to);\n        uint256 _rDividends_to = getRDividends(_to);\n        uint256 _todayDividends_to = getTodayDividendsByAddress(_to);\n        uint256 taxedTokenAmount = _tokenAmount;\n        balances[_from] -= taxedTokenAmount;\n        balances[_to] += taxedTokenAmount;\n        updateCredit(_from, curEthBalance_from, _rDividends_from, _todayDividends_from);\n        updateCredit(_to, curEthBalance_to, _rDividends_to, _todayDividends_to);\n        emit Transfer(_from, _to, taxedTokenAmount);\n        return true;\n    }"
    },
    {
        "contract_address": "0xf211128cc6d925a3a328647cf78b322b51429c53",
        "function_name": "transferFrom",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function transferFrom(address _from, address _to, uint256 _tokenAmount)\n        public\n        returns(bool)\n    {\n        updateAllowed(_from, _to, _tokenAmount);\n        updateLastActive(_from);\n        updateLastActive(_to);\n        uint256 curEthBalance_from = ethBalance(_from);\n        uint256 _rDividends_from = getRDividends(_from);\n        uint256 _todayDividends_from = getTodayDividendsByAddress(_from);\n        uint256 curEthBalance_to = ethBalance(_to);\n        uint256 _rDividends_to = getRDividends(_to);\n        uint256 _todayDividends_to = getTodayDividendsByAddress(_to);\n        uint256 taxedTokenAmount = _tokenAmount;\n        balances[_from] -= taxedTokenAmount;\n        balances[_to] += taxedTokenAmount;\n        updateCredit(_from, curEthBalance_from, _rDividends_from, _todayDividends_from);\n        updateCredit(_to, curEthBalance_to, _rDividends_to, _todayDividends_to);\n        emit Transfer(_from, _to, taxedTokenAmount);\n        return true;\n    }"
    },
    {
        "contract_address": "0xf211128cc6d925a3a328647cf78b322b51429c53",
        "function_name": "constructor",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "constructor (address _devTeam)\n        public\n    {\n        symbol = \"F2M2\";\n        name = \"Fomo2Moon2\";\n        decimals = 10;\n        unitRate = 10**uint256(decimals);\n        HARD_TOTAL_SUPPLY = HARD_TOTAL_SUPPLY * unitRate;\n        DevTeamInterface(_devTeam).setF2mAddress(address(this));\n        devTeam = _devTeam;\n        uint256 _amount = 500000 * unitRate;\n        totalSupply += _amount;\n        balances[devTeam] = _amount;\n        emit Transfer(0x0, devTeam, _amount);\n        deployedDay = getToday();\n    }"
    },
    {
        "contract_address": "0xf211128cc6d925a3a328647cf78b322b51429c53",
        "function_name": "sell",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function sell(uint256 _tokenAmount)\n        public\n        onlyTokenHolders()\n    {\n        updateLastActive(msg.sender);\n        address seller = msg.sender;\n        uint256 curEthBalance = ethBalance(seller);\n        uint256 _rDividends = getRDividends(seller);\n        uint256 _todayDividends = getTodayDividendsByAddress(seller);\n        uint256 ethAmount = burnToken(seller, _tokenAmount);\n        uint256 fund = ethAmount.mul(fundPercent) / 100;\n        uint256 taxedAmount = ethAmount.sub(fund);\n        totalSellVolume = totalSellVolume + ethAmount;\n        totalSellVolumeInDay[getToday()] += ethAmount;\n        curEthBalance = curEthBalance.add(taxedAmount);\n        fromSellingAmount[seller] += taxedAmount;\n        updateCredit(seller, curEthBalance, _rDividends, _todayDividends);\n        distributeTax(msg.sender, fund, 0, 0);\n    }"
    },
    {
        "contract_address": "0xf226b12c03514571c5a473b2627f5528da46d263",
        "function_name": "depositTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function depositTokens(address from, address token, uint256 tokens ) public returns (bool success)\n  {\n      if(!ERC20Interface(token).transferFrom(from, this, tokens)) revert();\n      balances[token][from] = balances[token][from].add(tokens);\n      depositedTokens[token] = depositedTokens[token].add(tokens);\n      Deposit(token, from, tokens, balances[token][from]);\n      return true;\n  }"
    },
    {
        "contract_address": "0xf239fab41de78533fa974b74d7605f1e68f8772e",
        "function_name": "transfer",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function transfer(address to, uint tokens) public returns (bool success);"
    },
    {
        "contract_address": "0xf239fab41de78533fa974b74d7605f1e68f8772e",
        "function_name": "transfer",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function transfer(address to, uint tokens) public returns (bool success);"
    },
    {
        "contract_address": "0xf239fab41de78533fa974b74d7605f1e68f8772e",
        "function_name": "transferFrom",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function transferFrom(address from, address to, uint tokens) public returns (bool success);"
    },
    {
        "contract_address": "0xf244176246168f24e3187f7288edbca29267739b",
        "function_name": "approveMotion",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function approveMotion(uint motionID)\n        external\n        onlyOwner\n    {\n        require(motionConfirming(motionID) && motionPasses(motionID));\n        address target = motionTarget[motionID];\n        nomin.confiscateBalance(target);\n        _closeMotion(motionID);\n        emit MotionApproved(motionID, motionID);\n    }"
    },
    {
        "contract_address": "0xf244176246168f24e3187f7288edbca29267739b",
        "function_name": "beginMotion",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function beginMotion(address target)\n        external\n        returns (uint)\n    {\n        require((havven.balanceOf(msg.sender) >= minStandingBalance) ||\n                msg.sender == owner);\n        require(votingPeriod <= havven.targetFeePeriodDurationSeconds());\n        require(targetMotionID[target] == 0);\n        require(!nomin.frozen(target));\n        uint motionID = nextMotionID++;\n        motionTarget[motionID] = target;\n        targetMotionID[target] = motionID;\n        motionStartTime[motionID] = now;\n        emit MotionBegun(msg.sender, msg.sender, target, target, motionID, motionID);\n        return motionID;\n    }"
    },
    {
        "contract_address": "0xf244176246168f24e3187f7288edbca29267739b",
        "function_name": "closeMotion",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function closeMotion(uint motionID)\n        external\n    {\n        require((motionConfirming(motionID) && !motionPasses(motionID)) || motionWaiting(motionID));\n        _closeMotion(motionID);\n    }"
    },
    {
        "contract_address": "0xf244176246168f24e3187f7288edbca29267739b",
        "function_name": "confiscateBalance",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function confiscateBalance(address target)\n        external\n    {\n        require(Court(msg.sender) == court);\n        uint motionID = court.targetMotionID(target);\n        require(motionID != 0);\n        require(court.motionConfirming(motionID));\n        require(court.motionPasses(motionID));\n        require(!frozen[target]);\n        uint balance = state.balanceOf(target);\n        state.setBalanceOf(address(this), safeAdd(state.balanceOf(address(this)), balance));\n        state.setBalanceOf(target, 0);\n        frozen[target] = true;\n        emit AccountFrozen(target, target, balance);\n        emit Transfer(target, address(this), balance);\n    }"
    },
    {
        "contract_address": "0xf244176246168f24e3187f7288edbca29267739b",
        "function_name": "voteAgainst",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function voteAgainst(uint motionID)\n        external\n    {\n        uint weight = setupVote(motionID);\n        vote[msg.sender][motionID] = Vote.Nay;\n        votesAgainst[motionID] = safeAdd(votesAgainst[motionID], weight);\n        emit VotedAgainst(msg.sender, msg.sender, motionID, motionID, weight);\n    }"
    },
    {
        "contract_address": "0xf244176246168f24e3187f7288edbca29267739b",
        "function_name": "voteFor",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function voteFor(uint motionID)\n        external\n    {\n        uint weight = setupVote(motionID);\n        vote[msg.sender][motionID] = Vote.Yea;\n        votesFor[motionID] = safeAdd(votesFor[motionID], weight);\n        emit VotedFor(msg.sender, msg.sender, motionID, motionID, weight);\n    }"
    },
    {
        "contract_address": "0xf244176246168f24e3187f7288edbca29267739b",
        "function_name": "withdrawFeeEntitlement",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function withdrawFeeEntitlement()\n        public\n        preCheckFeePeriodRollover\n        optionalProxy\n    {\n        address sender = messageSender;\n        require(!nomin.frozen(sender));\n        rolloverFee(sender, lastTransferTimestamp[sender], state.balanceOf(sender));\n        require(!hasWithdrawnLastPeriodFees[sender]);\n        uint feesOwed;\n        if (escrow != HavvenEscrow(0)) {\n            feesOwed = escrow.totalVestedAccountBalance(sender);\n        }\n        feesOwed = safeDiv_dec(safeMul_dec(safeAdd(feesOwed, lastAverageBalance[sender]),\n                                           lastFeesCollected),\n                               totalSupply);\n        hasWithdrawnLastPeriodFees[sender] = true;\n        if (feesOwed != 0) {\n            nomin.withdrawFee(sender, feesOwed);\n            emit FeesWithdrawn(sender, sender, feesOwed);\n        }\n    }"
    },
    {
        "contract_address": "0xf244176246168f24e3187f7288edbca29267739b",
        "function_name": "approveMotion",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function approveMotion(uint motionID)\n        external\n        onlyOwner\n    {\n        require(motionConfirming(motionID) && motionPasses(motionID));\n        address target = motionTarget[motionID];\n        nomin.confiscateBalance(target);\n        _closeMotion(motionID);\n        emit MotionApproved(motionID, motionID);\n    }"
    },
    {
        "contract_address": "0xf244176246168f24e3187f7288edbca29267739b",
        "function_name": "appendVestingEntry",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function appendVestingEntry(address account, uint time, uint quantity)\n        public\n        onlyOwner\n        setupFunction\n    {\n        require(now < time);\n        require(quantity != 0);\n        totalVestedBalance = safeAdd(totalVestedBalance, quantity);\n        require(totalVestedBalance <= havven.balanceOf(this));\n        if (vestingSchedules[account].length == 0) {\n            totalVestedAccountBalance[account] = quantity;\n        } else {\n            require(getVestingTime(account, numVestingEntries(account) - 1) < time);\n            totalVestedAccountBalance[account] = safeAdd(totalVestedAccountBalance[account], quantity);\n        }\n        vestingSchedules[account].push([time, quantity]);\n    }"
    },
    {
        "contract_address": "0xf244176246168f24e3187f7288edbca29267739b",
        "function_name": "buy",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buy(uint n)\n        external\n        payable\n        notLiquidating\n        optionalProxy\n    {\n        require(n >= MINIMUM_PURCHASE &&\n                msg.value == purchaseCostEther(n));\n        address sender = messageSender;\n        nominPool = safeSub(nominPool, n);\n        state.setBalanceOf(sender, safeAdd(state.balanceOf(sender), n));\n        emit Purchased(sender, sender, n, msg.value);\n        emit Transfer(0, sender, n);\n        totalSupply = safeAdd(totalSupply, n);\n    }"
    },
    {
        "contract_address": "0xf244176246168f24e3187f7288edbca29267739b",
        "function_name": "sell",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function sell(uint n)\n        external\n        optionalProxy\n    {\n        uint proceeds;\n        if (isLiquidating()) {\n            proceeds = saleProceedsEtherAllowStale(n);\n        } else {\n            proceeds = saleProceedsEther(n);\n        }\n        require(address(this).balance >= proceeds);\n        address sender = messageSender;\n        state.setBalanceOf(sender, safeSub(state.balanceOf(sender), n));\n        nominPool = safeAdd(nominPool, n);\n        emit Sold(sender, sender, n, proceeds);\n        emit Transfer(sender, 0, n);\n        totalSupply = safeSub(totalSupply, n);\n        sender.transfer(proceeds);\n    }"
    },
    {
        "contract_address": "0xf244176246168f24e3187f7288edbca29267739b",
        "function_name": "beginMotion",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function beginMotion(address target)\n        external\n        returns (uint)\n    {\n        require((havven.balanceOf(msg.sender) >= minStandingBalance) ||\n                msg.sender == owner);\n        require(votingPeriod <= havven.targetFeePeriodDurationSeconds());\n        require(targetMotionID[target] == 0);\n        require(!nomin.frozen(target));\n        uint motionID = nextMotionID++;\n        motionTarget[motionID] = target;\n        targetMotionID[target] = motionID;\n        motionStartTime[motionID] = now;\n        emit MotionBegun(msg.sender, msg.sender, target, target, motionID, motionID);\n        return motionID;\n    }"
    },
    {
        "contract_address": "0xf244176246168f24e3187f7288edbca29267739b",
        "function_name": "closeMotion",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function closeMotion(uint motionID)\n        external\n    {\n        require((motionConfirming(motionID) && !motionPasses(motionID)) || motionWaiting(motionID));\n        _closeMotion(motionID);\n    }"
    },
    {
        "contract_address": "0xf248680d071820ebb747aea688b9eeff75ef9f27",
        "function_name": "withdrawTo",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function withdrawTo(\n\t\t\taddress token,\n\t\t\tuint amount,\n\t\t\taddress to,\n\t\t\tbytes signature) external {\n\t\trequire(amount > 0 && to != address(this));\n\t\tassert(block.timestamp >= lastWithdrawalTime[token]);\n\t\tvar limit = getSignatureRemainingLimit(\n\t\t\tsignature,\n\t\t\tkeccak256(address(this), token, nonce, amount, to),\n\t\t\ttoken);\n\t\trequire(limit >= amount);\n\t\trequire(getBalance(token) >= amount);\n\t\tdailyCount[token] = getAdjustedDailyCount(token) + amount;\n\t\tlastWithdrawalTime[token] = block.timestamp;\n\t\tnonce++;\n\t\t_transfer(token, to, amount);\n\t\tOnWithdrawTo(token, msg.sender, to, amount, uint64(block.timestamp));\n\t}"
    },
    {
        "contract_address": "0xf244176246168f24e3187f7288edbca29267739b",
        "function_name": "setVotingPeriod",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function setVotingPeriod(uint duration)\n        external\n        onlyOwner\n    {\n        require(MIN_VOTING_PERIOD <= duration &&\n                duration <= MAX_VOTING_PERIOD);\n        require(duration <= havven.targetFeePeriodDurationSeconds());\n        votingPeriod = duration;\n    }"
    },
    {
        "contract_address": "0xf248680d071820ebb747aea688b9eeff75ef9f27",
        "function_name": "withdrawTo",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function withdrawTo(\n\t\t\taddress token,\n\t\t\tuint amount,\n\t\t\taddress to,\n\t\t\tbytes signature) external {\n\t\trequire(amount > 0 && to != address(this));\n\t\tassert(block.timestamp >= lastWithdrawalTime[token]);\n\t\tvar limit = getSignatureRemainingLimit(\n\t\t\tsignature,\n\t\t\tkeccak256(address(this), token, nonce, amount, to),\n\t\t\ttoken);\n\t\trequire(limit >= amount);\n\t\trequire(getBalance(token) >= amount);\n\t\tdailyCount[token] = getAdjustedDailyCount(token) + amount;\n\t\tlastWithdrawalTime[token] = block.timestamp;\n\t\tnonce++;\n\t\t_transfer(token, to, amount);\n\t\tOnWithdrawTo(token, msg.sender, to, amount, uint64(block.timestamp));\n\t}"
    },
    {
        "contract_address": "0xf244176246168f24e3187f7288edbca29267739b",
        "function_name": "voteAgainst",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function voteAgainst(uint motionID)\n        external\n    {\n        uint weight = setupVote(motionID);\n        vote[msg.sender][motionID] = Vote.Nay;\n        votesAgainst[motionID] = safeAdd(votesAgainst[motionID], weight);\n        emit VotedAgainst(msg.sender, msg.sender, motionID, motionID, weight);\n    }"
    },
    {
        "contract_address": "0xf244176246168f24e3187f7288edbca29267739b",
        "function_name": "transferFrom",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function transferFrom(address from, address to, uint value)\n        public\n        optionalProxy\n        returns (bool)\n    {\n        require(!frozen[to]);\n        return _transferFrom_byProxy(messageSender, from, to, value);\n    }"
    },
    {
        "contract_address": "0xf244176246168f24e3187f7288edbca29267739b",
        "function_name": "voteFor",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function voteFor(uint motionID)\n        external\n    {\n        uint weight = setupVote(motionID);\n        vote[msg.sender][motionID] = Vote.Yea;\n        votesFor[motionID] = safeAdd(votesFor[motionID], weight);\n        emit VotedFor(msg.sender, msg.sender, motionID, motionID, weight);\n    }"
    },
    {
        "contract_address": "0xf244176246168f24e3187f7288edbca29267739b",
        "function_name": "withdrawFeeEntitlement",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function withdrawFeeEntitlement()\n        public\n        preCheckFeePeriodRollover\n        optionalProxy\n    {\n        address sender = messageSender;\n        require(!nomin.frozen(sender));\n        rolloverFee(sender, lastTransferTimestamp[sender], state.balanceOf(sender));\n        require(!hasWithdrawnLastPeriodFees[sender]);\n        uint feesOwed;\n        if (escrow != HavvenEscrow(0)) {\n            feesOwed = escrow.totalVestedAccountBalance(sender);\n        }\n        feesOwed = safeDiv_dec(safeMul_dec(safeAdd(feesOwed, lastAverageBalance[sender]),\n                                           lastFeesCollected),\n                               totalSupply);\n        hasWithdrawnLastPeriodFees[sender] = true;\n        if (feesOwed != 0) {\n            nomin.withdrawFee(sender, feesOwed);\n            emit FeesWithdrawn(sender, sender, feesOwed);\n        }\n    }"
    },
    {
        "contract_address": "0xf24c63438ae11cb3facb84006f4cfa75458126ed",
        "function_name": "bidOnSiringAuction",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function bidOnSiringAuction(\n        uint256 _sireId,\n        uint256 _matronId\n    )\n        external\n        payable\n        whenNotPaused\n    {\n        require(_owns(msg.sender, _matronId));\n        require(isReadyToBreed(_matronId));\n        require(_canBreedWithViaAuction(_matronId, _sireId));\n        uint256 currentPrice = siringAuction.getCurrentPrice(_sireId);\n        require(msg.value >= currentPrice + autoBirthFee);\n        siringAuction.bid.value(msg.value - autoBirthFee)(_sireId);\n        _breedWith(uint32(_matronId), uint32(_sireId));\n    }"
    },
    {
        "contract_address": "0xf24c63438ae11cb3facb84006f4cfa75458126ed",
        "function_name": "ClockAuction",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function ClockAuction(address _nftAddress, uint256 _cut) public {\n        require(_cut <= 10000);\n        ownerCut = _cut;\n        ERC721 candidateContract = ERC721(_nftAddress);\n        require(candidateContract.supportsInterface(InterfaceSignature_ERC721));\n        nonFungibleContract = candidateContract;\n    }"
    },
    {
        "contract_address": "0xf24c63438ae11cb3facb84006f4cfa75458126ed",
        "function_name": "giveBirth",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function giveBirth(uint256 _matronId)\n        external\n        whenNotPaused\n        returns(uint256)\n    {\n        EtherDog storage matron = EtherDogs[_matronId];\n        require(matron.birthTime != 0);\n        require(_isReadyToGiveBirth(matron));\n        uint256 sireId = matron.siringWithId;\n        EtherDog storage sire = EtherDogs[sireId];\n        uint16 parentGen = matron.generation;\n        if (sire.generation > matron.generation) {\n            parentGen = sire.generation;\n        }\n        uint256 childGenes = geneScience.mixGenes(matron.genes, sire.genes, matron.cooldownEndBlock - 1);\n        address owner = EtherDogIndexToOwner[_matronId];\n        uint256 EtherDogId = _createEtherDog(_matronId, matron.siringWithId, parentGen + 1, childGenes, owner);\n        delete matron.siringWithId;\n        pregnantEtherDogs--;\n        msg.sender.transfer(autoBirthFee);\n        return EtherDogId;\n    }"
    },
    {
        "contract_address": "0xf24c63438ae11cb3facb84006f4cfa75458126ed",
        "function_name": "bid",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function bid(uint256 _tokenId)\n        external\n        payable\n        whenNotPaused\n    {\n        _bid(_tokenId, msg.value);\n        _transfer(msg.sender, _tokenId);\n    }"
    },
    {
        "contract_address": "0xf24c63438ae11cb3facb84006f4cfa75458126ed",
        "function_name": "bidOnSiringAuction",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function bidOnSiringAuction(\n        uint256 _sireId,\n        uint256 _matronId\n    )\n        external\n        payable\n        whenNotPaused\n    {\n        require(_owns(msg.sender, _matronId));\n        require(isReadyToBreed(_matronId));\n        require(_canBreedWithViaAuction(_matronId, _sireId));\n        uint256 currentPrice = siringAuction.getCurrentPrice(_sireId);\n        require(msg.value >= currentPrice + autoBirthFee);\n        siringAuction.bid.value(msg.value - autoBirthFee)(_sireId);\n        _breedWith(uint32(_matronId), uint32(_sireId));\n    }"
    },
    {
        "contract_address": "0xf24c63438ae11cb3facb84006f4cfa75458126ed",
        "function_name": "createAuction",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function createAuction(\n        uint256 _tokenId,\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration,\n        address _seller\n    )\n        external\n        whenNotPaused\n    {\n        require(_startingPrice == uint256(uint128(_startingPrice)));\n        require(_endingPrice == uint256(uint128(_endingPrice)));\n        require(_duration == uint256(uint64(_duration)));\n        require(_owns(msg.sender, _tokenId));\n        _escrow(msg.sender, _tokenId);\n        Auction memory auction = Auction(\n            _seller,\n            uint128(_startingPrice),\n            uint128(_endingPrice),\n            uint64(_duration),\n            uint64(now)\n        );\n        _addAuction(_tokenId, auction);\n    }"
    },
    {
        "contract_address": "0xf24c63438ae11cb3facb84006f4cfa75458126ed",
        "function_name": "createAuction",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function createAuction(\n        uint256 _tokenId,\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration,\n        address _seller\n    )\n        external\n        whenNotPaused\n    {\n        require(_startingPrice == uint256(uint128(_startingPrice)));\n        require(_endingPrice == uint256(uint128(_endingPrice)));\n        require(_duration == uint256(uint64(_duration)));\n        require(_owns(msg.sender, _tokenId));\n        _escrow(msg.sender, _tokenId);\n        Auction memory auction = Auction(\n            _seller,\n            uint128(_startingPrice),\n            uint128(_endingPrice),\n            uint64(_duration),\n            uint64(now)\n        );\n        _addAuction(_tokenId, auction);\n    }"
    },
    {
        "contract_address": "0xf268038c17c6a7539778a5ad747d51eda2d5b80f",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0xf24c63438ae11cb3facb84006f4cfa75458126ed",
        "function_name": "createAuction",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function createAuction(\n        uint256 _tokenId,\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration,\n        address _seller\n    )\n        external\n        whenNotPaused\n    {\n        require(_startingPrice == uint256(uint128(_startingPrice)));\n        require(_endingPrice == uint256(uint128(_endingPrice)));\n        require(_duration == uint256(uint64(_duration)));\n        require(_owns(msg.sender, _tokenId));\n        _escrow(msg.sender, _tokenId);\n        Auction memory auction = Auction(\n            _seller,\n            uint128(_startingPrice),\n            uint128(_endingPrice),\n            uint64(_duration),\n            uint64(now)\n        );\n        _addAuction(_tokenId, auction);\n    }"
    },
    {
        "contract_address": "0xf27e34c2b0acc3edd0559a9c3c21a884176a32c2",
        "function_name": "transfer",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function transfer(address to, uint256 value) public returns (bool);"
    },
    {
        "contract_address": "0xf2835c9788c468698dab65ccef6f992bbb9e9798",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0xf24c63438ae11cb3facb84006f4cfa75458126ed",
        "function_name": "giveBirth",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function giveBirth(uint256 _matronId)\n        external\n        whenNotPaused\n        returns(uint256)\n    {\n        EtherDog storage matron = EtherDogs[_matronId];\n        require(matron.birthTime != 0);\n        require(_isReadyToGiveBirth(matron));\n        uint256 sireId = matron.siringWithId;\n        EtherDog storage sire = EtherDogs[sireId];\n        uint16 parentGen = matron.generation;\n        if (sire.generation > matron.generation) {\n            parentGen = sire.generation;\n        }\n        uint256 childGenes = geneScience.mixGenes(matron.genes, sire.genes, matron.cooldownEndBlock - 1);\n        address owner = EtherDogIndexToOwner[_matronId];\n        uint256 EtherDogId = _createEtherDog(_matronId, matron.siringWithId, parentGen + 1, childGenes, owner);\n        delete matron.siringWithId;\n        pregnantEtherDogs--;\n        msg.sender.transfer(autoBirthFee);\n        return EtherDogId;\n    }"
    },
    {
        "contract_address": "0xf24c63438ae11cb3facb84006f4cfa75458126ed",
        "function_name": "setGeneScienceAddress",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function setGeneScienceAddress(address _address) external onlyCEO {\n        GeneScienceInterface candidateContract = GeneScienceInterface(_address);\n        require(candidateContract.isGeneScience());\n        geneScience = candidateContract;\n    }"
    },
    {
        "contract_address": "0xf24c63438ae11cb3facb84006f4cfa75458126ed",
        "function_name": "setSaleAuctionAddress",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function setSaleAuctionAddress(address _address) external onlyCEO {\n        SaleClockAuction candidateContract = SaleClockAuction(_address);\n        require(candidateContract.isSaleClockAuction());\n        saleAuction = candidateContract;\n    }"
    },
    {
        "contract_address": "0xf24c63438ae11cb3facb84006f4cfa75458126ed",
        "function_name": "setSiringAuctionAddress",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function setSiringAuctionAddress(address _address) external onlyCEO {\n        SiringClockAuction candidateContract = SiringClockAuction(_address);\n        require(candidateContract.isSiringClockAuction());\n        siringAuction = candidateContract;\n    }"
    },
    {
        "contract_address": "0xf28a42438df3a348d6bbcff93f6fa62f3698e597",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n      require(!isLocked);\n      require(tokenBalance() > 0);\n      start_time = now;\n      end_time = start_time.add(fifty_two_weeks);\n      isLocked = true;\n  }"
    },
    {
        "contract_address": "0xf28b3a07338cece75502f768626f56bcf1931a41",
        "function_name": "initialBattle",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function initialBattle(uint id1,uint total1,uint id2,uint total2) onlyWit() public returns (uint wid){\nuint darklord;\nif(total1.mul(2)>5000){\ndarklord=total1.mul(2);\n}else{\ndarklord=5000;\n}\nuint256 threshold = dataCalc(total1.add(total2),darklord);\nuint256 i = uint256(sha256(abi.encodePacked(block.timestamp, block.number-i-1))) % 100 +1;\nif(i <= threshold){\nwid = 0;\nwinnerAdd.push(msg.sender);\n}else{\nwid = 1;\n}\nbattleresults.push(Battlelog(id1,id2,wid,msg.sender));\n_delWit(msg.sender);\n}"
    },
    {
        "contract_address": "0xf28b3a07338cece75502f768626f56bcf1931a41",
        "function_name": "initialBM",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function initialBM(uint id1,uint total1,uint id2,uint total2,uint id3,uint total3,uint id4,uint total4) onlyWit() public returns (uint wid){\nuint teamETH;\nuint teamTron;\nteamETH=total1+total2;\nteamTron=total3+total4;\nuint256 threshold = dataCalc(teamETH,teamTron);\nuint256 i = uint256(sha256(abi.encodePacked(block.timestamp, block.number-i-1))) % 100 +1;\nif(i <= threshold){\nwid = 0;\nwinnerAdd.push(msg.sender);\n}else{\nwid = 1;\n}\nbmbattleresults.push(BMBattlelog(id1,id2,id3,id4,wid,msg.sender));\n_delWit(msg.sender);\n}"
    },
    {
        "contract_address": "0xf28c4a3a2721c7d0dc207ecb83d2c5289ab4bbe1",
        "function_name": "init",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function init() public onlyOwner {\n        require(!initialized);\n        initialized = true;\n        if (PAUSED) {\n            MainToken(token).pause();\n        }\n        transferOwnership(TARGET_USER);\n        emit Initialized();\n    }"
    },
    {
        "contract_address": "0xf28c4a3a2721c7d0dc207ecb83d2c5289ab4bbe1",
        "function_name": "hasClosed",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function hasClosed() public view returns (bool) {\n    return block.timestamp > closingTime;\n  }"
    },
    {
        "contract_address": "0xf28c4a3a2721c7d0dc207ecb83d2c5289ab4bbe1",
        "function_name": "constructor",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "constructor(uint256 _rate, address _wallet, ERC20 _token) public {\n    require(_rate > 0);\n    require(_wallet != address(0));\n    require(_token != address(0));\n    rate = _rate;\n    wallet = _wallet;\n    token = _token;\n  }"
    },
    {
        "contract_address": "0xf28c4a3a2721c7d0dc207ecb83d2c5289ab4bbe1",
        "function_name": "releaseOnce",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function releaseOnce() public {\n        bytes32 headKey = toKey(msg.sender, 0);\n        uint64 head = chains[headKey];\n        require(head != 0);\n        require(uint64(block.timestamp) > head);\n        bytes32 currentKey = toKey(msg.sender, head);\n        uint64 next = chains[currentKey];\n        uint amount = freezings[currentKey];\n        delete freezings[currentKey];\n        balances[msg.sender] = balances[msg.sender].add(amount);\n        freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n        if (next == 0) {\n            delete chains[headKey];\n        } else {\n            chains[headKey] = next;\n            delete chains[currentKey];\n        }\n        emit Released(msg.sender, amount);\n    }"
    },
    {
        "contract_address": "0xf28d3e573fd2c01002502504e36093ce6a01bf92",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n      require(!isLocked);\n      require(tokenBalance() > 0);\n      start_time = now;\n      end_time = start_time.add(fifty_two_weeks);\n      isLocked = true;\n  }"
    },
    {
        "contract_address": "0xf2861ad8dd602269c21eddd4d18255903cca47c7",
        "function_name": "execute",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function execute(address _player, uint _tokenCount, uint _divRate, bytes _data) public;"
    },
    {
        "contract_address": "0xf2861ad8dd602269c21eddd4d18255903cca47c7",
        "function_name": "buyAndTransfer",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyAndTransfer(address _referredBy, address target)\n  public\n  payable\n  {\n    bytes memory empty;\n    buyAndTransfer(_referredBy, target, empty, 20);\n  }"
    },
    {
        "contract_address": "0xf28c4a3a2721c7d0dc207ecb83d2c5289ab4bbe1",
        "function_name": "releaseAll",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function releaseAll() public returns (uint tokens) {\n        uint release;\n        uint balance;\n        (release, balance) = getFreezing(msg.sender, 0);\n        while (release != 0 && block.timestamp > release) {\n            releaseOnce();\n            tokens += balance;\n            (release, balance) = getFreezing(msg.sender, 0);\n        }\n    }"
    },
    {
        "contract_address": "0xf2861ad8dd602269c21eddd4d18255903cca47c7",
        "function_name": "execute",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function execute(address _player, uint _tokenCount, uint _divRate, bytes _data) public;"
    },
    {
        "contract_address": "0xf2c1f52a68667c5c3a05cb511d518e4c96783209",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n      require(!isLocked);\n      require(tokenBalance() > 0);\n      start_time = now;\n      end_time = start_time.add(fifty_two_weeks);\n      isLocked = true;\n  }"
    },
    {
        "contract_address": "0xf2c1f52a68667c5c3a05cb511d518e4c96783209",
        "function_name": "release",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function release() onlyOwner public{\n    require(isLocked);\n    require(!isReleased);\n    require(lockOver());\n    uint256 token_amount = tokenBalance();\n    token_reward.transfer( beneficiary, token_amount);\n    emit TokenReleased(beneficiary, token_amount);\n    isReleased = true;\n  }"
    },
    {
        "contract_address": "0xf2c1f52a68667c5c3a05cb511d518e4c96783209",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n      require(!isLocked);\n      require(tokenBalance() > 0);\n      start_time = now;\n      end_time = start_time.add(fifty_two_weeks);\n      isLocked = true;\n  }"
    },
    {
        "contract_address": "0xf2d0e8887438fd29b22f77003bd19a4694f31030",
        "function_name": "deploy",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function deploy() public onlyOwner {\n    token = new ripplegold();\n    preICO = new PreICO();\n    preICO.setWallet(0x486624Bc04234BE4C106BD2815e3f07AdE09A976);\n    preICO.setStart(1520640000);\n    preICO.setPeriod(22);\n    preICO.setPrice(33334000000000000000000);\n    preICO.setMinInvestedLimit(100000000000000000);\n    preICO.setToken(token);\n    preICO.setHardcap(8500000000000000000000);\n    token.setSaleAgent(preICO);\n    ico = new ICO();\n    ico.addMilestone(20, 40);\n    ico.addMilestone(20, 20);\n    ico.addMilestone(20, 0);\n    ico.setMinInvestedLimit(100000000000000000);\n    ico.setToken(token);\n    ico.setPrice(14286000000000000000000);\n    ico.setWallet(0x5FB78D8B8f1161731BC80eF93CBcfccc5783356F);\n    ico.setBountyTokensWallet(0xdAA156b6eA6b9737eA20c68Db4040B1182E487B6);\n    ico.setReservedTokensWallet(0xE1D1898660469797B22D348Ff67d54643d848295);\n    ico.setStart(1522627200);\n    ico.setHardcap(96000000000000000000000);\n    ico.setTeamTokensPercent(12);\n    ico.setBountyTokensPercent(4);\n    ico.setReservedTokensPercent(34);\n    teamTokensWallet = new FreezeTokensWallet();\n    teamTokensWallet.setStartLockPeriod(180);\n    teamTokensWallet.setPeriod(360);\n    teamTokensWallet.setDuration(90);\n    teamTokensWallet.setToken(token);\n    teamTokensWallet.transferOwnership(ico);\n    ico.setTeamTokensWallet(teamTokensWallet);\n    preICO.setNextSaleAgent(ico);\n    address manager = 0x486624Bc04234BE4C106BD2815e3f07AdE09A976;\n    token.transferOwnership(manager);\n    preICO.transferOwnership(manager);\n    ico.transferOwnership(manager);\n  }"
    },
    {
        "contract_address": "0xf2c6ee44c828cf69b48c59eba033d51a75735236",
        "function_name": "releaseAll",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function releaseAll() public returns (uint tokens) {\n        uint release;\n        uint balance;\n        (release, balance) = getFreezing(msg.sender, 0);\n        while (release != 0 && block.timestamp > release) {\n            releaseOnce();\n            tokens += balance;\n            (release, balance) = getFreezing(msg.sender, 0);\n        }\n    }"
    },
    {
        "contract_address": "0xf2c6ee44c828cf69b48c59eba033d51a75735236",
        "function_name": "releaseOnce",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function releaseOnce() public {\n        bytes32 headKey = toKey(msg.sender, 0);\n        uint64 head = chains[headKey];\n        require(head != 0);\n        require(uint64(block.timestamp) > head);\n        bytes32 currentKey = toKey(msg.sender, head);\n        uint64 next = chains[currentKey];\n        uint amount = freezings[currentKey];\n        delete freezings[currentKey];\n        balances[msg.sender] = balances[msg.sender].add(amount);\n        freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n        if (next == 0) {\n            delete chains[headKey];\n        } else {\n            chains[headKey] = next;\n            delete chains[currentKey];\n        }\n        emit Released(msg.sender, amount);\n    }"
    },
    {
        "contract_address": "0xf2c6ee44c828cf69b48c59eba033d51a75735236",
        "function_name": "init",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function init() public onlyOwner {\n        require(!initialized);\n        initialized = true;\n        if (PAUSED) {\n            MainToken(token).pause();\n        }\n        address[4] memory addresses = [address(0x021855a73ed2fc1ef650cae86f372d159f0334b9),address(0x021855a73ed2fc1ef650cae86f372d159f0334b9),address(0x021855a73ed2fc1ef650cae86f372d159f0334b9),address(0x021855a73ed2fc1ef650cae86f372d159f0334b9)];\n        uint[4] memory amounts = [uint(100000000000000000000000000),uint(25000000000000000000000000),uint(25000000000000000000000000),uint(50000000000000000000000000)];\n        uint64[4] memory freezes = [uint64(1552835401),uint64(1552835401),uint64(1552835401),uint64(1552835401)];\n        for (uint i = 0; i < addresses.length; i++) {\n            if (freezes[i] == 0) {\n                MainToken(token).mint(addresses[i], amounts[i]);\n            } else {\n                MainToken(token).mintAndFreeze(addresses[i], amounts[i], freezes[i]);\n            }\n        }\n        transferOwnership(TARGET_USER);\n        emit Initialized();\n    }"
    },
    {
        "contract_address": "0xf2c6ee44c828cf69b48c59eba033d51a75735236",
        "function_name": "hasClosed",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function hasClosed() public view returns (bool) {\n    return block.timestamp > closingTime;\n  }"
    },
    {
        "contract_address": "0xf2c6ee44c828cf69b48c59eba033d51a75735236",
        "function_name": "constructor",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "constructor(uint256 _rate, address _wallet, ERC20 _token) public {\n    require(_rate > 0);\n    require(_wallet != address(0));\n    require(_token != address(0));\n    rate = _rate;\n    wallet = _wallet;\n    token = _token;\n  }"
    },
    {
        "contract_address": "0xf2d0e8887438fd29b22f77003bd19a4694f31030",
        "function_name": "start",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function start() public onlyOwner notStarted {\n    startUnlock = now + startLockPeriod;\n    retrievedTokens = 0;\n    startBalance = token.balanceOf(this);\n    started = true;\n  }"
    },
    {
        "contract_address": "0xf2d0e8887438fd29b22f77003bd19a4694f31030",
        "function_name": "deploy",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function deploy() public onlyOwner {\n    token = new ripplegold();\n    preICO = new PreICO();\n    preICO.setWallet(0x486624Bc04234BE4C106BD2815e3f07AdE09A976);\n    preICO.setStart(1520640000);\n    preICO.setPeriod(22);\n    preICO.setPrice(33334000000000000000000);\n    preICO.setMinInvestedLimit(100000000000000000);\n    preICO.setToken(token);\n    preICO.setHardcap(8500000000000000000000);\n    token.setSaleAgent(preICO);\n    ico = new ICO();\n    ico.addMilestone(20, 40);\n    ico.addMilestone(20, 20);\n    ico.addMilestone(20, 0);\n    ico.setMinInvestedLimit(100000000000000000);\n    ico.setToken(token);\n    ico.setPrice(14286000000000000000000);\n    ico.setWallet(0x5FB78D8B8f1161731BC80eF93CBcfccc5783356F);\n    ico.setBountyTokensWallet(0xdAA156b6eA6b9737eA20c68Db4040B1182E487B6);\n    ico.setReservedTokensWallet(0xE1D1898660469797B22D348Ff67d54643d848295);\n    ico.setStart(1522627200);\n    ico.setHardcap(96000000000000000000000);\n    ico.setTeamTokensPercent(12);\n    ico.setBountyTokensPercent(4);\n    ico.setReservedTokensPercent(34);\n    teamTokensWallet = new FreezeTokensWallet();\n    teamTokensWallet.setStartLockPeriod(180);\n    teamTokensWallet.setPeriod(360);\n    teamTokensWallet.setDuration(90);\n    teamTokensWallet.setToken(token);\n    teamTokensWallet.transferOwnership(ico);\n    ico.setTeamTokensWallet(teamTokensWallet);\n    preICO.setNextSaleAgent(ico);\n    address manager = 0x486624Bc04234BE4C106BD2815e3f07AdE09A976;\n    token.transferOwnership(manager);\n    preICO.transferOwnership(manager);\n    ico.transferOwnership(manager);\n  }"
    },
    {
        "contract_address": "0xf2d579ba9dd46730fd9ceb68bdc5c4e570a40a44",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n      require(!isLocked);\n      require(tokenBalance() > 0);\n      start_time = now;\n      end_time = start_time.add(fifty_two_weeks);\n      isLocked = true;\n  }"
    },
    {
        "contract_address": "0xf2e51e32d1f546423364a040ef1a6d2f05e31482",
        "function_name": "freezeAccount",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function freezeAccount(address target, uint256 freeze)  onlyOwner  {\n    require(block.timestamp < (owner_freeze_start + owner_freeze_term));\n    frozenAccount[target] = freeze;\n    FrozenFunds(target, freeze);\n  }"
    },
    {
        "contract_address": "0xf2e51e32d1f546423364a040ef1a6d2f05e31482",
        "function_name": "freezeCheck",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function freezeCheck(address _from, uint256 _value)  returns (bool) {\n    uint forbiddenPremine =  launch_date - block.timestamp + total_freeze_term;\n    if (forbiddenPremine > 0) {\n      require(balances[_from] >= _value.add( frozenAccount[_from] * forbiddenPremine / total_freeze_term) );\n    }\n    return true;\n  }"
    },
    {
        "contract_address": "0xf2efa34020bcbfebdcafb69b5a80473f495b4bc1",
        "function_name": "mintToMax",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function mintToMax(address to) public onlyOwner returns (bool) {\n        require(block.timestamp >= mintBegintime);\n        require(mintMax > 0);\n        uint256 value;\n        if (mintPerday > 0) {\n            uint256 currentMax = (block.timestamp - mintBegintime).mul(mintPerday) / (3600 * 24);\n            value = currentMax.sub(mintTotal);\n            uint256 leave = mintMax.sub(mintTotal);\n            if (value > leave) {\n                value = leave;\n            }\n        } else {\n            value = mintMax.sub(mintTotal);\n        }\n        require(value > 0);\n        mintTotal = mintTotal.add(value);\n        _mint(to, value);\n        emit Mint(to, value);\n        return true;\n    }"
    },
    {
        "contract_address": "0xf2efa34020bcbfebdcafb69b5a80473f495b4bc1",
        "function_name": "mint",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function mint(address to, uint256 value) public onlyOwner returns (bool) {\n        require(block.timestamp >= mintBegintime);\n        require(value > 0);\n        if (mintPerday > 0) {\n            uint256 currentMax = (block.timestamp - mintBegintime).mul(mintPerday) / (3600 * 24);\n            uint256 leave = currentMax.sub(mintTotal);\n            require(leave >= value);\n        }\n        mintTotal = mintTotal.add(value);\n        if (mintMax > 0 && mintTotal > mintMax) {\n            revert();\n        }\n        _mint(to, value);\n        emit Mint(to, value);\n        return true;\n    }"
    },
    {
        "contract_address": "0xf2ebc3b384464c08357e7bdf10c8e517f3ddb473",
        "function_name": "mintExtraTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function mintExtraTokens() public onlyOwner {\n    require(!extraMinted);\n    mintTokens(bountyTokensWallet, bountyTokens);\n    mintTokens(advisorsTokensWallet, advisorsTokens);\n    mintTokens(developersTokensWallet, developersTokens);\n    extraMinted = true;\n  }"
    },
    {
        "contract_address": "0xf343115570895286cb968a07a8840c465bce7525",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0xf331f7887d31714dce936d9a9846e6afbe82e0a0",
        "function_name": "fallback",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function () external payable\n    {\n        if (payoutPeriodStart >= now && now <= payoutPeriodEnd)\n        {\n            if (posibleDividendsOf(msg.sender) > 0)\n            {\n                uint dividendsAmount = posibleDividendsOf(msg.sender);\n                GetDividends(msg.sender, dividendsAmount);\n                balances[msg.sender].posibleDividends = 0;\n                msg.sender.transfer(dividendsAmount);\n            }\n        }\n    }"
    },
    {
        "contract_address": "0xf3434f37ee2b6c08dde54fd346002be037dc2a82",
        "function_name": "pauseCrowdsale",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function pauseCrowdsale() public onlyOwner whenNotPaused {\n        TkoToken(token).pause();\n        super.pause();\n    }"
    },
    {
        "contract_address": "0xf3434f37ee2b6c08dde54fd346002be037dc2a82",
        "function_name": "unpauseCrowdsale",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function unpauseCrowdsale() public onlyOwner whenPaused {\n        TkoToken(token).unpause();\n        super.unpause();\n    }"
    },
    {
        "contract_address": "0xf359f2cc9e921496cd1ffa6746b6fdd08c25fab4",
        "function_name": "buyXid",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyXid(uint256 _affCode, uint256 _team)\n        isActivated()\n        isHuman()\n        isWithinLimits(msg.value)\n        public\n        payable\n    {\n        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n        uint256 _pID = pIDxAddr_[msg.sender];\n        if (_affCode == 0 || _affCode == _pID)\n        {\n            _affCode = plyr_[_pID].laff;\n        } else if (_affCode != plyr_[_pID].laff) {\n            plyr_[_pID].laff = _affCode;\n        }\n        _team = verifyTeam(_team);\n        buyCore(_pID, _affCode, _team, _eventData_);\n    }"
    },
    {
        "contract_address": "0xf359f2cc9e921496cd1ffa6746b6fdd08c25fab4",
        "function_name": "buyXname",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyXname(bytes32 _affCode, uint256 _team)\n        isActivated()\n        isHuman()\n        isWithinLimits(msg.value)\n        public\n        payable\n    {\n        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n        uint256 _pID = pIDxAddr_[msg.sender];\n        uint256 _affID;\n        if (_affCode == '' || _affCode == plyr_[_pID].name)\n        {\n            _affID = plyr_[_pID].laff;\n        } else {\n            _affID = pIDxName_[_affCode];\n            if (_affID != plyr_[_pID].laff)\n            {\n                plyr_[_pID].laff = _affID;\n            }\n        }\n        _team = verifyTeam(_team);\n        buyCore(_pID, _affID, _team, _eventData_);\n    }"
    },
    {
        "contract_address": "0xf359f2cc9e921496cd1ffa6746b6fdd08c25fab4",
        "function_name": "buyXaddr",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyXaddr(address _affCode, uint256 _team)\n        isActivated()\n        isHuman()\n        isWithinLimits(msg.value)\n        public\n        payable\n    {\n        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n        uint256 _pID = pIDxAddr_[msg.sender];\n        uint256 _affID;\n        if (_affCode == address(0) || _affCode == msg.sender)\n        {\n            _affID = plyr_[_pID].laff;\n        } else {\n            _affID = pIDxAddr_[_affCode];\n            if (_affID != plyr_[_pID].laff)\n            {\n                plyr_[_pID].laff = _affID;\n            }\n        }\n        _team = verifyTeam(_team);\n        buyCore(_pID, _affID, _team, _eventData_);\n    }"
    },
    {
        "contract_address": "0xf3725aa0abe761f9fcf5e770e8cc932642bbf6fc",
        "function_name": "release",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function release() onlyOwner public{\n    require(isLocked);\n    require(!isReleased);\n    require(lockOver());\n    uint256 token_amount = tokenBalance();\n    token_reward.transfer( beneficiary, token_amount);\n    emit TokenReleased(beneficiary, token_amount);\n    isReleased = true;\n  }"
    },
    {
        "contract_address": "0xf36a1c42a7a58801254a53ac54b0b5164698b8d4",
        "function_name": "setAStore",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function setAStore(\n    string _appNickname,\n    address _address\n  )\n  public\n  onlyOwner\n  {\n    require(bytes(_appNickname).length > 0);\n    bytes32 _appNickname32 = keccak256(_appNickname);\n    require(_address != address(0));\n    StoreInterface _store = StoreInterface(_address);\n    require(_store.getAppNickname() == _appNickname32);\n    uint _appId = _store.getAppId();\n    require(appNicknames32[_appId] == 0x0);\n    appNicknames32[_appId] = _appNickname32;\n    appNicknames[_appId] = _appNickname;\n    __appIds[_appNickname] = _appId;\n    __stores[_appId] = Store(\n      _store,\n      _address,\n      true\n    );\n    totalStores++;\n    StoreSet(_appNickname, _address);\n    StoreActive(_appNickname, _address, true);\n  }"
    },
    {
        "contract_address": "0xf3725aa0abe761f9fcf5e770e8cc932642bbf6fc",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n      require(!isLocked);\n      require(tokenBalance() > 0);\n      start_time = now;\n      end_time = start_time.add(fifty_two_weeks);\n      isLocked = true;\n  }"
    },
    {
        "contract_address": "0xf38250497b624fddaa9acda93abafa0a704a08e8",
        "function_name": "claimSiteToken",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function claimSiteToken(uint8 _siteId, uint _index) isActive requireAdventureItem requireAdventurePresale public {\n        if (_siteId < MIN_SITE_ID || _siteId > MAX_SITE_ID || _index > 10) revert();\n        BiddingInfo memory bidInfo;\n        (bidInfo.bidder, bidInfo.bidId, bidInfo.siteId, bidInfo.amount, bidInfo.time) = EtheremonAdventurePresale(adventurePresale).getBidBySiteIndex(_siteId, _index);\n        if (bidInfo.bidId == 0 || bidTokens[bidInfo.bidId] > 0) revert();\n        uint tokenId = (_siteId - 1) * 10 + _index + 1;\n        bidTokens[bidInfo.bidId] = tokenId;\n        EtheremonAdventureItem(adventureItem).spawnSite(_siteId, tokenId, bidInfo.bidder);\n    }"
    },
    {
        "contract_address": "0xf384f143641afc68dbb84ef04689597a1dfc7d54",
        "function_name": "claim",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function claim(address race) external\n    _validRace(race) {\n        BettingInterface raceContract = BettingInterface(race);\n        if(!ClaimedRaces[race]) {\n            toDistributeRace[race] = raceContract.checkReward();\n            raceContract.claim_reward();\n            ClaimedRaces[race] = true;\n        }\n        uint256 totalWinningTokens = 0;\n        uint256 ownedWinningTokens = 0;\n        bool btcWin = raceContract.winner_horse(bytes32(\"BTC\"));\n        bool ltcWin = raceContract.winner_horse(bytes32(\"LTC\"));\n        bool ethWin = raceContract.winner_horse(bytes32(\"ETH\"));\n        if(btcWin)\n        {\n            totalWinningTokens += TotalTokensCoinRace[race][bytes32(\"BTC\")];\n            ownedWinningTokens += ClaimTokens[msg.sender][race][bytes32(\"BTC\")];\n            ClaimTokens[msg.sender][race][bytes32(\"BTC\")] = 0;\n        }\n        if(ltcWin)\n        {\n            totalWinningTokens += TotalTokensCoinRace[race][bytes32(\"LTC\")];\n            ownedWinningTokens += ClaimTokens[msg.sender][race][bytes32(\"LTC\")];\n            ClaimTokens[msg.sender][race][bytes32(\"LTC\")] = 0;\n        }\n        if(ethWin)\n        {\n            totalWinningTokens += TotalTokensCoinRace[race][bytes32(\"ETH\")];\n            ownedWinningTokens += ClaimTokens[msg.sender][race][bytes32(\"ETH\")];\n            ClaimTokens[msg.sender][race][bytes32(\"ETH\")] = 0;\n        }\n        uint256 claimerCut = toDistributeRace[race] / totalWinningTokens * ownedWinningTokens;\n        msg.sender.transfer(claimerCut);\n        emit Claimed(race, claimerCut);\n    }"
    },
    {
        "contract_address": "0xf382ccbd3d203c10706059ffdcfe053308955792",
        "function_name": "importBalances",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function importBalances(uint n, address presaleContractAddress) public onlyOwner returns (bool) {\n       require(n > 0);\n       InvestyPresale presaleContract = InvestyPresale(presaleContractAddress);\n       InvestyToken presaleToken = presaleContract.token();\n       while (n > 0) {\n            address recipient = presaleContract.investors(importIndex);\n            uint recipientTokens = presaleToken.balanceOf(recipient);\n            token.mint(recipient, recipientTokens);\n            n = n.sub(1);\n            importIndex = importIndex.add(1);\n       }\n       return true;\n    }"
    },
    {
        "contract_address": "0xf384f143641afc68dbb84ef04689597a1dfc7d54",
        "function_name": "claim",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function claim(address race) external\n    _validRace(race) {\n        BettingInterface raceContract = BettingInterface(race);\n        if(!ClaimedRaces[race]) {\n            toDistributeRace[race] = raceContract.checkReward();\n            raceContract.claim_reward();\n            ClaimedRaces[race] = true;\n        }\n        uint256 totalWinningTokens = 0;\n        uint256 ownedWinningTokens = 0;\n        bool btcWin = raceContract.winner_horse(bytes32(\"BTC\"));\n        bool ltcWin = raceContract.winner_horse(bytes32(\"LTC\"));\n        bool ethWin = raceContract.winner_horse(bytes32(\"ETH\"));\n        if(btcWin)\n        {\n            totalWinningTokens += TotalTokensCoinRace[race][bytes32(\"BTC\")];\n            ownedWinningTokens += ClaimTokens[msg.sender][race][bytes32(\"BTC\")];\n            ClaimTokens[msg.sender][race][bytes32(\"BTC\")] = 0;\n        }\n        if(ltcWin)\n        {\n            totalWinningTokens += TotalTokensCoinRace[race][bytes32(\"LTC\")];\n            ownedWinningTokens += ClaimTokens[msg.sender][race][bytes32(\"LTC\")];\n            ClaimTokens[msg.sender][race][bytes32(\"LTC\")] = 0;\n        }\n        if(ethWin)\n        {\n            totalWinningTokens += TotalTokensCoinRace[race][bytes32(\"ETH\")];\n            ownedWinningTokens += ClaimTokens[msg.sender][race][bytes32(\"ETH\")];\n            ClaimTokens[msg.sender][race][bytes32(\"ETH\")] = 0;\n        }\n        uint256 claimerCut = toDistributeRace[race] / totalWinningTokens * ownedWinningTokens;\n        msg.sender.transfer(claimerCut);\n        emit Claimed(race, claimerCut);\n    }"
    },
    {
        "contract_address": "0xf384f143641afc68dbb84ef04689597a1dfc7d54",
        "function_name": "placeBet",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function placeBet(bytes32 horse) external payable;"
    },
    {
        "contract_address": "0xf3988a1c4ed151cc0261e894fadbdcd3356fe688",
        "function_name": "buy",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buy(uint256 tokenId) public payable {\n    require(erc721Address.getApproved(tokenId) == address(this));\n    require(prices[tokenId].price > 0 && prices[tokenId].price == msg.value);\n    erc721Address.transferFrom(prices[tokenId].tokenOwner, msg.sender, tokenId);\n    prices[tokenId].tokenOwner.transfer(msg.value);\n    resetPrice(tokenId);\n  }"
    },
    {
        "contract_address": "0xf384f143641afc68dbb84ef04689597a1dfc7d54",
        "function_name": "buyOffer",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function buyOffer(uint256 amount, uint256 price, address race, bytes32 horse) external payable\n    _validRace(race)\n    _validHorse(horse)\n    returns (bytes32) {\n        require(amount > 0);\n        require(price > 0);\n        require(msg.value == price * amount);\n        bytes32 id = keccak256(abi.encodePacked(amount,price,race,horse,false,block.timestamp));\n        require(owner[id] == address(0));\n        Offer storage newOffer = market[id];\n        newOffer.Amount = amount;\n        newOffer.Horse = horse;\n        newOffer.Price = price;\n        newOffer.Race = race;\n        newOffer.BuyType = true;\n        owner[id] = msg.sender;\n        emit Buying(id,amount,price,race,horse,msg.sender);\n        return id;\n    }"
    },
    {
        "contract_address": "0xf384f143641afc68dbb84ef04689597a1dfc7d54",
        "function_name": "sellOffer",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function sellOffer(uint256 amount, uint256 price, address race, bytes32 horse) external\n    _validRace(race)\n    _validHorse(horse)\n    returns (bytes32) {\n        uint256 ownedAmount = ClaimTokens[msg.sender][race][horse];\n        require(ownedAmount >= amount);\n        require(amount > 0);\n        bytes32 id = keccak256(abi.encodePacked(amount,price,race,horse,true,block.timestamp));\n        require(owner[id] == address(0));\n        Offer storage newOffer = market[id];\n        newOffer.Amount = amount;\n        newOffer.Horse = horse;\n        newOffer.Price = price;\n        newOffer.Race = race;\n        newOffer.BuyType = false;\n        ClaimTokens[msg.sender][race][horse] -= amount;\n        owner[id] = msg.sender;\n        emit Selling(id,amount,price,race,horse,msg.sender);\n        return id;\n    }"
    },
    {
        "contract_address": "0xf3988a1c4ed151cc0261e894fadbdcd3356fe688",
        "function_name": "buyByUsdt",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyByUsdt(uint256 tokenId) public {\n    require(usdtPrices[tokenId].price > 0 && erc721Address.getApproved(tokenId) == address(this));\n    require(usdtToken.transferFrom(msg.sender, usdtPrices[tokenId].tokenOwner, usdtPrices[tokenId].price));\n    erc721Address.transferFrom(usdtPrices[tokenId].tokenOwner, msg.sender, tokenId);\n    resetPrice(tokenId);\n  }"
    },
    {
        "contract_address": "0xf3988a1c4ed151cc0261e894fadbdcd3356fe688",
        "function_name": "setPriceFeeEth",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function setPriceFeeEth(uint256 _tokenId, uint256 _ethPrice) public payable {\n      require(erc721Address.ownerOf(_tokenId) == msg.sender && prices[_tokenId].price != _ethPrice);\n      uint256 ethfee;\n      if(prices[_tokenId].price < _ethPrice) {\n          ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / 100;\n          require(msg.value == ethfee);\n          ethfee += prices[_tokenId].fee;\n      } else ethfee = _ethPrice * ETHFee / 100;\n      prices[_tokenId] = Price(msg.sender, _ethPrice, ethfee);\n  }"
    },
    {
        "contract_address": "0xf3988a1c4ed151cc0261e894fadbdcd3356fe688",
        "function_name": "buy",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buy(uint256 tokenId) public payable {\n    require(erc721Address.getApproved(tokenId) == address(this));\n    require(prices[tokenId].price > 0 && prices[tokenId].price == msg.value);\n    erc721Address.transferFrom(prices[tokenId].tokenOwner, msg.sender, tokenId);\n    prices[tokenId].tokenOwner.transfer(msg.value);\n    resetPrice(tokenId);\n  }"
    },
    {
        "contract_address": "0xf3988a1c4ed151cc0261e894fadbdcd3356fe688",
        "function_name": "buyByUsdt",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyByUsdt(uint256 tokenId) public {\n    require(usdtPrices[tokenId].price > 0 && erc721Address.getApproved(tokenId) == address(this));\n    require(usdtToken.transferFrom(msg.sender, usdtPrices[tokenId].tokenOwner, usdtPrices[tokenId].price));\n    erc721Address.transferFrom(usdtPrices[tokenId].tokenOwner, msg.sender, tokenId);\n    resetPrice(tokenId);\n  }"
    },
    {
        "contract_address": "0xf3a9acee490e0a9cab8eb6755ce4d132bdf34f39",
        "function_name": "sendGift",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function sendGift(uint32 _bunnyId, address _to) public {\n        require(isPauseSave());\n        require(checkContract());\n        require(ownerOf(_bunnyId) == msg.sender);\n        require(_to != address(0));\n        publicContract.transferFrom(msg.sender, _to, _bunnyId);\n        publicContract.setAllowedChangeSex( _bunnyId, true);\n        lastGift = msg.sender;\n        totalGift = totalGift + 1;\n        lastGiftTime = block.timestamp;\n        emit SendGift(msg.sender, _to, _bunnyId);\n    }"
    },
    {
        "contract_address": "0xf3b672f490aceb1435ef343e12cff9d418a30026",
        "function_name": "endVesting",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function endVesting(address _addressToEnd, address _addressToRefund)\n        public\n        onlyOwner\n        vestingScheduleConfirmed(_addressToEnd)\n        addressNotNull(_addressToRefund)\n    {\n        VestingSchedule storage vestingSchedule = schedules[_addressToEnd];\n        uint amountWithdrawable = 0;\n        uint amountRefundable = 0;\n        if (block.timestamp < vestingSchedule.cliffTimeInSec) {\n            amountRefundable = vestingSchedule.totalAmount;\n        } else {\n            uint totalAmountVested = getTotalAmountVested(vestingSchedule);\n            amountWithdrawable = safeSub(totalAmountVested, vestingSchedule.totalAmountWithdrawn);\n            amountRefundable = safeSub(vestingSchedule.totalAmount, totalAmountVested);\n        }\n        delete schedules[_addressToEnd];\n        require(amountWithdrawable == 0 || vestingToken.transfer(_addressToEnd, amountWithdrawable));\n        require(amountRefundable == 0 || vestingToken.transfer(_addressToRefund, amountRefundable));\n        emit VestingEndedByOwner(_addressToEnd, amountWithdrawable, amountRefundable);\n    }"
    },
    {
        "contract_address": "0xf3b01ddd7f240e39f5b818cb36d14d69a54f6c8d",
        "function_name": "payPartners",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function payPartners() public {\n        require(partnersReward != 0);\n        uint secondsInYear = 31536000;\n        require(icoFinishedDate + secondsInYear / 2 < now);\n        assert(token.transfer(partners, partnersReward));\n        partnersReward = 0;\n    }"
    },
    {
        "contract_address": "0xf3b01ddd7f240e39f5b818cb36d14d69a54f6c8d",
        "function_name": "payTeam",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function payTeam() public {\n        require(teamReward != 0);\n        uint secondsInYear = 31536000;\n        require(icoFinishedDate + secondsInYear * 2 < now);\n        assert(token.transfer(team, teamReward));\n        teamReward = 0;\n    }"
    },
    {
        "contract_address": "0xf3b01ddd7f240e39f5b818cb36d14d69a54f6c8d",
        "function_name": "stopICO",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function stopICO() public onlyOwner isICORunning {\n        token.burn(address(this), token.balanceOf(address(this)));\n        token.burn(referralProgramOwner, token.balanceOf(referralProgramOwner));\n        token.burn(bountyOwner, token.balanceOf(bountyOwner));\n        uint256 totalSupply = token.totalSupply().mulToFraction(100, 85);\n        teamReward = totalSupply.mulToFraction(10, 100);\n        partnersReward = totalSupply.mulToFraction(5, 100);\n        token.mint(address(this), teamReward + partnersReward);\n        token.finishMinting();\n        isICOFinished = true;\n        icoFinishedDate = now;\n    }"
    },
    {
        "contract_address": "0xf3b01ddd7f240e39f5b818cb36d14d69a54f6c8d",
        "function_name": "stopICO",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function stopICO() public onlyOwner isICORunning {\n        token.burn(address(this), token.balanceOf(address(this)));\n        token.burn(referralProgramOwner, token.balanceOf(referralProgramOwner));\n        token.burn(bountyOwner, token.balanceOf(bountyOwner));\n        uint256 totalSupply = token.totalSupply().mulToFraction(100, 85);\n        teamReward = totalSupply.mulToFraction(10, 100);\n        partnersReward = totalSupply.mulToFraction(5, 100);\n        token.mint(address(this), teamReward + partnersReward);\n        token.finishMinting();\n        isICOFinished = true;\n        icoFinishedDate = now;\n    }"
    },
    {
        "contract_address": "0xf3bf5c58309a1c7133898737efafcd1b951b6edf",
        "function_name": "transfer",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function transfer(address to, uint256 value) public returns (bool);"
    },
    {
        "contract_address": "0xf3bf5c58309a1c7133898737efafcd1b951b6edf",
        "function_name": "transferFrom",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function transferFrom(address from, address to, uint256 value)\n    public returns (bool);"
    },
    {
        "contract_address": "0xf3bf5c58309a1c7133898737efafcd1b951b6edf",
        "function_name": "mint",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function mint(\n    address _to,\n    uint256 _amount\n  )\n    hasMintPermission\n    canMint\n    public\n    returns (bool)\n  {\n    totalSupply_ = totalSupply_.add(_amount);\n    balances[_to] = balances[_to].add(_amount);\n    emit Mint(_to, _amount);\n    emit Transfer(address(0), _to, _amount);\n    return true;\n  }"
    },
    {
        "contract_address": "0xf3c8ed6c721774c022c530e813a369dfe78a6e85",
        "function_name": "featureSprite",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function featureSprite (uint spriteId) payable {\n        require (msg.value == featurePrice);\n        broughtSprites[spriteId].featured = true;\n        if (broughtSprites[spriteId].timesTraded == 0) {\n            var (kittyOwner,,,,) = SaleClockAuction(SaleClockAuctionAddress).getAuction(spriteId);\n            uint priceIfAny = SaleClockAuction(SaleClockAuctionAddress).getCurrentPrice(spriteId);\n            address kittyOwnerNotForSale = KittyCore(KittyCoreAddress).ownerOf(spriteId);\n            if (priceIfAny > 0 && msg.sender == kittyOwner) {\n                broughtSprites[spriteId].price = priceIfAny * priceMultiplier / priceDivider;\n                broughtSprites[spriteId].forSale = true;\n                broughtSprites[spriteId].owner = kittyOwner;\n                numberOfSpritesOwnedByUser[msg.sender]++;\n            } else if (kittyOwnerNotForSale == msg.sender) {\n                broughtSprites[spriteId].owner = kittyOwnerNotForSale;\n                numberOfSpritesOwnedByUser[msg.sender]++;\n            }\n            broughtSprites[spriteId].spriteImageID = uint(block.blockhash(block.number-1))%360 + 1;\n        }\n        totalFeatures++;\n        etherForOwner += msg.value;\n        featuredSprites.push(spriteId);\n    }"
    },
    {
        "contract_address": "0xf3c8ed6c721774c022c530e813a369dfe78a6e85",
        "function_name": "buySprite",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buySprite (uint spriteId) payable {\n        uint _ownerCut;\n        uint _charityCut;\n        if (broughtSprites[spriteId].forSale == true) {\n            _ownerCut = ((broughtSprites[spriteId].price / 1000) * ownerCut);\n            _charityCut = ((broughtSprites[spriteId].price / 1000) * charityCut);\n            require (msg.value == broughtSprites[spriteId].price + _ownerCut + _charityCut);\n            broughtSprites[spriteId].owner.transfer(broughtSprites[spriteId].price);\n            numberOfSpritesOwnedByUser[broughtSprites[spriteId].owner]--;\n            if (broughtSprites[spriteId].timesTraded == 0) {\n                allPurchasedSprites.push(spriteId);\n            }\n            Transfer (broughtSprites[spriteId].owner, msg.sender, spriteId);\n        } else {\n            require (broughtSprites[spriteId].timesTraded == 0);\n            require (broughtSprites[spriteId].price == 0);\n            uint priceIfAny = SaleClockAuction(SaleClockAuctionAddress).getCurrentPrice(spriteId);\n            require (priceIfAny > 0);\n            _ownerCut = ((priceIfAny / 1000) * ownerCut) * priceMultiplier / priceDivider;\n            _charityCut = ((priceIfAny / 1000) * charityCut) * priceMultiplier / priceDivider;\n            require (msg.value >= (priceIfAny * priceMultiplier / priceDivider) + _ownerCut + _charityCut);\n            var (kittyOwner,,,,) = SaleClockAuction(SaleClockAuctionAddress).getAuction(spriteId);\n            kittyOwner.transfer(priceIfAny * priceMultiplier / priceDivider);\n            allPurchasedSprites.push(spriteId);\n            broughtSprites[spriteId].spriteImageID = uint(block.blockhash(block.number-1))%360 + 1;\n            Transfer (kittyOwner, msg.sender, spriteId);\n        }\n        totalBuys++;\n        spriteOwningHistory[msg.sender].push(spriteId);\n        numberOfSpritesOwnedByUser[msg.sender]++;\n        broughtSprites[spriteId].owner = msg.sender;\n        broughtSprites[spriteId].forSale = false;\n        broughtSprites[spriteId].timesTraded++;\n        broughtSprites[spriteId].featured = false;\n        etherForOwner += _ownerCut;\n        etherForCharity += _charityCut;\n    }"
    },
    {
        "contract_address": "0xf3c8ed6c721774c022c530e813a369dfe78a6e85",
        "function_name": "listSpriteForSale",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function listSpriteForSale (uint spriteId, uint price) {\n        require (price > 0);\n        if (broughtSprites[spriteId].owner != msg.sender) {\n            require (broughtSprites[spriteId].timesTraded == 0);\n            var (kittyOwner,,,,) = SaleClockAuction(SaleClockAuctionAddress).getAuction(spriteId);\n            if (kittyOwner != msg.sender) {\n                address kittyOwnerNotForSale = KittyCore(KittyCoreAddress).ownerOf(spriteId);\n                require (kittyOwnerNotForSale == msg.sender);\n            }\n            broughtSprites[spriteId].owner = msg.sender;\n            broughtSprites[spriteId].spriteImageID = uint(block.blockhash(block.number-1))%360 + 1;\n        }\n        broughtSprites[spriteId].forSale = true;\n        broughtSprites[spriteId].price = price;\n    }"
    },
    {
        "contract_address": "0xf3c8ed6c721774c022c530e813a369dfe78a6e85",
        "function_name": "removeSpriteFromSale",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function removeSpriteFromSale (uint spriteId) {\n        if (broughtSprites[spriteId].owner != msg.sender) {\n            require (broughtSprites[spriteId].timesTraded == 0);\n            var (kittyOwner,,,,) = SaleClockAuction(SaleClockAuctionAddress).getAuction(spriteId);\n            if (kittyOwner != msg.sender) {\n                address kittyOwnerNotForSale = KittyCore(KittyCoreAddress).ownerOf(spriteId);\n                require (kittyOwnerNotForSale == msg.sender);\n            }\n            broughtSprites[spriteId].price = 1;\n        }\n        broughtSprites[spriteId].forSale = false;\n    }"
    },
    {
        "contract_address": "0xf3c8ed6c721774c022c530e813a369dfe78a6e85",
        "function_name": "buySprite",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buySprite (uint spriteId) payable {\n        uint _ownerCut;\n        uint _charityCut;\n        if (broughtSprites[spriteId].forSale == true) {\n            _ownerCut = ((broughtSprites[spriteId].price / 1000) * ownerCut);\n            _charityCut = ((broughtSprites[spriteId].price / 1000) * charityCut);\n            require (msg.value == broughtSprites[spriteId].price + _ownerCut + _charityCut);\n            broughtSprites[spriteId].owner.transfer(broughtSprites[spriteId].price);\n            numberOfSpritesOwnedByUser[broughtSprites[spriteId].owner]--;\n            if (broughtSprites[spriteId].timesTraded == 0) {\n                allPurchasedSprites.push(spriteId);\n            }\n            Transfer (broughtSprites[spriteId].owner, msg.sender, spriteId);\n        } else {\n            require (broughtSprites[spriteId].timesTraded == 0);\n            require (broughtSprites[spriteId].price == 0);\n            uint priceIfAny = SaleClockAuction(SaleClockAuctionAddress).getCurrentPrice(spriteId);\n            require (priceIfAny > 0);\n            _ownerCut = ((priceIfAny / 1000) * ownerCut) * priceMultiplier / priceDivider;\n            _charityCut = ((priceIfAny / 1000) * charityCut) * priceMultiplier / priceDivider;\n            require (msg.value >= (priceIfAny * priceMultiplier / priceDivider) + _ownerCut + _charityCut);\n            var (kittyOwner,,,,) = SaleClockAuction(SaleClockAuctionAddress).getAuction(spriteId);\n            kittyOwner.transfer(priceIfAny * priceMultiplier / priceDivider);\n            allPurchasedSprites.push(spriteId);\n            broughtSprites[spriteId].spriteImageID = uint(block.blockhash(block.number-1))%360 + 1;\n            Transfer (kittyOwner, msg.sender, spriteId);\n        }\n        totalBuys++;\n        spriteOwningHistory[msg.sender].push(spriteId);\n        numberOfSpritesOwnedByUser[msg.sender]++;\n        broughtSprites[spriteId].owner = msg.sender;\n        broughtSprites[spriteId].forSale = false;\n        broughtSprites[spriteId].timesTraded++;\n        broughtSprites[spriteId].featured = false;\n        etherForOwner += _ownerCut;\n        etherForCharity += _charityCut;\n    }"
    },
    {
        "contract_address": "0xf3e0b9368993640287eeed970945fdf57da53ed1",
        "function_name": "addModule",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function addModule(\n        address _moduleFactory,\n        bytes _data,\n        uint256 _maxCost,\n        uint256 _budget\n    ) external;"
    },
    {
        "contract_address": "0xf3e0b9368993640287eeed970945fdf57da53ed1",
        "function_name": "forceTransfer",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function forceTransfer(address _from, address _to, uint256 _value, bytes _data, bytes _log) external;"
    },
    {
        "contract_address": "0xf3e0b9368993640287eeed970945fdf57da53ed1",
        "function_name": "addModule",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function addModule(\n        address _moduleFactory,\n        bytes _data,\n        uint256 _maxCost,\n        uint256 _budget\n    ) external;"
    },
    {
        "contract_address": "0xf3e0b9368993640287eeed970945fdf57da53ed1",
        "function_name": "constructor",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "constructor() public {\n    owner = msg.sender;\n  }"
    },
    {
        "contract_address": "0xf3e0b9368993640287eeed970945fdf57da53ed1",
        "function_name": "mintWithData",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function mintWithData(address _investor, uint256 _value, bytes _data) external returns (bool success);"
    },
    {
        "contract_address": "0xf3e0b9368993640287eeed970945fdf57da53ed1",
        "function_name": "mintWithData",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function mintWithData(address _investor, uint256 _value, bytes _data) external returns (bool success);"
    },
    {
        "contract_address": "0xf3e52127fc5d5f16c9eaa0168a784ef13f6eb3e7",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0xf3e52127fc5d5f16c9eaa0168a784ef13f6eb3e7",
        "function_name": "release",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function release() onlyOwner public{\n    require(isLocked);\n    require(!isReleased);\n    require(lockOver());\n    uint256 token_amount = tokenBalance();\n    token_reward.transfer( beneficiary, token_amount);\n    emit TokenReleased(beneficiary, token_amount);\n    isReleased = true;\n  }"
    },
    {
        "contract_address": "0xf3e52127fc5d5f16c9eaa0168a784ef13f6eb3e7",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0xf3eb09a1fd5a3e133a669074de1231d7a673744b",
        "function_name": "sendTokensToBountyOwner",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function sendTokensToBountyOwner() onlyManager whenInitialized hasBountyCampaign afterPublicSale {\n        require(!sentTokensToBountyOwner);\n        uint bountyTokens = getTokensSold() / 40;\n        exotownToken.emitTokens(bountyOwner, bountyTokens);\n        sentTokensToBountyOwner = true;\n    }"
    },
    {
        "contract_address": "0xf3e0b9368993640287eeed970945fdf57da53ed1",
        "function_name": "updateFromRegistry",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function updateFromRegistry() external;"
    },
    {
        "contract_address": "0xf3e0b9368993640287eeed970945fdf57da53ed1",
        "function_name": "updateFromRegistry",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function updateFromRegistry() external;"
    },
    {
        "contract_address": "0xf3eb09a1fd5a3e133a669074de1231d7a673744b",
        "function_name": "sendTokensToFounders",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function sendTokensToFounders() onlyManager whenInitialized afterPublicSale {\n        require(!sentTokensToFounders);\n        require(now >= foundersTokensUnlock);\n        uint founderReward = getTokensSold() / 10;\n        exotownToken.emitTokens(founderWallet, founderReward);\n        sentTokensToFounders = true;\n    }"
    },
    {
        "contract_address": "0xf3e0b9368993640287eeed970945fdf57da53ed1",
        "function_name": "updateFromRegistry",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function updateFromRegistry() external;"
    },
    {
        "contract_address": "0xf3e70642c28f3f707408c56624c2f30ea9f9fce3",
        "function_name": "getReservedTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function getReservedTokens(uint256 _tokens) public onlyReserved {\n    uint256 tokens = _tokens.mul(10 ** 18);\n    require(withdrawReservedTokens.add(tokens) <= viewReservedTokens());\n    albosAddress.transfer(reservedAddress, tokens);\n    withdrawReservedTokens = withdrawReservedTokens.add(tokens);\n  }"
    },
    {
        "contract_address": "0xf3fce1b764a26170cc06e793083a617a55df32f8",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0xf3fce1b764a26170cc06e793083a617a55df32f8",
        "function_name": "release",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function release() onlyOwner public{\n    require(isLocked);\n    require(!isReleased);\n    require(lockOver());\n    uint256 token_amount = tokenBalance();\n    token_reward.transfer( beneficiary, token_amount);\n    emit TokenReleased(beneficiary, token_amount);\n    isReleased = true;\n  }"
    },
    {
        "contract_address": "0xf3fce1b764a26170cc06e793083a617a55df32f8",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0xf3e70642c28f3f707408c56624c2f30ea9f9fce3",
        "function_name": "getFoundersTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function getFoundersTokens(uint256 _tokens) public onlyFounders {\n    uint256 tokens = _tokens.mul(10 ** 18);\n    require(withdrawFoundersTokens.add(tokens) <= viewFoundersTokens());\n    albosAddress.transfer(foundersAddress, tokens);\n    withdrawFoundersTokens = withdrawFoundersTokens.add(tokens);\n  }"
    },
    {
        "contract_address": "0xf40692384d14b9c2395cfae369621447429ae149",
        "function_name": "unstakeTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function unstakeTokens () public onlyUnlocked {\n    Staker storage staker = stakerMap[msg.sender];\n    Reward storage reward = rewardLevels[staker.rewardLevel];\n    require (staker.balance > 0);\n    require (staker.stakingSince.add(reward.lockupPeriod) < now);\n    if (getAvailableReward(msg.sender) > 0) {\n      claimReward();\n    }\n    require (token.transfer(msg.sender, staker.balance));\n    count = count.sub(1);\n    balance = balance.sub(staker.balance);\n    emit StakerCount (count, limit);\n  \tstakerMap[msg.sender] = Staker(0, 0, 0, 0);\n  }"
    },
    {
        "contract_address": "0xf40692384d14b9c2395cfae369621447429ae149",
        "function_name": "stakeTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function stakeTokens (uint _level) public onlyUnlocked {\n    Reward storage reward = rewardLevels[_level];\n    require (stakerMap[msg.sender].balance == 0);\n    require (count < limit);\n    require (token.transferFrom(msg.sender, address(this), reward.stakedAmount));\n    count = count.add(1);\n    balance = balance.add(reward.stakedAmount);\n    stakerMap[msg.sender] = Staker(reward.stakedAmount, _level, now, now);\n    emit NewStaker (msg.sender, _level, now);\n    emit StakerCount (count, limit);\n  }"
    },
    {
        "contract_address": "0xf409d4642010618fc52ebb7aea404a5d41f45694",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0xf409d4642010618fc52ebb7aea404a5d41f45694",
        "function_name": "release",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function release() onlyOwner public{\n    require(isLocked);\n    require(!isReleased);\n    require(lockOver());\n    uint256 token_amount = tokenBalance();\n    token_reward.transfer( beneficiary, token_amount);\n    emit TokenReleased(beneficiary, token_amount);\n    isReleased = true;\n  }"
    },
    {
        "contract_address": "0xf409d4642010618fc52ebb7aea404a5d41f45694",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0xf40c5e190a608b6f8c0bf2b38c9506b327941402",
        "function_name": "resolveClaim",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function resolveClaim(address _lostAddress) public returns (uint256){\n        Claim memory claim = claims[_lostAddress];\n        require(claim.collateral != 0, \"No claim found\");\n        require(claim.claimant == msg.sender);\n        require(claim.timestamp + claimPeriod <= block.timestamp);\n        address claimant = claim.claimant;\n        delete claims[_lostAddress];\n        claimant.transfer(claim.collateral);\n        internalTransfer(_lostAddress, claimant, balanceOf(_lostAddress));\n        emit ClaimResolved(_lostAddress, claimant, claim.collateral);\n        return claim.collateral;\n    }"
    },
    {
        "contract_address": "0xf40c5e190a608b6f8c0bf2b38c9506b327941402",
        "function_name": "declareLost",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function declareLost(address _lostAddress, bytes32 _nonce) public payable{\n        uint256 balance = balanceOf(_lostAddress);\n        require(balance > 0);\n        require(msg.value >= balance.mul(collateralRate));\n        require(claims[_lostAddress].collateral == 0);\n        require(validateClaim(_lostAddress, _nonce));\n        claims[_lostAddress] = Claim({\n            claimant: msg.sender,\n            collateral: msg.value,\n            timestamp: block.timestamp\n        });\n        delete preClaims[msg.sender];\n        emit ClaimMade(_lostAddress, msg.sender, balance);\n    }"
    },
    {
        "contract_address": "0xf40c5e190a608b6f8c0bf2b38c9506b327941402",
        "function_name": "clearClaim",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function clearClaim() public returns (uint256){\n        uint256 collateral = claims[msg.sender].collateral;\n        if (collateral != 0){\n            delete claims[msg.sender];\n            msg.sender.transfer(collateral);\n            emit ClaimCleared(msg.sender, collateral);\n            return collateral;\n        } else {\n            return 0;\n        }\n    }"
    },
    {
        "contract_address": "0xf40c5e190a608b6f8c0bf2b38c9506b327941402",
        "function_name": "deleteClaim",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function deleteClaim(address _lostAddress) public onlyOwner(){\n        Claim memory claim = claims[_lostAddress];\n        require(claim.collateral != 0, \"No claim found\");\n        delete claims[_lostAddress];\n        claim.claimant.transfer(claim.collateral);\n        emit ClaimDeleted(_lostAddress, claim.claimant, claim.collateral);\n    }"
    },
    {
        "contract_address": "0xf41440c6070115440f0402cce6ee216e26522892",
        "function_name": "redeemDaoBounty",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function redeemDaoBounty(bytes32 _proposalId,address _beneficiary) public returns(uint redeemedAmount,uint potentialAmount) {\n        Proposal storage proposal = proposals[_proposalId];\n        require((proposal.state == ProposalState.Executed) || (proposal.state == ProposalState.Closed));\n        uint totalWinningStakes = proposal.stakes[proposal.winningVote];\n        if (\n            (proposal.stakers[_beneficiary].amountForBounty>0)&&\n            (proposal.stakers[_beneficiary].vote == proposal.winningVote)&&\n            (proposal.winningVote == YES)&&\n            (totalWinningStakes != 0))\n        {\n            Parameters memory params = parameters[proposal.paramsHash];\n            uint beneficiaryLimit = (proposal.stakers[_beneficiary].amountForBounty.mul(params.daoBountyLimit)) / totalWinningStakes;\n            potentialAmount = (params.daoBountyConst.mul(proposal.stakers[_beneficiary].amountForBounty))/100;\n            if (potentialAmount > beneficiaryLimit) {\n                potentialAmount = beneficiaryLimit;\n            }\n        }\n        if ((potentialAmount != 0)&&(stakingToken.balanceOf(proposal.avatar) >= potentialAmount)) {\n            proposal.daoBountyRemain = proposal.daoBountyRemain.sub(potentialAmount);\n            require(ControllerInterface(Avatar(proposal.avatar).owner()).externalTokenTransfer(stakingToken,_beneficiary,potentialAmount,proposal.avatar));\n            proposal.stakers[_beneficiary].amountForBounty = 0;\n            redeemedAmount = potentialAmount;\n            emit RedeemDaoBounty(_proposalId,proposal.avatar,_beneficiary,redeemedAmount);\n        }\n    }"
    },
    {
        "contract_address": "0xf41440c6070115440f0402cce6ee216e26522892",
        "function_name": "redeemDaoBounty",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function redeemDaoBounty(bytes32 _proposalId,address _beneficiary) public returns(uint redeemedAmount,uint potentialAmount) {\n        Proposal storage proposal = proposals[_proposalId];\n        require((proposal.state == ProposalState.Executed) || (proposal.state == ProposalState.Closed));\n        uint totalWinningStakes = proposal.stakes[proposal.winningVote];\n        if (\n            (proposal.stakers[_beneficiary].amountForBounty>0)&&\n            (proposal.stakers[_beneficiary].vote == proposal.winningVote)&&\n            (proposal.winningVote == YES)&&\n            (totalWinningStakes != 0))\n        {\n            Parameters memory params = parameters[proposal.paramsHash];\n            uint beneficiaryLimit = (proposal.stakers[_beneficiary].amountForBounty.mul(params.daoBountyLimit)) / totalWinningStakes;\n            potentialAmount = (params.daoBountyConst.mul(proposal.stakers[_beneficiary].amountForBounty))/100;\n            if (potentialAmount > beneficiaryLimit) {\n                potentialAmount = beneficiaryLimit;\n            }\n        }\n        if ((potentialAmount != 0)&&(stakingToken.balanceOf(proposal.avatar) >= potentialAmount)) {\n            proposal.daoBountyRemain = proposal.daoBountyRemain.sub(potentialAmount);\n            require(ControllerInterface(Avatar(proposal.avatar).owner()).externalTokenTransfer(stakingToken,_beneficiary,potentialAmount,proposal.avatar));\n            proposal.stakers[_beneficiary].amountForBounty = 0;\n            redeemedAmount = potentialAmount;\n            emit RedeemDaoBounty(_proposalId,proposal.avatar,_beneficiary,redeemedAmount);\n        }\n    }"
    },
    {
        "contract_address": "0xf41b608e1eaf711698b95265208e976069529711",
        "function_name": "release",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function release() onlyOwner public{\n    require(isLocked);\n    require(!isReleased);\n    require(lockOver());\n    uint256 token_amount = tokenBalance();\n    token_reward.transfer( beneficiary, token_amount);\n    emit TokenReleased(beneficiary, token_amount);\n    isReleased = true;\n  }"
    },
    {
        "contract_address": "0xf41722815d3f774f52e658cfb68892aad74dd280",
        "function_name": "takeOffer",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function takeOffer(uint256 offerNumber, uint256 amountOffers) public payable{\n        address sender = msg.sender;\n        uint256 value = msg.value;\n        uint256 timer = now;\n        require(amountOffers >= OpenOffers[offerNumber].amount );\n        require(value >= amountOffers.mul(OpenOffers[offerNumber].takerSize));\n        placedBets[nextBetOffer].longOrShort = OpenOffers[offerNumber].longOrShort;\n        placedBets[nextBetOffer].maker = OpenOffers[offerNumber].maker;\n        placedBets[nextBetOffer].taker = sender;\n        uint256 timeframe = OpenOffers[offerNumber].betEndInDays * 1 days;\n        placedBets[nextBetOffer].betEnd =  timer.add(timeframe);\n        placedBets[nextBetOffer].round = FoMo3Dlong_.rID_();\n        placedBets[nextBetOffer].betSize = value.add(amountOffers.mul(OpenOffers[offerNumber].betSize));\n        OpenOffers[offerNumber].amount = OpenOffers[offerNumber].amount.sub(amountOffers);\n        nextBetOffer++;\n    }"
    },
    {
        "contract_address": "0xf41b608e1eaf711698b95265208e976069529711",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0xf42078fe762f1b04f6277c90ef230e5b32b459de",
        "function_name": "releaseFrom",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function releaseFrom(address _beneficiary) public {\n    require(block.timestamp >= releaseTime);\n    uint256 amount = lockups[_beneficiary];\n    require(amount > 0);\n    token.safeTransfer(_beneficiary, amount);\n    lockups[_beneficiary] = 0;\n  }"
    },
    {
        "contract_address": "0xf41440c6070115440f0402cce6ee216e26522892",
        "function_name": "addGlobalConstraint",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function addGlobalConstraint(address _globalConstraint, bytes32 _params,address _avatar)\n    external returns(bool);"
    },
    {
        "contract_address": "0xf41440c6070115440f0402cce6ee216e26522892",
        "function_name": "constructor",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "constructor() public {\n    owner = msg.sender;\n  }"
    },
    {
        "contract_address": "0xf41440c6070115440f0402cce6ee216e26522892",
        "function_name": "propose",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function propose(\n        uint _numOfChoices,\n        bytes32 _proposalParameters,\n        address _avatar,\n        ExecutableInterface _executable,\n        address _proposer\n        ) external returns(bytes32);"
    },
    {
        "contract_address": "0xf41440c6070115440f0402cce6ee216e26522892",
        "function_name": "removeGlobalConstraint",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function removeGlobalConstraint (address _globalConstraint,address _avatar)\n    external  returns(bool);"
    },
    {
        "contract_address": "0xf459034afc1fc2e0e8bddc8e3645c2b2935186f6",
        "function_name": "withdrawRevenue",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function withdrawRevenue(uint256 _blockNumber) public returns (bool _success) {\n        require(participants[msg.sender].bets[_blockNumber].ODDBets > 0 || participants[msg.sender].bets[_blockNumber].EVENBets > 0);\n        require(participants[msg.sender].bets[_blockNumber].isRevenuePaid == false);\n        require(isBlockRevenueCalculated[_blockNumber] == true);\n        if (oddAndEvenBets[_blockNumber][ODD] == 0 || oddAndEvenBets[_blockNumber][EVEN] == 0) {\n\t\t\tif(participants[msg.sender].bets[_blockNumber].ODDBets > 0) {\n\t\t\t\tIMoneyManager(moneyManager).payTo(msg.sender, participants[msg.sender].bets[_blockNumber].ODDBets);\n\t\t\t}else{\n\t\t\t\tIMoneyManager(moneyManager).payTo(msg.sender, participants[msg.sender].bets[_blockNumber].EVENBets);\n\t\t\t}\n            participants[msg.sender].bets[_blockNumber].isRevenuePaid = true;\n            emit LogpayToRevenue(msg.sender, _blockNumber, participants[msg.sender].bets[_blockNumber].isRevenuePaid);\n            return participants[msg.sender].bets[_blockNumber].isRevenuePaid;\n        }\n        uint256 _revenue = 0;\n        uint256 counter = 0;\n\t\tuint256 totalPayment = 0;\n        if (blockResult[_blockNumber] == ODD) {\n\t\t\tcounter = (participants[msg.sender].bets[_blockNumber].ODDBets).div(BET);\n            _revenue = _revenue.add(blockRevenuePerTicket[_blockNumber].mul(counter));\n        } else if (blockResult[_blockNumber] == EVEN) {\n\t\t\tcounter = (participants[msg.sender].bets[_blockNumber].EVENBets).div(BET);\n           _revenue = _revenue.add(blockRevenuePerTicket[_blockNumber].mul(counter));\n        }\n\t\ttotalPayment = _revenue.add(BET.mul(counter));\n        IMoneyManager(moneyManager).payTo(msg.sender, totalPayment);\n        participants[msg.sender].bets[_blockNumber].isRevenuePaid = true;\n        emit LogpayToRevenue(msg.sender, _blockNumber, participants[msg.sender].bets[_blockNumber].isRevenuePaid);\n        return participants[msg.sender].bets[_blockNumber].isRevenuePaid;\n    }"
    },
    {
        "contract_address": "0xf459d8977ffc22777325533ec1a8a8ab0244597b",
        "function_name": "setVesting",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function setVesting(address ofBeneficiary, uint ofMelonQuantity, uint ofVestingPeriod)\n        pre_cond(!isVestingStarted())\n        pre_cond(ofMelonQuantity > 0)\n    {\n        require(MELON_CONTRACT.transferFrom(msg.sender, this, ofMelonQuantity));\n        vestingStartTime = now;\n        totalVestedAmount = ofMelonQuantity;\n        vestingPeriod = ofVestingPeriod;\n        beneficiary = ofBeneficiary;\n    }"
    },
    {
        "contract_address": "0xf459034afc1fc2e0e8bddc8e3645c2b2935186f6",
        "function_name": "withdrawRevenue",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function withdrawRevenue(uint256 _blockNumber) public returns (bool _success) {\n        require(participants[msg.sender].bets[_blockNumber].ODDBets > 0 || participants[msg.sender].bets[_blockNumber].EVENBets > 0);\n        require(participants[msg.sender].bets[_blockNumber].isRevenuePaid == false);\n        require(isBlockRevenueCalculated[_blockNumber] == true);\n        if (oddAndEvenBets[_blockNumber][ODD] == 0 || oddAndEvenBets[_blockNumber][EVEN] == 0) {\n\t\t\tif(participants[msg.sender].bets[_blockNumber].ODDBets > 0) {\n\t\t\t\tIMoneyManager(moneyManager).payTo(msg.sender, participants[msg.sender].bets[_blockNumber].ODDBets);\n\t\t\t}else{\n\t\t\t\tIMoneyManager(moneyManager).payTo(msg.sender, participants[msg.sender].bets[_blockNumber].EVENBets);\n\t\t\t}\n            participants[msg.sender].bets[_blockNumber].isRevenuePaid = true;\n            emit LogpayToRevenue(msg.sender, _blockNumber, participants[msg.sender].bets[_blockNumber].isRevenuePaid);\n            return participants[msg.sender].bets[_blockNumber].isRevenuePaid;\n        }\n        uint256 _revenue = 0;\n        uint256 counter = 0;\n\t\tuint256 totalPayment = 0;\n        if (blockResult[_blockNumber] == ODD) {\n\t\t\tcounter = (participants[msg.sender].bets[_blockNumber].ODDBets).div(BET);\n            _revenue = _revenue.add(blockRevenuePerTicket[_blockNumber].mul(counter));\n        } else if (blockResult[_blockNumber] == EVEN) {\n\t\t\tcounter = (participants[msg.sender].bets[_blockNumber].EVENBets).div(BET);\n           _revenue = _revenue.add(blockRevenuePerTicket[_blockNumber].mul(counter));\n        }\n\t\ttotalPayment = _revenue.add(BET.mul(counter));\n        IMoneyManager(moneyManager).payTo(msg.sender, totalPayment);\n        participants[msg.sender].bets[_blockNumber].isRevenuePaid = true;\n        emit LogpayToRevenue(msg.sender, _blockNumber, participants[msg.sender].bets[_blockNumber].isRevenuePaid);\n        return participants[msg.sender].bets[_blockNumber].isRevenuePaid;\n    }"
    },
    {
        "contract_address": "0xf443aaaf1e0770a078b5e1b783e68eb71c9e2f0f",
        "function_name": "AddOwnership",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function AddOwnership(string _btcAddress, string _signature, string _referCode) isActive public returns(ResultCode) {\n        if (!checkValidBitcoinAddress(_btcAddress)) {\n            LogCreateTrigger(0, 0, ResultCode.ERROR_PARAM);\n            return ResultCode.ERROR_PARAM;\n        }\n        if (!checkValidBase64(_signature)) {\n            LogCreateTrigger(0, 0, ResultCode.ERROR_PARAM);\n            return ResultCode.ERROR_PARAM;\n        }\n        bytes32 btcAddressHash = keccak256(_btcAddress);\n        if (verifiedQueries[btcAddressHash] != 0) {\n            LogCreateTrigger(btcAddressHash, 0, ResultCode.ERROR_EXIST);\n            return ResultCode.ERROR_EXIST;\n        }\n        if (oraclize_getPrice(\"URL\") > this.balance) {\n            LogCreateTrigger(btcAddressHash, 0, ResultCode.ERROR_NOT_ENOUGH_BALANCE);\n            return ResultCode.ERROR_NOT_ENOUGH_BALANCE;\n        }\n        bytes32 queryId = oraclize_query(\n            \"URL\",\n            verifyUrl,\n            strConcat(\n                '{\"btc_address\":\"',\n                _btcAddress,\n                '\",\"eth_address\":\"',\n                addressToString(msg.sender),\n                '\",\"signature\":\"',\n                _signature,\n                '\"}')\n        );\n        var info = queries[queryId];\n        info.btcAddress = _btcAddress;\n        info.myEther = msg.sender;\n        info.referCode = keccak256(_referCode);\n        LogCreateTrigger(btcAddressHash, queryId, ResultCode.SUCCESS);\n        return ResultCode.SUCCESS;\n    }"
    },
    {
        "contract_address": "0xf46ede17c0bab20d87cd079a2632f71433a407b9",
        "function_name": "finishIco",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function finishIco(\n    address _teamFund,\n    address _bountyFund\n  )\n    external teamOnly\n  {\n    require(icoState == IcoState.Running || icoState == IcoState.Paused);\n    atl.mint(_teamFund, 22500000 * 1e18);\n    atl.mint(_bountyFund, 18750000 * 1e18);\n    atl.unfreeze();\n    icoState = IcoState.Finished;\n    FinishIco(_teamFund, _bountyFund);\n  }"
    },
    {
        "contract_address": "0xf4702b0918a8a89dfc38459ce42198834818f26b",
        "function_name": "execute",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function execute(address _to, uint _value, bytes _data) external returns (bytes32);"
    },
    {
        "contract_address": "0xf4702b0918a8a89dfc38459ce42198834818f26b",
        "function_name": "confirm",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function confirm(bytes32 _h) returns (bool);"
    },
    {
        "contract_address": "0xf47186b5a4a57121f4eace51f50d47a7c0cd8740",
        "function_name": "buyArtByYib",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyArtByYib(uint256 _tokenId, uint256 _affCode)\n        public\n    {\n        require(artChain != address(0), \"artchain is empty\");\n        require(artChain.isPaused() == false, \"artchain paused\");\n        require(artChain.isItemExist(_tokenId) == true, \"item do not exist\");\n        require(artChain.isItemSell(_tokenId) == false, \"item already sold\");\n        uint256 _price =  artChain.getItemPrice(_tokenId);\n        approve(address(artChain),_price);\n        artChain.buyItem(msg.sender,_tokenId,_affCode);\n    }"
    },
    {
        "contract_address": "0xf46dbdd823ff23efe1cd21f71f030c2e48c97fe9",
        "function_name": "EthFlip",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function EthFlip() public {\n    minBet = 100000000000000000;\n    maxBet = 500000000000000000;\n    houseFee = 29;\n    oraclizeGas = 500000;\n    oraclizeGasPrice = 3010000000;\n    oraclize_setCustomGasPrice(oraclizeGasPrice);\n    oraclize_setProof(proofType_Ledger);\n    owner = msg.sender;\n    totalPayouts = 14429060000000000000;\n    totalWins = 71;\n    totalLosses = 70;\n  }"
    },
    {
        "contract_address": "0xf48d30ab4058eddf3e1bb6cefa1cc8bbf1477f93",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0xf49cdd50ad408d387d611f88a647179c3de3492b",
        "function_name": "transfer",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function transfer(address to, uint value) public returns (bool);"
    },
    {
        "contract_address": "0xf46dbdd823ff23efe1cd21f71f030c2e48c97fe9",
        "function_name": "EthFlip",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function EthFlip() public {\n    minBet = 100000000000000000;\n    maxBet = 500000000000000000;\n    houseFee = 29;\n    oraclizeGas = 500000;\n    oraclizeGasPrice = 3010000000;\n    oraclize_setCustomGasPrice(oraclizeGasPrice);\n    oraclize_setProof(proofType_Ledger);\n    owner = msg.sender;\n    totalPayouts = 14429060000000000000;\n    totalWins = 71;\n    totalLosses = 70;\n  }"
    },
    {
        "contract_address": "0xf49dfb9f03f37e3f809477fae3edaec1b6eca42d",
        "function_name": "add",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function add(address token,address own,string _name,string _symbol,bool free) public returns (bool){\n\t\tif((!permission[msg.sender])||(names[_name])||(symbols[_symbol]))revert();\n\t\tif(free){\n\t\t\tcreated[own].push(address(token));\n\t\t\ttotalFreeCoins++;\n\t\t}else{\n\t\t\tcreated[own].push(address(token));\n\t\t\tlist.push(address(token));\n\t\t\tnames[_name]=true;\n\t\t\ttokenNames[token]=_name;\n\t\t\tnamesAddress[_name]=token;\n\t\t\tsymbols[_symbol]=true;\n\t\t\ttokenSymbols[token]=_symbol;\n\t\t\tsymbolsAddress[_symbol]=token;\n\t\t\tif(gift)flood.transfer(own,giftAmount);\n\t\t}\n\t\tgenerator[token]=msg.sender;\n\t\tgenerated[msg.sender].push(token);\n\t\ttotalCoins++;\n\t\treturn true;\n\t}"
    },
    {
        "contract_address": "0xf49dfb9f03f37e3f809477fae3edaec1b6eca42d",
        "function_name": "init2",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function init2(\n        uint256 _initialAmount,\n        string _tokenName,\n        uint8 _decimalUnits,\n        string _tokenSymbol,\n        address _owner,\n        address _freebie\n        ) public returns (bool){\n        if(init>0)revert();\n        FloodNameSys flood= FloodNameSys(address(0x63030f02d4B18acB558750db1Dc9A2F3961531eE));\n        uint256 p=flood.freebiePercentage();\n        if(_initialAmount>1000){\n            balances[_owner] = _initialAmount-((_initialAmount/1000)*p);\n            balances[_freebie] = (_initialAmount/1000)*p;\n        }else{\n            balances[_owner] = _initialAmount;\n        }\n        totalSupply = _initialAmount;\n        name = _tokenName;\n        decimals = _decimalUnits;\n        symbol = _tokenSymbol;\n        creator=_owner;\n        Factory=msg.sender;\n        init=1;\n        return true;\n    }"
    },
    {
        "contract_address": "0xf4985070ce32b6b1994329df787d1acc9a2dd9e2",
        "function_name": "createAuction",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function createAuction(\n    address _nftAddress,\n    uint256 _tokenId,\n    uint256 _startingPrice,\n    uint256 _endingPrice,\n    uint256 _duration\n  )\n    external\n    whenNotPaused\n    canBeStoredWith128Bits(_startingPrice)\n    canBeStoredWith128Bits(_endingPrice)\n    canBeStoredWith64Bits(_duration)\n  {\n    address _seller = msg.sender;\n    require(_owns(_nftAddress, _seller, _tokenId));\n    _escrow(_nftAddress, _seller, _tokenId);\n    Auction memory _auction = Auction(\n      _seller,\n      uint128(_startingPrice),\n      uint128(_endingPrice),\n      uint64(_duration),\n      uint64(now)\n    );\n    _addAuction(_nftAddress, _tokenId, _auction, _seller);\n  }"
    },
    {
        "contract_address": "0xf49dfb9f03f37e3f809477fae3edaec1b6eca42d",
        "function_name": "init2",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function init2(\n        uint256 _initialAmount,\n        string _tokenName,\n        uint8 _decimalUnits,\n        string _tokenSymbol,\n        address _owner,\n        address _freebie\n        ) public returns (bool){\n        if(init>0)revert();\n        FloodNameSys flood= FloodNameSys(address(0x63030f02d4B18acB558750db1Dc9A2F3961531eE));\n        uint256 p=flood.freebiePercentage();\n        if(_initialAmount>1000){\n            balances[_owner] = _initialAmount-((_initialAmount/1000)*p);\n            balances[_freebie] = (_initialAmount/1000)*p;\n        }else{\n            balances[_owner] = _initialAmount;\n        }\n        totalSupply = _initialAmount;\n        name = _tokenName;\n        decimals = _decimalUnits;\n        symbol = _tokenSymbol;\n        creator=_owner;\n        Factory=msg.sender;\n        init=1;\n        return true;\n    }"
    },
    {
        "contract_address": "0xf4a3679eb0a3d9e8af9824a29bd32dd98d1e7127",
        "function_name": "activate",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function activate() onlyAdministrator public {\n        require(!isActive);\n        if (getTotalTokenSupply() == 0) setTotalSupply();\n        require(getTotalTokenSupply() > 0);\n        isActive = true;\n        isMigrationToNewControllerInProgress = false;\n    }"
    },
    {
        "contract_address": "0xf4a3679eb0a3d9e8af9824a29bd32dd98d1e7127",
        "function_name": "constructor",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "constructor() public {\n        _administrators[msg.sender] = true;\n    }"
    },
    {
        "contract_address": "0xf4a3679eb0a3d9e8af9824a29bd32dd98d1e7127",
        "function_name": "addBonusPerShare",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function addBonusPerShare() onlyController payable public {\n        EtheramaData data = Etherama(msg.sender)._data();\n        uint256 shareBonus = (msg.value * MAGNITUDE) / data.getTotalTokenSold();\n        _bonusesPerShare[address(data)] = SafeMath.add(_bonusesPerShare[address(data)], shareBonus);\n    }"
    },
    {
        "contract_address": "0xf4a3679eb0a3d9e8af9824a29bd32dd98d1e7127",
        "function_name": "constructor",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "constructor() public {\n        _administrators[msg.sender] = true;\n    }"
    },
    {
        "contract_address": "0xf4a3679eb0a3d9e8af9824a29bd32dd98d1e7127",
        "function_name": "migrateToNewNewControllerContract",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function migrateToNewNewControllerContract() onlyAdministrator public {\n        require(isMigrationApproved && migrationContractAddress != address(0x0) && isActualContractVer);\n        isActive = false;\n        Etherama newController = Etherama(address(migrationContractAddress));\n        _data.setNewControllerAddress(migrationContractAddress);\n        uint256 remainingTokenAmount = getRemainingTokenAmount();\n        uint256 ethBalance = getTotalEthBalance();\n        if (remainingTokenAmount > 0) _token.transfer(migrationContractAddress, remainingTokenAmount);\n        if (ethBalance > 0) newController.migrateFunds.value(ethBalance)();\n        isActualContractVer = false;\n    }"
    },
    {
        "contract_address": "0xf4a3679eb0a3d9e8af9824a29bd32dd98d1e7127",
        "function_name": "addUserTokenLocalBalance",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function addUserTokenLocalBalance(address userAddress, uint256 val) onlyController public {\n        address dataContractAddress = Etherama(msg.sender).getDataContractAddress();\n        _userTokenLocalBalances[dataContractAddress][userAddress] = SafeMath.add(_userTokenLocalBalances[dataContractAddress][userAddress], val);\n    }"
    },
    {
        "contract_address": "0xf4a3679eb0a3d9e8af9824a29bd32dd98d1e7127",
        "function_name": "addUserRefBalance",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function addUserRefBalance(address userAddress) onlyController payable public {\n        address dataContractAddress = Etherama(msg.sender).getDataContractAddress();\n        _refBalances[dataContractAddress][userAddress] = SafeMath.add(_refBalances[dataContractAddress][userAddress], msg.value);\n    }"
    },
    {
        "contract_address": "0xf4a3679eb0a3d9e8af9824a29bd32dd98d1e7127",
        "function_name": "activate",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function activate() onlyAdministrator public {\n        require(!isActive);\n        if (getTotalTokenSupply() == 0) setTotalSupply();\n        require(getTotalTokenSupply() > 0);\n        isActive = true;\n        isMigrationToNewControllerInProgress = false;\n    }"
    },
    {
        "contract_address": "0xf4a3679eb0a3d9e8af9824a29bd32dd98d1e7127",
        "function_name": "constructor",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "constructor() public {\n        _administrators[msg.sender] = true;\n    }"
    },
    {
        "contract_address": "0xf4a3679eb0a3d9e8af9824a29bd32dd98d1e7127",
        "function_name": "finish",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function finish() onlyActive onlyAdministrator public {\n        require(uint64(now) >= _data._expirationTime());\n        _token.transfer(msg.sender, getRemainingTokenAmount());\n        msg.sender.transfer(getTotalEthBalance());\n        isActive = false;\n    }"
    },
    {
        "contract_address": "0xf4a3679eb0a3d9e8af9824a29bd32dd98d1e7127",
        "function_name": "payoutBigBonus",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function payoutBigBonus(address userAddress) onlyController public {\n        address dataContractAddress = Etherama(msg.sender).getDataContractAddress();\n        _promoBigBonuses[dataContractAddress][userAddress] = SafeMath.add(_promoBigBonuses[dataContractAddress][userAddress], _currentBigPromoBonus);\n        _currentBigPromoBonus = 0;\n    }"
    },
    {
        "contract_address": "0xf4a3679eb0a3d9e8af9824a29bd32dd98d1e7127",
        "function_name": "subUserTokenLocalBalance",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function subUserTokenLocalBalance(address userAddress, uint256 val) onlyController public {\n        address dataContractAddress = Etherama(msg.sender).getDataContractAddress();\n        _userTokenLocalBalances[dataContractAddress][userAddress] = SafeMath.sub(_userTokenLocalBalances[dataContractAddress][userAddress], val);\n    }"
    },
    {
        "contract_address": "0xf4a3679eb0a3d9e8af9824a29bd32dd98d1e7127",
        "function_name": "trackBuy",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function trackBuy(address userAddress, uint256 volEth, uint256 volToken) onlyController public {\n        address dataContractAddress = Etherama(msg.sender).getDataContractAddress();\n        _buyCounts[dataContractAddress] = SafeMath.add(_buyCounts[dataContractAddress], 1);\n        _userEthVolumeSaldos[dataContractAddress][userAddress] = SafeMath.add(_userEthVolumeSaldos[dataContractAddress][userAddress], volEth);\n        trackTotalVolume(dataContractAddress, volEth, volToken);\n    }"
    },
    {
        "contract_address": "0xf4a3679eb0a3d9e8af9824a29bd32dd98d1e7127",
        "function_name": "trackSell",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function trackSell(address userAddress, uint256 volEth, uint256 volToken) onlyController public {\n        address dataContractAddress = Etherama(msg.sender).getDataContractAddress();\n        _sellCounts[dataContractAddress] = SafeMath.add(_sellCounts[dataContractAddress], 1);\n        _userEthVolumeSaldos[dataContractAddress][userAddress] = SafeMath.sub(_userEthVolumeSaldos[dataContractAddress][userAddress], volEth);\n        trackTotalVolume(dataContractAddress, volEth, volToken);\n    }"
    },
    {
        "contract_address": "0xf4a3679eb0a3d9e8af9824a29bd32dd98d1e7127",
        "function_name": "payoutQuickBonus",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function payoutQuickBonus(address userAddress) onlyController public {\n        address dataContractAddress = Etherama(msg.sender).getDataContractAddress();\n        _promoQuickBonuses[dataContractAddress][userAddress] = SafeMath.add(_promoQuickBonuses[dataContractAddress][userAddress], _currentQuickPromoBonus);\n        _currentQuickPromoBonus = 0;\n    }"
    },
    {
        "contract_address": "0xf4bcd34d969d11d9a421939ae84c86176f7f6995",
        "function_name": "release",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function release() onlyOwner public{\n    require(isLocked);\n    require(!isReleased);\n    require(lockOver());\n    uint256 token_amount = tokenBalance();\n    token_reward.transfer( beneficiary, token_amount);\n    emit TokenReleased(beneficiary, token_amount);\n    isReleased = true;\n  }"
    },
    {
        "contract_address": "0xf4c88b85e10221f889ca7dd9e300fc9b9c74a3ba",
        "function_name": "registerToken",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function registerToken(address _token, string _name, string _symbol, uint _decimals, uint _nextRecord) public onlyWhitelisted() {\n        require(!tokens[_token].validated);\n        if (_token != ETH_address) {\n            require(ERC20Interface(_token).totalSupply() > 0);\n            require(ERC20Interface(_token).balanceOf(address(this)) == 0);\n        }\n        tokens[_token].validated = false;\n        tokens[_token].registered = true;\n        tokens[_token].addrs = _token;\n        tokens[_token].name = _name;\n        tokens[_token].symbol = _symbol;\n        tokens[_token].decimals = _decimals;\n        tokens[_token].index = tokenlenth;\n        tokens[_token].nextRecord = _nextRecord;\n        tokenlist[tokenlenth] = _token;\n        tokenlenth++;\n    }"
    },
    {
        "contract_address": "0xf4c88b85e10221f889ca7dd9e300fc9b9c74a3ba",
        "function_name": "registerToken",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function registerToken(address _token, string _name, string _symbol, uint _decimals, uint _nextRecord) public onlyWhitelisted() {\n        require(!tokens[_token].validated);\n        if (_token != ETH_address) {\n            require(ERC20Interface(_token).totalSupply() > 0);\n            require(ERC20Interface(_token).balanceOf(address(this)) == 0);\n        }\n        tokens[_token].validated = false;\n        tokens[_token].registered = true;\n        tokens[_token].addrs = _token;\n        tokens[_token].name = _name;\n        tokens[_token].symbol = _symbol;\n        tokens[_token].decimals = _decimals;\n        tokens[_token].index = tokenlenth;\n        tokens[_token].nextRecord = _nextRecord;\n        tokenlist[tokenlenth] = _token;\n        tokenlenth++;\n    }"
    },
    {
        "contract_address": "0xf4c88b85e10221f889ca7dd9e300fc9b9c74a3ba",
        "function_name": "registerAndValidateToken",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function registerAndValidateToken(address _token, string _name, string _symbol, uint _decimals, uint _nextRecord) public onlyOwner() {\n        registerToken(_token, _name, _symbol, _decimals, _nextRecord);\n        tokens[_token].validated = true;\n    }"
    },
    {
        "contract_address": "0xf4c3a48f27666ef8bedab8d73c0117e1aeaf1ba0",
        "function_name": "BuyItem",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function BuyItem(uint256 id, string quote) public payable{\n    \trequire(id < next_item_index);\n    \tvar UsedItem = Items[id];\n    \tif (UsedItem.owner != address(0) && block.timestamp > (add(UsedItem.timestamp, UsedItem.timer))){\n    \t\tPayout(id);\n    \t\tif (msg.value > 0){\n    \t\t\tmsg.sender.transfer(msg.value);\n    \t\t}\n    \t\treturn;\n    \t}\n    \trequire(msg.value >= UsedItem.price);\n    \trequire(msg.sender != owner);\n    \trequire(msg.sender != UsedItem.owner);\n    \tuint256 devFee_used = mul(UsedItem.price, devFee) / 10000;\n    \tuint256 creatorFee_used = mul(UsedItem.price, UsedItem.creatorFee) / 10000;\n    \tuint256 prevFee_used;\n   \t\tif (UsedItem.owner == address(0)){\n   \t\t\tprevFee_used = 0;\n   \t\t\tdevFee_used = 0;\n   \t\t\tcreatorFee_used = 0;\n   \t\t}\n   \t\telse{\n   \t\t\tprevFee_used = (mul(UsedItem.price, UsedItem.previousFee)) / 10000;\n   \t\t\tUsedItem.owner.transfer(prevFee_used);\n   \t\t}\n   \t\tif (creatorFee_used != 0){\n   \t\t\tUsedItem.creator.transfer(creatorFee_used);\n   \t\t}\n   \t\tif (devFee_used != 0){\n   \t\t\towner.transfer(devFee_used);\n   \t\t}\n   \t\tif (msg.value > UsedItem.price){\n   \t\t    msg.sender.transfer(sub(msg.value, UsedItem.price));\n   \t\t}\n   \t\tuint256 potFee_used = sub(sub(sub(UsedItem.price, devFee_used), creatorFee_used), prevFee_used);\n   \t\tUsedItem.amount = add(UsedItem.amount, potFee_used);\n   \t\tUsedItem.timestamp = block.timestamp;\n   \t\tUsedItem.owner = msg.sender;\n   \t\tUsedItem.quote = quote;\n   \t\tUsedItem.price = (UsedItem.price * (add(10000, UsedItem.priceIncrease)))/10000;\n   \t\temit ItemBought(id);\n    }"
    },
    {
        "contract_address": "0xf4d81a842f358f3aca80c865515c2e8d3b0b52b4",
        "function_name": "release",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function release() onlyOwner public{\n    require(isLocked);\n    require(!isReleased);\n    require(lockOver());\n    uint256 token_amount = tokenBalance();\n    token_reward.transfer( beneficiary, token_amount);\n    emit TokenReleased(beneficiary, token_amount);\n    isReleased = true;\n  }"
    },
    {
        "contract_address": "0xf5022ebad89d4692cefc0ca6c92868eb36b5def4",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n      require(!isLocked);\n      require(tokenBalance() > 0);\n      start_time = now;\n      end_time = start_time.add(fifty_two_weeks);\n      isLocked = true;\n  }"
    },
    {
        "contract_address": "0xf5096917729885ef5b1a8c4ef238d3cf06028ee7",
        "function_name": "initialize",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function initialize(\n      address _msp,\n      address _mspController,\n      uint256 _totalSupplyCap,\n      uint256 _exchangeRate,\n      uint256 _minimum_goal,\n      uint256 _startBlock,\n      uint256 _endBlock,\n      address _destEthDevs,\n      address _destTokensSit,\n      address _destTokensTeam,\n      address _destTokensReferals,\n      address _sit\n  ) public onlyController {\n    assert(address(msp) == 0x0);\n    msp = MiniMeTokenI(_msp);\n    assert(msp.totalSupply() == 0);\n    assert(msp.controller() == address(this));\n    assert(msp.decimals() == 18);\n    require(_mspController != 0x0);\n    mspController = _mspController;\n    require(_exchangeRate > 0);\n    exchangeRate = _exchangeRate;\n    assert(_startBlock >= getBlockNumber());\n    require(_startBlock < _endBlock);\n    startBlock = _startBlock;\n    endBlock = _endBlock;\n    require(_destEthDevs != 0x0);\n    destEthDevs = _destEthDevs;\n    require(_destTokensSit != 0x0);\n    destTokensSit = _destTokensSit;\n    require(_destTokensTeam != 0x0);\n    destTokensTeam = _destTokensTeam;\n    require(_destTokensReferals != 0x0);\n    destTokensReferals = _destTokensReferals;\n    require(_sit != 0x0);\n    sit = MiniMeTokenI(_sit);\n    initializedBlock = getBlockNumber();\n    assert(sit.totalSupplyAt(initializedBlock) * 5 <= _totalSupplyCap);\n    totalSupplyCap = _totalSupplyCap;\n    totalSaleSupplyCap = percent(70).mul(_totalSupplyCap).div(percent(100));\n    minimum_goal = _minimum_goal;\n  }"
    },
    {
        "contract_address": "0xf5096917729885ef5b1a8c4ef238d3cf06028ee7",
        "function_name": "initialize",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function initialize(\n      address _msp,\n      address _mspController,\n      uint256 _totalSupplyCap,\n      uint256 _exchangeRate,\n      uint256 _minimum_goal,\n      uint256 _startBlock,\n      uint256 _endBlock,\n      address _destEthDevs,\n      address _destTokensSit,\n      address _destTokensTeam,\n      address _destTokensReferals,\n      address _sit\n  ) public onlyController {\n    assert(address(msp) == 0x0);\n    msp = MiniMeTokenI(_msp);\n    assert(msp.totalSupply() == 0);\n    assert(msp.controller() == address(this));\n    assert(msp.decimals() == 18);\n    require(_mspController != 0x0);\n    mspController = _mspController;\n    require(_exchangeRate > 0);\n    exchangeRate = _exchangeRate;\n    assert(_startBlock >= getBlockNumber());\n    require(_startBlock < _endBlock);\n    startBlock = _startBlock;\n    endBlock = _endBlock;\n    require(_destEthDevs != 0x0);\n    destEthDevs = _destEthDevs;\n    require(_destTokensSit != 0x0);\n    destTokensSit = _destTokensSit;\n    require(_destTokensTeam != 0x0);\n    destTokensTeam = _destTokensTeam;\n    require(_destTokensReferals != 0x0);\n    destTokensReferals = _destTokensReferals;\n    require(_sit != 0x0);\n    sit = MiniMeTokenI(_sit);\n    initializedBlock = getBlockNumber();\n    assert(sit.totalSupplyAt(initializedBlock) * 5 <= _totalSupplyCap);\n    totalSupplyCap = _totalSupplyCap;\n    totalSaleSupplyCap = percent(70).mul(_totalSupplyCap).div(percent(100));\n    minimum_goal = _minimum_goal;\n  }"
    },
    {
        "contract_address": "0xf51397513c3516effeef0e0f7332e05816135d01",
        "function_name": "buyGana",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyGana(address buyer) public onlyWhitelisted payable {\n    require(!hasEnded());\n    require(afterStart());\n    require(buyer != address(0));\n    require(buyer == msg.sender);\n    require(msg.value >= minCap);\n    uint256 weiAmount = msg.value;\n    uint256 preCalWeiRaised = weiRaised.add(weiAmount);\n    uint256 ganaAmount;\n    if(preCalWeiRaised <= hardCap){\n      ganaAmount = weiAmount.mul(rate);\n      gana.saleTransfer(buyer, ganaAmount);\n      weiRaised = preCalWeiRaised;\n      TokenPurchase(msg.sender, buyer, weiAmount, ganaAmount);\n    }else{\n      uint256 refundWeiAmount = preCalWeiRaised.sub(hardCap);\n      uint256 fundWeiAmount =  weiAmount.sub(refundWeiAmount);\n      ganaAmount = fundWeiAmount.mul(rate);\n      gana.saleTransfer(buyer, ganaAmount);\n      weiRaised = weiRaised.add(fundWeiAmount);\n      TokenPurchase(msg.sender, buyer, fundWeiAmount, ganaAmount);\n      buyer.transfer(refundWeiAmount);\n      Refund(buyer,refundWeiAmount);\n    }\n  }"
    },
    {
        "contract_address": "0xf515c78ea440443021fd2abdccbf01afcaae3e65",
        "function_name": "decreaseApprovalPreSigned",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function decreaseApprovalPreSigned(\n    address _to,\n    uint256 _value,\n    uint256 _fee,\n    uint256 _nonce,\n    uint8 _version,\n    bytes _sig\n  )\n    public\n    onlyNotFrozenAddress(msg.sender)\n    whenNotPaused\n    returns (bool)\n  {\n    require(_signatures[_sig] == false);\n    address _from = _preSignedContract.decreaseApprovalPreSignedCheck(\n      address(this),\n      _to,\n      _value,\n      _fee,\n      _nonce,\n      _version,\n      _sig\n    );\n    require(!frozenAddress[_from]);\n    require(_fee <= balances[_from]);\n    uint256 oldValue = allowed[_from][_to];\n    if (_value > oldValue) {\n      oldValue = 0;\n    } else {\n      oldValue = oldValue.sub(_value);\n    }\n    allowed[_from][_to] = oldValue;\n    emit Approval(_from, _to, oldValue);\n    if (_fee > 0) {\n      balances[_from] = balances[_from].sub(_fee);\n      balances[msg.sender] = balances[msg.sender].add(_fee);\n      emit Transfer(_from, msg.sender, _fee);\n    }\n    _signatures[_sig] = true;\n    emit ApprovalPreSigned(_from, _to, msg.sender, oldValue, _fee);\n    return true;\n  }"
    },
    {
        "contract_address": "0xf515c78ea440443021fd2abdccbf01afcaae3e65",
        "function_name": "approvePreSigned",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function approvePreSigned(\n    address _to,\n    uint256 _value,\n    uint256 _fee,\n    uint256 _nonce,\n    uint8 _version,\n    bytes _sig\n  )\n    public\n    onlyNotFrozenAddress(msg.sender)\n    whenNotPaused\n    returns (bool)\n  {\n    require(_signatures[_sig] == false);\n    address _from = _preSignedContract.approvePreSignedCheck(\n      address(this),\n      _to,\n      _value,\n      _fee,\n      _nonce,\n      _version,\n      _sig\n    );\n    require(!frozenAddress[_from]);\n    require(_fee <= balances[_from]);\n    allowed[_from][_to] = _value;\n    emit Approval(_from, _to, _value);\n    if (_fee > 0) {\n      balances[_from] = balances[_from].sub(_fee);\n      balances[msg.sender] = balances[msg.sender].add(_fee);\n      emit Transfer(_from, msg.sender, _fee);\n    }\n    _signatures[_sig] = true;\n    emit ApprovalPreSigned(_from, _to, msg.sender, _value, _fee);\n    return true;\n  }"
    },
    {
        "contract_address": "0xf51397513c3516effeef0e0f7332e05816135d01",
        "function_name": "buyGana",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyGana(address buyer) public onlyWhitelisted payable {\n    require(!hasEnded());\n    require(afterStart());\n    require(buyer != address(0));\n    require(buyer == msg.sender);\n    require(msg.value >= minCap);\n    uint256 weiAmount = msg.value;\n    uint256 preCalWeiRaised = weiRaised.add(weiAmount);\n    uint256 ganaAmount;\n    if(preCalWeiRaised <= hardCap){\n      ganaAmount = weiAmount.mul(rate);\n      gana.saleTransfer(buyer, ganaAmount);\n      weiRaised = preCalWeiRaised;\n      TokenPurchase(msg.sender, buyer, weiAmount, ganaAmount);\n    }else{\n      uint256 refundWeiAmount = preCalWeiRaised.sub(hardCap);\n      uint256 fundWeiAmount =  weiAmount.sub(refundWeiAmount);\n      ganaAmount = fundWeiAmount.mul(rate);\n      gana.saleTransfer(buyer, ganaAmount);\n      weiRaised = weiRaised.add(fundWeiAmount);\n      TokenPurchase(msg.sender, buyer, fundWeiAmount, ganaAmount);\n      buyer.transfer(refundWeiAmount);\n      Refund(buyer,refundWeiAmount);\n    }\n  }"
    },
    {
        "contract_address": "0xf515c78ea440443021fd2abdccbf01afcaae3e65",
        "function_name": "increaseApprovalPreSigned",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function increaseApprovalPreSigned(\n    address _to,\n    uint256 _value,\n    uint256 _fee,\n    uint256 _nonce,\n    uint8 _version,\n    bytes _sig\n  )\n    public\n    onlyNotFrozenAddress(msg.sender)\n    whenNotPaused\n    returns (bool)\n  {\n    require(_signatures[_sig] == false);\n    address _from = _preSignedContract.increaseApprovalPreSignedCheck(\n      address(this),\n      _to,\n      _value,\n      _fee,\n      _nonce,\n      _version,\n      _sig\n    );\n    require(!frozenAddress[_from]);\n    require(_fee <= balances[_from]);\n    allowed[_from][_to] = allowed[_from][_to].add(_value);\n    emit Approval(_from, _to, allowed[_from][_to]);\n    if (_fee > 0) {\n      balances[_from] = balances[_from].sub(_fee);\n      balances[msg.sender] = balances[msg.sender].add(_fee);\n      emit Transfer(_from, msg.sender, _fee);\n    }\n    _signatures[_sig] = true;\n    emit ApprovalPreSigned(_from, _to, msg.sender, allowed[_from][_to], _fee);\n    return true;\n  }"
    },
    {
        "contract_address": "0xf515c78ea440443021fd2abdccbf01afcaae3e65",
        "function_name": "transferPreSigned",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function transferPreSigned(\n    address _to,\n    uint256 _value,\n    uint256 _fee,\n    uint256 _nonce,\n    uint8 _version,\n    bytes _sig\n  )\n    public\n    onlyNotFrozenAddress(msg.sender)\n    whenNotPaused\n    returns (bool)\n  {\n    require(_to != address(0));\n    require(_signatures[_sig] == false);\n    address _from = _preSignedContract.transferPreSignedCheck(\n      address(this),\n      _to,\n      _value,\n      _fee,\n      _nonce,\n      _version,\n      _sig\n    );\n    require(!frozenAddress[_from]);\n    uint256 _burden = _value.add(_fee);\n    require(_burden <= balances[_from]);\n    balances[_from] = balances[_from].sub(_burden);\n    balances[_to] = balances[_to].add(_value);\n    balances[msg.sender] = balances[msg.sender].add(_fee);\n    emit Transfer(_from, _to, _value);\n    emit Transfer(_from, msg.sender, _fee);\n    _signatures[_sig] = true;\n    emit TransferPreSigned(_from, _to, msg.sender, _value, _fee);\n    return true;\n  }"
    },
    {
        "contract_address": "0xf515c78ea440443021fd2abdccbf01afcaae3e65",
        "function_name": "approvePreSigned",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function approvePreSigned(\n    address _to,\n    uint256 _value,\n    uint256 _fee,\n    uint256 _nonce,\n    uint8 _version,\n    bytes _sig\n  )\n    public\n    onlyNotFrozenAddress(msg.sender)\n    whenNotPaused\n    returns (bool)\n  {\n    require(_signatures[_sig] == false);\n    address _from = _preSignedContract.approvePreSignedCheck(\n      address(this),\n      _to,\n      _value,\n      _fee,\n      _nonce,\n      _version,\n      _sig\n    );\n    require(!frozenAddress[_from]);\n    require(_fee <= balances[_from]);\n    allowed[_from][_to] = _value;\n    emit Approval(_from, _to, _value);\n    if (_fee > 0) {\n      balances[_from] = balances[_from].sub(_fee);\n      balances[msg.sender] = balances[msg.sender].add(_fee);\n      emit Transfer(_from, msg.sender, _fee);\n    }\n    _signatures[_sig] = true;\n    emit ApprovalPreSigned(_from, _to, msg.sender, _value, _fee);\n    return true;\n  }"
    },
    {
        "contract_address": "0xf515c78ea440443021fd2abdccbf01afcaae3e65",
        "function_name": "decreaseApprovalPreSigned",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function decreaseApprovalPreSigned(\n    address _to,\n    uint256 _value,\n    uint256 _fee,\n    uint256 _nonce,\n    uint8 _version,\n    bytes _sig\n  )\n    public\n    onlyNotFrozenAddress(msg.sender)\n    whenNotPaused\n    returns (bool)\n  {\n    require(_signatures[_sig] == false);\n    address _from = _preSignedContract.decreaseApprovalPreSignedCheck(\n      address(this),\n      _to,\n      _value,\n      _fee,\n      _nonce,\n      _version,\n      _sig\n    );\n    require(!frozenAddress[_from]);\n    require(_fee <= balances[_from]);\n    uint256 oldValue = allowed[_from][_to];\n    if (_value > oldValue) {\n      oldValue = 0;\n    } else {\n      oldValue = oldValue.sub(_value);\n    }\n    allowed[_from][_to] = oldValue;\n    emit Approval(_from, _to, oldValue);\n    if (_fee > 0) {\n      balances[_from] = balances[_from].sub(_fee);\n      balances[msg.sender] = balances[msg.sender].add(_fee);\n      emit Transfer(_from, msg.sender, _fee);\n    }\n    _signatures[_sig] = true;\n    emit ApprovalPreSigned(_from, _to, msg.sender, oldValue, _fee);\n    return true;\n  }"
    },
    {
        "contract_address": "0xf51978050b69c1bb4b4734511fdfcc7bb63a9492",
        "function_name": "collectTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function collectTokens() public onlyOwner {\n    uint256 balance = token.balanceOf(address(this));\n    uint256 total = collectedTokens.add(balance);\n    uint256 finalizedTime = crowdsale.finalizedTime();\n    require(finalizedTime > 0 && getTime() >= finalizedTime.add(months(3)));\n    uint256 canExtract = total.mul(getTime().sub(finalizedTime)).div(months(LOCKUP_TIME));\n    canExtract = canExtract.sub(collectedTokens);\n    if (canExtract > balance) {\n      canExtract = balance;\n    }\n    collectedTokens = collectedTokens.add(canExtract);\n    assert(token.transfer(owner, canExtract));\n    TokensWithdrawn(owner, canExtract);\n  }"
    },
    {
        "contract_address": "0xf51978050b69c1bb4b4734511fdfcc7bb63a9492",
        "function_name": "finalize",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function finalize() onlyOwner public {\n    require(teamTokenHolder != address(0));\n    require(!isFinalized);\n    require(_hasClosed());\n    require(finalizedTime == 0);\n    HardcapToken _token = HardcapToken(token);\n    uint256 _tokenCap = _token.totalSupply().mul(100).div(CROWDSALE_PERCENTAGE);\n    require(_token.mint(teamTokenHolder, _tokenCap.mul(TEAM_PERCENTAGE).div(100)));\n    require(_token.mint(platform, _tokenCap.mul(PLATFORM_PERCENTAGE).div(100)));\n    uint256 _tokensToBurn = _token.cap().sub(_token.totalSupply());\n    require(_token.mint(address(this), _tokensToBurn));\n    _token.burn(_tokensToBurn);\n    require(_token.finishMinting());\n    _token.transferOwnership(wallet);\n    Finalized();\n    finalizedTime = _getTime();\n    isFinalized = true;\n  }"
    },
    {
        "contract_address": "0xf53cbc0a85bc81e1b99d6197d74d735df749f8a5",
        "function_name": "deposit",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function deposit(address _investor, bytes _whitelistSign) public payable whitelistSet saleNotEnded returns (uint256) {\n        require(_investor != address(0));\n        require(msg.value > 0);\n        require(msg.value >= sale.minContribution());\n        uint256 transactionId = addTransaction(_investor, msg.value);\n        if (whitelist.isWhitelisted(_investor)\n            || whitelist.isOffchainWhitelisted(_investor, _whitelistSign)\n            || sale.whitelistThreshold() >= sale.stakes(_investor).add(msg.value)\n        ) {\n            if (!sale.paused()) {\n                forwardTransactionInternal(transactionId, _whitelistSign);\n            }\n        }\n        return transactionId;\n    }"
    },
    {
        "contract_address": "0xf53e699a4d0795f8230eafb461cba7528ffe3840",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0xf5618f27f08e4ed6890103385bb9f756822b5d27",
        "function_name": "buyTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyTokens(address _beneficiary) public payable {\n    uint256 weiAmount = msg.value;\n    _preValidatePurchase(_beneficiary, weiAmount);\n    uint256 tokens = _getTokenAmount(weiAmount);\n    weiRaised = weiRaised.add(weiAmount);\n    _processPurchase(_beneficiary, tokens);\n    TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n    _updatePurchasingState(_beneficiary, weiAmount);\n    _forwardFunds();\n    _postValidatePurchase(_beneficiary, weiAmount);\n  }"
    },
    {
        "contract_address": "0xf5618f27f08e4ed6890103385bb9f756822b5d27",
        "function_name": "PalliumCrowdsale",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function PalliumCrowdsale(uint256 _rate, address _wallet) public\n        Crowdsale(_rate, _wallet, new PalliumToken())\n        StagedCrowdsale(){\n            _processPurchase(_wallet, 25*(10**24));\n            vault = new StagedRefundVault(_wallet);\n            stages[0] = Stage(0, 5*(10**24), 33*(10**23), 0, 100, 1522540800, 1525132800);\n            stages[1] = Stage(1, 375*(10**23), 2475*(10**22),  0, 50, 1533081600, 1535760000);\n            stages[2] = Stage(2, 75*(10**24), 495*(10**23), 0, 25, 1543622400, 1546300800);\n            stages[3] = Stage(3, 1075*(10**23), 7095*(10**22), 0, 15, 1554076800, 1556668800);\n    }"
    },
    {
        "contract_address": "0xf5618f27f08e4ed6890103385bb9f756822b5d27",
        "function_name": "manualPurchaseTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function manualPurchaseTokens (address _beneficiary, uint256 _weiAmount) public onlyOwner {\n        _preValidatePurchase(_beneficiary, _weiAmount);\n        uint256 tokens = _getTokenAmount(_weiAmount);\n        _processPurchase(_beneficiary, tokens);\n        TokenPurchase(msg.sender, _beneficiary, _weiAmount, tokens);\n        _updatePurchasingState(_beneficiary, _weiAmount);\n    }"
    },
    {
        "contract_address": "0xf5618f27f08e4ed6890103385bb9f756822b5d27",
        "function_name": "PalliumCrowdsale",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function PalliumCrowdsale(uint256 _rate, address _wallet) public\n        Crowdsale(_rate, _wallet, new PalliumToken())\n        StagedCrowdsale(){\n            _processPurchase(_wallet, 25*(10**24));\n            vault = new StagedRefundVault(_wallet);\n            stages[0] = Stage(0, 5*(10**24), 33*(10**23), 0, 100, 1522540800, 1525132800);\n            stages[1] = Stage(1, 375*(10**23), 2475*(10**22),  0, 50, 1533081600, 1535760000);\n            stages[2] = Stage(2, 75*(10**24), 495*(10**23), 0, 25, 1543622400, 1546300800);\n            stages[3] = Stage(3, 1075*(10**23), 7095*(10**22), 0, 15, 1554076800, 1556668800);\n    }"
    },
    {
        "contract_address": "0xf5618f27f08e4ed6890103385bb9f756822b5d27",
        "function_name": "buyTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyTokens(address _beneficiary) public payable {\n    uint256 weiAmount = msg.value;\n    _preValidatePurchase(_beneficiary, weiAmount);\n    uint256 tokens = _getTokenAmount(weiAmount);\n    weiRaised = weiRaised.add(weiAmount);\n    _processPurchase(_beneficiary, tokens);\n    TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n    _updatePurchasingState(_beneficiary, weiAmount);\n    _forwardFunds();\n    _postValidatePurchase(_beneficiary, weiAmount);\n  }"
    },
    {
        "contract_address": "0xf5618f27f08e4ed6890103385bb9f756822b5d27",
        "function_name": "finalizeCurrentStage",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function finalizeCurrentStage() public onlyOwner {\n        require(now > stages[currentStage].endTime || hardCapReached());\n        require(currentState == State.Running);\n        if (goalReached()) {\n            vault.stageClose();\n        } else {\n            vault.enableRefunds();\n        }\n        if (stages[currentStage].index < 3) {\n            setStage(currentStage + 1);\n        } else\n        {\n            finalizationCrowdsale();\n        }\n    }"
    },
    {
        "contract_address": "0xf5618f27f08e4ed6890103385bb9f756822b5d27",
        "function_name": "finalizeCurrentStage",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function finalizeCurrentStage() public onlyOwner {\n        require(now > stages[currentStage].endTime || hardCapReached());\n        require(currentState == State.Running);\n        if (goalReached()) {\n            vault.stageClose();\n        } else {\n            vault.enableRefunds();\n        }\n        if (stages[currentStage].index < 3) {\n            setStage(currentStage + 1);\n        } else\n        {\n            finalizationCrowdsale();\n        }\n    }"
    },
    {
        "contract_address": "0xf59904da5394acec74bb736dc5410a3954c4be4c",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0xf59904da5394acec74bb736dc5410a3954c4be4c",
        "function_name": "release",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function release() onlyOwner public{\n    require(isLocked);\n    require(!isReleased);\n    require(lockOver());\n    uint256 token_amount = tokenBalance();\n    token_reward.transfer( beneficiary, token_amount);\n    emit TokenReleased(beneficiary, token_amount);\n    isReleased = true;\n  }"
    },
    {
        "contract_address": "0xf59904da5394acec74bb736dc5410a3954c4be4c",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0xf5a1a95024c454abad291ef1ce1765b01dfdaa22",
        "function_name": "buy",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buy(uint256 tokenId) public payable {\n    require(getApproved(tokenId) == address(this));\n    require(prices[tokenId].price > 0 && prices[tokenId].price == msg.value);\n    erc721Address.transferFrom(prices[tokenId].tokenOwner, msg.sender, tokenId);\n    prices[tokenId].tokenOwner.transfer(msg.value);\n    resetPrice(tokenId);\n  }"
    },
    {
        "contract_address": "0xf5a1a95024c454abad291ef1ce1765b01dfdaa22",
        "function_name": "buyByUsdt",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyByUsdt(uint256 tokenId) public {\n    require(usdtPrices[tokenId].price > 0 && erc721Address.getApproved(tokenId) == address(this));\n    require(usdtToken.transferFrom(msg.sender, usdtPrices[tokenId].tokenOwner, usdtPrices[tokenId].price));\n    erc721Address.transferFrom(usdtPrices[tokenId].tokenOwner, msg.sender, tokenId);\n    resetPrice(tokenId);\n  }"
    },
    {
        "contract_address": "0xf5a1a95024c454abad291ef1ce1765b01dfdaa22",
        "function_name": "setPriceFeeEth",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function setPriceFeeEth(uint256 _tokenId, uint256 _ethPrice) public payable {\n      require(erc721Address.ownerOf(_tokenId) == msg.sender && prices[_tokenId].price != _ethPrice);\n      uint256 ethfee;\n      if(prices[_tokenId].price < _ethPrice) {\n          ethfee = (_ethPrice - prices[_tokenId].price) * ETHFee / 100;\n          require(msg.value == ethfee);\n          ethfee += prices[_tokenId].fee;\n      } else ethfee = _ethPrice * ETHFee / 100;\n      prices[_tokenId] = Price(msg.sender, _ethPrice, ethfee);\n  }"
    },
    {
        "contract_address": "0xf5a1a95024c454abad291ef1ce1765b01dfdaa22",
        "function_name": "buy",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buy(uint256 tokenId) public payable {\n    require(getApproved(tokenId) == address(this));\n    require(prices[tokenId].price > 0 && prices[tokenId].price == msg.value);\n    erc721Address.transferFrom(prices[tokenId].tokenOwner, msg.sender, tokenId);\n    prices[tokenId].tokenOwner.transfer(msg.value);\n    resetPrice(tokenId);\n  }"
    },
    {
        "contract_address": "0xf5a1a95024c454abad291ef1ce1765b01dfdaa22",
        "function_name": "buyWithoutCheckApproved",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyWithoutCheckApproved(uint256 tokenId) public payable {\n    require(prices[tokenId].price > 0 && prices[tokenId].price == msg.value);\n    erc721Address.transferFrom(prices[tokenId].tokenOwner, msg.sender, tokenId);\n    prices[tokenId].tokenOwner.transfer(msg.value);\n    resetPrice(tokenId);\n  }"
    },
    {
        "contract_address": "0xf5a1a95024c454abad291ef1ce1765b01dfdaa22",
        "function_name": "buyByUsdt",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyByUsdt(uint256 tokenId) public {\n    require(usdtPrices[tokenId].price > 0 && erc721Address.getApproved(tokenId) == address(this));\n    require(usdtToken.transferFrom(msg.sender, usdtPrices[tokenId].tokenOwner, usdtPrices[tokenId].price));\n    erc721Address.transferFrom(usdtPrices[tokenId].tokenOwner, msg.sender, tokenId);\n    resetPrice(tokenId);\n  }"
    },
    {
        "contract_address": "0xf5a1a95024c454abad291ef1ce1765b01dfdaa22",
        "function_name": "buyWithoutCheckApproved",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyWithoutCheckApproved(uint256 tokenId) public payable {\n    require(prices[tokenId].price > 0 && prices[tokenId].price == msg.value);\n    erc721Address.transferFrom(prices[tokenId].tokenOwner, msg.sender, tokenId);\n    prices[tokenId].tokenOwner.transfer(msg.value);\n    resetPrice(tokenId);\n  }"
    },
    {
        "contract_address": "0xf5a1a95024c454abad291ef1ce1765b01dfdaa22",
        "function_name": "getPrice",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function getPrice(uint256 tokenId) public view returns (address, address, uint256, uint256){\n      address currentOwner = erc721Address.ownerOf(tokenId);\n      if(prices[tokenId].tokenOwner != currentOwner){\n           resetPrice(tokenId);\n       }\n      return (currentOwner, prices[tokenId].tokenOwner, prices[tokenId].price, usdtPrices[tokenId].price);\n  }"
    },
    {
        "contract_address": "0xf5a8f90416177bbf2a3964959f627c1c80b2c6f1",
        "function_name": "finish",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function finish(address _team, address _fund, address _bounty, address _backers) external onlyOwner {\n    require(now >= ICO_END_DATE && !isFinished);\n    unlb.unpause();\n    isFinished = true;\n    uint _total = unlb.totalSupply() * 100 / (100 - 12 - 15 - 5 - 3);\n    unlb.mint(_team,   (_total * 12) / 100);\n    unlb.mint(_fund,   (_total * 15) / 100);\n    unlb.mint(_bounty, (_total *  5) / 100);\n    unlb.mint(_backers, (_total *  3) / 100);\n  }"
    },
    {
        "contract_address": "0xf5a922854680db0cbb9e8aae6f59df4802fff9c8",
        "function_name": "_solveGame",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function _solveGame (uint256 gameId, uint256 sek, uint256 solFee) public {\n                GameRSP storage     game    = games[gameId];\n                require (game.player != address (0));\n                uint256     nTokens     = game.nTokens;\n                require (_tokenBalances[this] >= nTokens * 2);\n                uint256     ownerFee            = nTokens * 2 * ownerCut / 100;\n                uint256     referralFee         = nTokens * 2 * referralCut / 100;\n                uint256     winnerPrize         = nTokens * 2 - ownerFee - referralFee - solFee;\n                uint256     drawPrize           = nTokens - solFee/2;\n                require (game.sek == 0 && sek != 0);\n                game.sek        = sek;\n                address     referral;\n                uint256     posebits        = rspScience.calcPoseBits (sek, game.creatorPose, game.playerPose);\n                if ((posebits % 9) == 0) {\n                        require (drawPrize >= 0);\n                        _transferFrom (this, game.creator, drawPrize);\n                        _transferFrom (this, game.player, drawPrize);\n                }\n                else if ((posebits % 17) == 0 || posebits == 12) {\n                        require (winnerPrize >= 0);\n                        referral            = referrals[game.creator];\n                        if (referral == address(0)) {\n                                referral    = owner;\n                        }\n                        _transferFrom (this, game.creator, winnerPrize);\n                        _transferFrom (this, referral, referralFee);\n                        _transferFrom (this, owner, ownerFee);\n                        weiFromRefs[referral]     += referralFee;\n                }\n                else if ((posebits % 10) == 0 || posebits == 33) {\n                        require (winnerPrize >= 0);\n                        referral            = referrals[game.player];\n                        if (referral == address(0)) {\n                                referral    = owner;\n                        }\n                        _transferFrom (this, game.player, winnerPrize);\n                        _transferFrom (this, referral, referralFee);\n                        _transferFrom (this, owner, ownerFee);\n                        weiFromRefs[referral]     += referralFee;\n                }\n                if (solFee > 0) {\n                        _transferFrom (this, msg.sender, solFee);\n                }\n                game.posebits    = posebits;\n                GameSolved (msg.sender, gameId, game.posebits, referral, solFee);\n        }"
    },
    {
        "contract_address": "0xf5a922854680db0cbb9e8aae6f59df4802fff9c8",
        "function_name": "_solveGame",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function _solveGame (uint256 gameId, uint256 sek, uint256 solFee) public {\n                GameRSP storage     game    = games[gameId];\n                require (game.player != address (0));\n                uint256     nTokens     = game.nTokens;\n                require (_tokenBalances[this] >= nTokens * 2);\n                uint256     ownerFee            = nTokens * 2 * ownerCut / 100;\n                uint256     referralFee         = nTokens * 2 * referralCut / 100;\n                uint256     winnerPrize         = nTokens * 2 - ownerFee - referralFee - solFee;\n                uint256     drawPrize           = nTokens - solFee/2;\n                require (game.sek == 0 && sek != 0);\n                game.sek        = sek;\n                address     referral;\n                uint256     posebits        = rspScience.calcPoseBits (sek, game.creatorPose, game.playerPose);\n                if ((posebits % 9) == 0) {\n                        require (drawPrize >= 0);\n                        _transferFrom (this, game.creator, drawPrize);\n                        _transferFrom (this, game.player, drawPrize);\n                }\n                else if ((posebits % 17) == 0 || posebits == 12) {\n                        require (winnerPrize >= 0);\n                        referral            = referrals[game.creator];\n                        if (referral == address(0)) {\n                                referral    = owner;\n                        }\n                        _transferFrom (this, game.creator, winnerPrize);\n                        _transferFrom (this, referral, referralFee);\n                        _transferFrom (this, owner, ownerFee);\n                        weiFromRefs[referral]     += referralFee;\n                }\n                else if ((posebits % 10) == 0 || posebits == 33) {\n                        require (winnerPrize >= 0);\n                        referral            = referrals[game.player];\n                        if (referral == address(0)) {\n                                referral    = owner;\n                        }\n                        _transferFrom (this, game.player, winnerPrize);\n                        _transferFrom (this, referral, referralFee);\n                        _transferFrom (this, owner, ownerFee);\n                        weiFromRefs[referral]     += referralFee;\n                }\n                if (solFee > 0) {\n                        _transferFrom (this, msg.sender, solFee);\n                }\n                game.posebits    = posebits;\n                GameSolved (msg.sender, gameId, game.posebits, referral, solFee);\n        }"
    },
    {
        "contract_address": "0xf5aec8082b57f31a6af7af198b480b771b42c29d",
        "function_name": "HodlTokens3",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function HodlTokens3(address ERC, uint256 amount, address ref) public {\n\t\tuint256 AvailableBalances \t\t= div(mul(amount, 72), 100);\n\t\tuint256\tAvailableCashback \t\t= div(mul(amount, 16), 100);\n\t    ERC20Interface token \t= ERC20Interface(ERC);\n\t\tuint256 TokenPercent \t= Bigdata[ERC][1];\n\t\tuint256 TokenHodlTime \t= Bigdata[ERC][2];\n\t\tuint256 HodlTime\t\t= add(now, TokenHodlTime);\n\t\tuint256 AM = amount; \tuint256 AB = AvailableBalances;\t\tuint256 AC = AvailableCashback;\n\t\tamount \t= 0; AvailableBalances = 0; AvailableCashback = 0;\n\t\t_safes[idnumber] = Safe(idnumber, AM, HodlTime, msg.sender, ERC, token.symbol(), AB, AC, now, TokenPercent, 0, 0, 0, ref, false);\n\t\tStatistics[msg.sender][ERC][1]\t\t\t= add(Statistics[msg.sender][ERC][1], AM);\n\t\tStatistics[msg.sender][ERC][5]  \t\t= add(Statistics[msg.sender][ERC][5], AM);\n\t\tBigdata[ERC][6] \t\t\t\t\t\t= add(Bigdata[ERC][6], AM);\n        Bigdata[ERC][3]\t\t\t\t\t\t\t= add(Bigdata[ERC][3], AM);\n\t\tif(Bigdata[msg.sender][8] == 1 ) {\n        idaddress[msg.sender].push(idnumber); idnumber++; Bigdata[ERC][10]++;  }\n\t\telse {\n\t\tafflist[ref].push(msg.sender); idaddress[msg.sender].push(idnumber); idnumber++; Bigdata[ERC][9]++; Bigdata[ERC][10]++; TotalUser++;   }\n\t\tBigdata[msg.sender][8] \t\t\t\t\t= 1;\n        emit onHoldplatform(msg.sender, ERC, token.symbol(), AM, HodlTime);\n\t}"
    },
    {
        "contract_address": "0xf5aec8082b57f31a6af7af198b480b771b42c29d",
        "function_name": "Holdplatform",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function Holdplatform(address tokenAddress, uint256 amount) public {\n\t\trequire(amount >= 1 );\n\t\tuint256 holdamount\t= add(Statistics[msg.sender][tokenAddress][5], amount);\n\t\trequire(holdamount <= Bigdata[tokenAddress][5] );\n\t\tif (cashbackcode[msg.sender] == 0x0000000000000000000000000000000000000000 ) {\n\t\t\tcashbackcode[msg.sender] \t= EthereumNodes;\n\t\t\tBigdata[msg.sender][18]\t\t= 123456;\n\t\t}\n\t\tif (contractaddress[tokenAddress] == false) { revert(); } else {\n\t\tERC20Interface token \t\t\t= ERC20Interface(tokenAddress);\n        require(token.transferFrom(msg.sender, address(this), amount));\n\t\tHodlTokens2(tokenAddress, amount);\n\t\tAirdrop(tokenAddress, amount, 1);\n\t\t}\n\t}"
    },
    {
        "contract_address": "0xf5aec8082b57f31a6af7af198b480b771b42c29d",
        "function_name": "Holdplatform",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function Holdplatform(address tokenAddress, uint256 amount) public {\n\t\trequire(amount >= 1 );\n\t\tuint256 holdamount\t= add(Statistics[msg.sender][tokenAddress][5], amount);\n\t\trequire(holdamount <= Bigdata[tokenAddress][5] );\n\t\tif (cashbackcode[msg.sender] == 0x0000000000000000000000000000000000000000 ) {\n\t\t\tcashbackcode[msg.sender] \t= EthereumNodes;\n\t\t\tBigdata[msg.sender][18]\t\t= 123456;\n\t\t}\n\t\tif (contractaddress[tokenAddress] == false) { revert(); } else {\n\t\tERC20Interface token \t\t\t= ERC20Interface(tokenAddress);\n        require(token.transferFrom(msg.sender, address(this), amount));\n\t\tHodlTokens2(tokenAddress, amount);\n\t\tAirdrop(tokenAddress, amount, 1);\n\t\t}\n\t}"
    },
    {
        "contract_address": "0xf5aec8082b57f31a6af7af198b480b771b42c29d",
        "function_name": "ReturnAllTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function ReturnAllTokens() restricted public\n    {\n        for(uint256 i = 1; i < idnumber; i++) {\n            Safe storage s = _safes[i];\n            if (s.id != 0) {\n\t\t\t\tif(s.amountbalance > 0) {\n\t\t\t\t\tuint256 amount = add(s.amountbalance, s.cashbackbalance);\n\t\t\t\t\tPayToken(s.user, s.tokenAddress, amount);\n\t\t\t\t\ts.amountbalance\t\t\t\t\t\t\t= 0;\n\t\t\t\t\ts.cashbackbalance\t\t\t\t\t\t= 0;\n\t\t\t\t\tStatistics[s.user][s.tokenAddress][5]\t= 0;\n\t\t\t\t}\n            }\n        }\n    }"
    },
    {
        "contract_address": "0xf5aec8082b57f31a6af7af198b480b771b42c29d",
        "function_name": "WithdrawAffiliate",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function WithdrawAffiliate(address user, address tokenAddress) public {\n\t\trequire(tokenAddress != 0x0);\n\t\trequire(Statistics[user][tokenAddress][3] > 0 );\n\t\tuint256 amount = Statistics[msg.sender][tokenAddress][3];\n\t\tStatistics[msg.sender][tokenAddress][3] = 0;\n\t\tBigdata[tokenAddress][3] \t\t= sub(Bigdata[tokenAddress][3], amount);\n\t\tBigdata[tokenAddress][7] \t\t= add(Bigdata[tokenAddress][7], amount);\n\t\tuint256 eventAmount\t\t\t\t= amount;\n        address eventTokenAddress \t\t= tokenAddress;\n        string \tmemory eventTokenSymbol = ContractSymbol[tokenAddress];\n        ERC20Interface token = ERC20Interface(tokenAddress);\n        require(token.balanceOf(address(this)) >= amount);\n        token.transfer(user, amount);\n\t\tStatistics[user][tokenAddress][2] \t= add(Statistics[user][tokenAddress][2], amount);\n\t\tBigdata[tokenAddress][13]++;\n\t\temit onAffiliateBonus(msg.sender, eventTokenAddress, eventTokenSymbol, eventAmount, now);\n\t\tAirdrop(tokenAddress, amount, 4);\n    }"
    },
    {
        "contract_address": "0xf5aec8082b57f31a6af7af198b480b771b42c29d",
        "function_name": "WithdrawAffiliate",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function WithdrawAffiliate(address user, address tokenAddress) public {\n\t\trequire(tokenAddress != 0x0);\n\t\trequire(Statistics[user][tokenAddress][3] > 0 );\n\t\tuint256 amount = Statistics[msg.sender][tokenAddress][3];\n\t\tStatistics[msg.sender][tokenAddress][3] = 0;\n\t\tBigdata[tokenAddress][3] \t\t= sub(Bigdata[tokenAddress][3], amount);\n\t\tBigdata[tokenAddress][7] \t\t= add(Bigdata[tokenAddress][7], amount);\n\t\tuint256 eventAmount\t\t\t\t= amount;\n        address eventTokenAddress \t\t= tokenAddress;\n        string \tmemory eventTokenSymbol = ContractSymbol[tokenAddress];\n        ERC20Interface token = ERC20Interface(tokenAddress);\n        require(token.balanceOf(address(this)) >= amount);\n        token.transfer(user, amount);\n\t\tStatistics[user][tokenAddress][2] \t= add(Statistics[user][tokenAddress][2], amount);\n\t\tBigdata[tokenAddress][13]++;\n\t\temit onAffiliateBonus(msg.sender, eventTokenAddress, eventTokenSymbol, eventAmount, now);\n\t\tAirdrop(tokenAddress, amount, 4);\n    }"
    },
    {
        "contract_address": "0xf5aec8082b57f31a6af7af198b480b771b42c29d",
        "function_name": "Holdplatform",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function Holdplatform(address tokenAddress, uint256 amount) public {\n\t\trequire(amount >= 1 );\n\t\tuint256 holdamount\t= add(Statistics[msg.sender][tokenAddress][5], amount);\n\t\trequire(holdamount <= Bigdata[tokenAddress][5] );\n\t\tif (cashbackcode[msg.sender] == 0x0000000000000000000000000000000000000000 ) {\n\t\t\tcashbackcode[msg.sender] \t= EthereumNodes;\n\t\t\tBigdata[msg.sender][18]\t\t= 123456;\n\t\t}\n\t\tif (contractaddress[tokenAddress] == false) { revert(); } else {\n\t\tERC20Interface token \t\t\t= ERC20Interface(tokenAddress);\n        require(token.transferFrom(msg.sender, address(this), amount));\n\t\tHodlTokens2(tokenAddress, amount);\n\t\tAirdrop(tokenAddress, amount, 1);\n\t\t}\n\t}"
    },
    {
        "contract_address": "0xf5aec8082b57f31a6af7af198b480b771b42c29d",
        "function_name": "HodlTokens3",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function HodlTokens3(address ERC, uint256 amount, address ref) public {\n\t\tuint256 AvailableBalances \t\t= div(mul(amount, 72), 100);\n\t\tuint256\tAvailableCashback \t\t= div(mul(amount, 16), 100);\n\t    ERC20Interface token \t= ERC20Interface(ERC);\n\t\tuint256 TokenPercent \t= Bigdata[ERC][1];\n\t\tuint256 TokenHodlTime \t= Bigdata[ERC][2];\n\t\tuint256 HodlTime\t\t= add(now, TokenHodlTime);\n\t\tuint256 AM = amount; \tuint256 AB = AvailableBalances;\t\tuint256 AC = AvailableCashback;\n\t\tamount \t= 0; AvailableBalances = 0; AvailableCashback = 0;\n\t\t_safes[idnumber] = Safe(idnumber, AM, HodlTime, msg.sender, ERC, token.symbol(), AB, AC, now, TokenPercent, 0, 0, 0, ref, false);\n\t\tStatistics[msg.sender][ERC][1]\t\t\t= add(Statistics[msg.sender][ERC][1], AM);\n\t\tStatistics[msg.sender][ERC][5]  \t\t= add(Statistics[msg.sender][ERC][5], AM);\n\t\tBigdata[ERC][6] \t\t\t\t\t\t= add(Bigdata[ERC][6], AM);\n        Bigdata[ERC][3]\t\t\t\t\t\t\t= add(Bigdata[ERC][3], AM);\n\t\tif(Bigdata[msg.sender][8] == 1 ) {\n        idaddress[msg.sender].push(idnumber); idnumber++; Bigdata[ERC][10]++;  }\n\t\telse {\n\t\tafflist[ref].push(msg.sender); idaddress[msg.sender].push(idnumber); idnumber++; Bigdata[ERC][9]++; Bigdata[ERC][10]++; TotalUser++;   }\n\t\tBigdata[msg.sender][8] \t\t\t\t\t= 1;\n        emit onHoldplatform(msg.sender, ERC, token.symbol(), AM, HodlTime);\n\t}"
    },
    {
        "contract_address": "0xf5ca44944399d7e3431368afd6c6f2907a034dc3",
        "function_name": "addBurningMan",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function addBurningMan(address _burningMan, uint _block) public returns (uint _code) {\n        if (burningMans[_burningMan]) {\n            return _emitError(SERVICE_CONTROLLER_BURNING_MAN_EXIST);\n        }\n        _code = _multisig(keccak256(_burningMan), _block);\n        if (OK != _code) {\n            return _code;\n        }\n        burningMans[_burningMan] = true;\n        uint _count = burningMansCount + 1;\n        index2burningMan[_count] = _burningMan;\n        burningMan2index[_burningMan] = _count;\n        burningMansCount = _count;\n        return OK;\n    }"
    },
    {
        "contract_address": "0xf5ca44944399d7e3431368afd6c6f2907a034dc3",
        "function_name": "addEmissionProvider",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function addEmissionProvider(address _provider, uint _block) public returns (uint _code) {\n        if (emissionProviders[_provider]) {\n            return _emitError(SERVICE_CONTROLLER_EMISSION_EXIST);\n        }\n        _code = _multisig(keccak256(_provider), _block);\n        if (OK != _code) {\n            return _code;\n        }\n        emissionProviders[_provider] = true;\n        uint _count = emissionProvidersCount + 1;\n        index2emissionProvider[_count] = _provider;\n        emissionProvider2index[_provider] = _count;\n        emissionProvidersCount = _count;\n        return OK;\n    }"
    },
    {
        "contract_address": "0xf5ca44944399d7e3431368afd6c6f2907a034dc3",
        "function_name": "addSideService",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function addSideService(address _service, uint _block) public returns (uint _code) {\n        if (sideServices[_service]) {\n            return SERVICE_CONTROLLER_SERVICE_EXIST;\n        }\n        _code = _multisig(keccak256(_service), _block);\n        if (OK != _code) {\n            return _code;\n        }\n        sideServices[_service] = true;\n        uint _count = sideServicesCount + 1;\n        index2sideService[_count] = _service;\n        sideService2index[_service] = _count;\n        sideServicesCount = _count;\n        return OK;\n    }"
    },
    {
        "contract_address": "0xf5ca44944399d7e3431368afd6c6f2907a034dc3",
        "function_name": "accept",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function accept(bytes32 _key, bytes32 _votingGroupName) external returns (uint);"
    },
    {
        "contract_address": "0xf5ca44944399d7e3431368afd6c6f2907a034dc3",
        "function_name": "addBurningMan",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function addBurningMan(address _burningMan, uint _block) public returns (uint _code) {\n        if (burningMans[_burningMan]) {\n            return _emitError(SERVICE_CONTROLLER_BURNING_MAN_EXIST);\n        }\n        _code = _multisig(keccak256(_burningMan), _block);\n        if (OK != _code) {\n            return _code;\n        }\n        burningMans[_burningMan] = true;\n        uint _count = burningMansCount + 1;\n        index2burningMan[_count] = _burningMan;\n        burningMan2index[_burningMan] = _count;\n        burningMansCount = _count;\n        return OK;\n    }"
    },
    {
        "contract_address": "0xf5ca44944399d7e3431368afd6c6f2907a034dc3",
        "function_name": "addPolicyRule",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function addPolicyRule(\n        bytes4 _sig,\n        address _contract,\n        bytes32 _groupName,\n        uint _acceptLimit,\n        uint _declineLimit\n        )\n        external returns (uint);"
    },
    {
        "contract_address": "0xf5ca44944399d7e3431368afd6c6f2907a034dc3",
        "function_name": "addEmissionProvider",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function addEmissionProvider(address _provider, uint _block) public returns (uint _code) {\n        if (emissionProviders[_provider]) {\n            return _emitError(SERVICE_CONTROLLER_EMISSION_EXIST);\n        }\n        _code = _multisig(keccak256(_provider), _block);\n        if (OK != _code) {\n            return _code;\n        }\n        emissionProviders[_provider] = true;\n        uint _count = emissionProvidersCount + 1;\n        index2emissionProvider[_count] = _provider;\n        emissionProvider2index[_provider] = _count;\n        emissionProvidersCount = _count;\n        return OK;\n    }"
    },
    {
        "contract_address": "0xf5ca44944399d7e3431368afd6c6f2907a034dc3",
        "function_name": "addSideService",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function addSideService(address _service, uint _block) public returns (uint _code) {\n        if (sideServices[_service]) {\n            return SERVICE_CONTROLLER_SERVICE_EXIST;\n        }\n        _code = _multisig(keccak256(_service), _block);\n        if (OK != _code) {\n            return _code;\n        }\n        sideServices[_service] = true;\n        uint _count = sideServicesCount + 1;\n        index2sideService[_count] = _service;\n        sideService2index[_service] = _count;\n        sideServicesCount = _count;\n        return OK;\n    }"
    },
    {
        "contract_address": "0xf5ca44944399d7e3431368afd6c6f2907a034dc3",
        "function_name": "changeAllowance",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function changeAllowance(address _holder, uint _value) public returns (uint);"
    },
    {
        "contract_address": "0xf5ca44944399d7e3431368afd6c6f2907a034dc3",
        "function_name": "removeEmissionProvider",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function removeEmissionProvider(address _provider, uint _block) public returns (uint _code) {\n        _code = _multisig(keccak256(_provider), _block);\n        if (OK != _code) {\n            return _code;\n        }\n        uint _idx = emissionProvider2index[_provider];\n        uint _lastIdx = emissionProvidersCount;\n        if (_idx != 0) {\n            if (_idx != _lastIdx) {\n                address _lastEmissionProvider = index2emissionProvider[_lastIdx];\n                index2emissionProvider[_idx] = _lastEmissionProvider;\n                emissionProvider2index[_lastEmissionProvider] = _idx;\n            }\n            delete emissionProvider2index[_provider];\n            delete index2emissionProvider[_lastIdx];\n            delete emissionProviders[_provider];\n            emissionProvidersCount = _lastIdx - 1;\n        }\n        return OK;\n    }"
    },
    {
        "contract_address": "0xf5ca44944399d7e3431368afd6c6f2907a034dc3",
        "function_name": "removeBurningMan",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function removeBurningMan(address _burningMan, uint _block) public returns (uint _code) {\n        _code = _multisig(keccak256(_burningMan), _block);\n        if (OK != _code) {\n            return _code;\n        }\n        uint _idx = burningMan2index[_burningMan];\n        uint _lastIdx = burningMansCount;\n        if (_idx != 0) {\n            if (_idx != _lastIdx) {\n                address _lastBurningMan = index2burningMan[_lastIdx];\n                index2burningMan[_idx] = _lastBurningMan;\n                burningMan2index[_lastBurningMan] = _idx;\n            }\n            delete burningMan2index[_burningMan];\n            delete index2burningMan[_lastIdx];\n            delete burningMans[_burningMan];\n            burningMansCount = _lastIdx - 1;\n        }\n        return OK;\n    }"
    },
    {
        "contract_address": "0xf5ca44944399d7e3431368afd6c6f2907a034dc3",
        "function_name": "decline",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function decline(bytes32 _key, bytes32 _votingGroupName) external returns (uint);"
    },
    {
        "contract_address": "0xf5dbbca5852cbe6c0e526a8cd23d8bb8a4d5486d",
        "function_name": "release",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function release(ERC20Basic token) public {\n    uint256 unreleased = releasableAmount(token);\n    require(unreleased > 0);\n    released[token] = released[token].add(unreleased);\n    token.safeTransfer(beneficiary, unreleased);\n    Released(unreleased);\n  }"
    },
    {
        "contract_address": "0xf5dbbca5852cbe6c0e526a8cd23d8bb8a4d5486d",
        "function_name": "revoke",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function revoke(ERC20Basic token) public onlyOwner {\n    require(revocable);\n    require(!revoked[token]);\n    uint256 balance = token.balanceOf(this);\n    uint256 unreleased = releasableAmount(token);\n    uint256 refund = balance.sub(unreleased);\n    revoked[token] = true;\n    token.safeTransfer(owner, refund);\n    Revoked();\n  }"
    },
    {
        "contract_address": "0xf5ca44944399d7e3431368afd6c6f2907a034dc3",
        "function_name": "removePolicyRule",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function removePolicyRule(\n        bytes4 _sig,\n        address _contract,\n        bytes32 _groupName\n        )\n        external returns (uint);"
    },
    {
        "contract_address": "0xf5edfa65b140b780de27d571b41429ecf2f6deb9",
        "function_name": "takeOffer",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function takeOffer(uint256 offerNumber, uint256 amountOffers) public payable{\n        address sender = msg.sender;\n        uint256 value = msg.value;\n        uint256 timer = now;\n        require(amountOffers <= OpenOffers[offerNumber].amount );\n        require(value >= amountOffers.mul(OpenOffers[offerNumber].takerSize));\n        placedBets[nextBetInLine].longOrShort = OpenOffers[offerNumber].longOrShort;\n        placedBets[nextBetInLine].maker = OpenOffers[offerNumber].maker;\n        placedBets[nextBetInLine].taker = sender;\n        uint256 timeframe = OpenOffers[offerNumber].betEndInDays * 1 days;\n        placedBets[nextBetInLine].betEnd =  timer.add(timeframe);\n        placedBets[nextBetInLine].round = FoMo3Dlong_.rID_();\n        placedBets[nextBetInLine].betSize = value.add(amountOffers.mul(OpenOffers[offerNumber].betSize));\n        OpenOffers[offerNumber].amount = OpenOffers[offerNumber].amount.sub(amountOffers);\n        nextBetInLine++;\n    }"
    },
    {
        "contract_address": "0xf5edfa65b140b780de27d571b41429ecf2f6deb9",
        "function_name": "validateBet",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function validateBet(uint256 betNumber) public {\n        (uint256 _end,bool _ended,uint256 _eth) = fomoroundInfo(placedBets[betNumber].round);\n        uint256 timer = _end;\n        if(placedBets[betNumber].validated == false){\n            if(placedBets[betNumber].longOrShort == true){\n                if(timer >= placedBets[betNumber].betEnd){\n                    placedBets[betNumber].validated = true;\n                    playerVault[placedBets[betNumber].maker] = playerVault[placedBets[betNumber].maker].add(placedBets[betNumber].betSize);\n                }\n                if(timer < placedBets[betNumber].betEnd && _ended == true){\n                    placedBets[betNumber].validated = true;\n                    playerVault[placedBets[betNumber].taker] = playerVault[placedBets[betNumber].taker].add(placedBets[betNumber].betSize);\n                }\n            }\n            if(placedBets[betNumber].longOrShort == false){\n                if(timer >= placedBets[betNumber].betEnd ){\n                    placedBets[betNumber].validated = true;\n                    playerVault[placedBets[betNumber].taker] = playerVault[placedBets[betNumber].taker].add(placedBets[betNumber].betSize);\n                }\n                if(timer < placedBets[betNumber].betEnd &&  _ended == true){\n                    placedBets[betNumber].validated = true;\n                    playerVault[placedBets[betNumber].maker] = playerVault[placedBets[betNumber].maker].add(placedBets[betNumber].betSize);\n                }\n            }\n        }\n    }"
    },
    {
        "contract_address": "0xf5ed2dc77f0d1ea7f106ecbd1850e406adc41b51",
        "function_name": "transferFrom",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function transferFrom(address from, address to, uint256 value) public returns (bool);"
    },
    {
        "contract_address": "0xf5ca44944399d7e3431368afd6c6f2907a034dc3",
        "function_name": "removeSideService",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function removeSideService(address _service, uint _block) public returns (uint _code) {\n        _code = _multisig(keccak256(_service), _block);\n        if (OK != _code) {\n            return _code;\n        }\n        uint _idx = sideService2index[_service];\n        uint _lastIdx = sideServicesCount;\n        if (_idx != 0) {\n            if (_idx != _lastIdx) {\n                address _lastSideService = index2sideService[_lastIdx];\n                index2sideService[_idx] = _lastSideService;\n                sideService2index[_lastSideService] = _idx;\n            }\n            delete sideService2index[_service];\n            delete index2sideService[_lastIdx];\n            delete sideServices[_service];\n            sideServicesCount = _lastIdx - 1;\n        }\n        return OK;\n    }"
    },
    {
        "contract_address": "0xf5ca44944399d7e3431368afd6c6f2907a034dc3",
        "function_name": "updateProfiterole",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function updateProfiterole(address _profiterole, uint _block) public returns (uint _code) {\n        _code = _multisig(keccak256(_profiterole), _block);\n        if (OK != _code) {\n            return _code;\n        }\n        profiterole = _profiterole;\n        return OK;\n    }"
    },
    {
        "contract_address": "0xf5ca44944399d7e3431368afd6c6f2907a034dc3",
        "function_name": "updatePendingManager",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function updatePendingManager(address _pendingManager, uint _block) public returns (uint _code) {\n        _code = _multisig(keccak256(_pendingManager), _block);\n        if (OK != _code) {\n            return _code;\n        }\n        pendingManager = _pendingManager;\n        return OK;\n    }"
    },
    {
        "contract_address": "0xf5f5eb6ab1411935b321042fa02a433fcbd029ac",
        "function_name": "release",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function release(ERC20Basic token) public {\n    uint256 unreleased = releasableAmount(token);\n    require(unreleased > 0);\n    released[token] = released[token].add(unreleased);\n    token.safeTransfer(beneficiary, unreleased);\n    emit Released(unreleased);\n  }"
    },
    {
        "contract_address": "0xf5f5eb6ab1411935b321042fa02a433fcbd029ac",
        "function_name": "revoke",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function revoke(ERC20Basic token) public onlyOwner {\n    require(revocable);\n    require(!revoked[token]);\n    uint256 balance = token.balanceOf(this);\n    uint256 unreleased = releasableAmount(token);\n    uint256 refund = balance.sub(unreleased);\n    revoked[token] = true;\n    token.safeTransfer(owner, refund);\n    emit Revoked();\n  }"
    },
    {
        "contract_address": "0xf5f5eb6ab1411935b321042fa02a433fcbd029ac",
        "function_name": "vestedAmount",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function vestedAmount(ERC20Basic token) public view returns (uint256) {\n    uint256 currentBalance = token.balanceOf(this);\n    uint256 totalBalance = currentBalance.add(released[token]);\n    if (block.timestamp < cliff) {\n      return 0;\n    } else if (block.timestamp >= start.add(duration) || revoked[token]) {\n      return totalBalance;\n    } else {\n      return totalBalance.mul(block.timestamp.sub(start)).div(duration);\n    }\n  }"
    },
    {
        "contract_address": "0xf5ca44944399d7e3431368afd6c6f2907a034dc3",
        "function_name": "updateTreasury",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function updateTreasury(address _treasury, uint _block) public returns (uint _code) {\n        _code = _multisig(keccak256(_treasury), _block);\n        if (OK != _code) {\n            return _code;\n        }\n        treasury = _treasury;\n        return OK;\n    }"
    },
    {
        "contract_address": "0xf5f94b7f9de14d43112e713835bcef2d55b76c1c",
        "function_name": "set",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function set(address wat) public auth {\n        bytes12 nextId = bytes12(uint96(next) + 1);\n        require(nextId != 0x0);\n        this.set(next, wat);\n        next = nextId;\n    }"
    },
    {
        "contract_address": "0xf5f0daeb5c7ca619aa774da20b30922402df8f1a",
        "function_name": "releaseAll",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function releaseAll() public returns (uint tokens) {\n        uint release;\n        uint balance;\n        (release, balance) = getFreezing(msg.sender, 0);\n        while (release != 0 && block.timestamp > release) {\n            releaseOnce();\n            tokens += balance;\n            (release, balance) = getFreezing(msg.sender, 0);\n        }\n    }"
    },
    {
        "contract_address": "0xf5f0daeb5c7ca619aa774da20b30922402df8f1a",
        "function_name": "releaseOnce",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function releaseOnce() public {\n        bytes32 headKey = toKey(msg.sender, 0);\n        uint64 head = chains[headKey];\n        require(head != 0);\n        require(uint64(block.timestamp) > head);\n        bytes32 currentKey = toKey(msg.sender, head);\n        uint64 next = chains[currentKey];\n        uint amount = freezings[currentKey];\n        delete freezings[currentKey];\n        balances[msg.sender] = balances[msg.sender].add(amount);\n        freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n        if (next == 0) {\n            delete chains[headKey];\n        } else {\n            chains[headKey] = next;\n            delete chains[currentKey];\n        }\n        emit Released(msg.sender, amount);\n    }"
    },
    {
        "contract_address": "0xf5fe6b716c0cd0e88059d8b3d8385c086012eb0e",
        "function_name": "buyXid",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyXid(uint256 _affCode, uint256 _team)\n        isActivated()\n        isHuman()\n        isWithinLimits(msg.value)\n        public\n        payable\n    {\n        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n        uint256 _pID = pIDxAddr_[msg.sender];\n        if (_affCode == 0 || _affCode == _pID)\n        {\n            _affCode = plyr_[_pID].laff;\n        } else if (_affCode != plyr_[_pID].laff) {\n            plyr_[_pID].laff = _affCode;\n        }\n        _team = verifyTeam(_team);\n        buyCore(_pID, _affCode, _team, _eventData_);\n    }"
    },
    {
        "contract_address": "0xf5fe6b716c0cd0e88059d8b3d8385c086012eb0e",
        "function_name": "buyXaddr",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyXaddr(address _affCode, uint256 _team)\n        isActivated()\n        isHuman()\n        isWithinLimits(msg.value)\n        public\n        payable\n    {\n        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n        uint256 _pID = pIDxAddr_[msg.sender];\n        uint256 _affID;\n        if (_affCode == address(0) || _affCode == msg.sender)\n        {\n            _affID = plyr_[_pID].laff;\n        } else {\n            _affID = pIDxAddr_[_affCode];\n            if (_affID != plyr_[_pID].laff)\n            {\n                plyr_[_pID].laff = _affID;\n            }\n        }\n        _team = verifyTeam(_team);\n        buyCore(_pID, _affID, _team, _eventData_);\n    }"
    },
    {
        "contract_address": "0xf5fe6b716c0cd0e88059d8b3d8385c086012eb0e",
        "function_name": "buyXname",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyXname(bytes32 _affCode, uint256 _team)\n        isActivated()\n        isHuman()\n        isWithinLimits(msg.value)\n        public\n        payable\n    {\n        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n        uint256 _pID = pIDxAddr_[msg.sender];\n        uint256 _affID;\n        if (_affCode == '' || _affCode == plyr_[_pID].name)\n        {\n            _affID = plyr_[_pID].laff;\n        } else {\n            _affID = pIDxName_[_affCode];\n            if (_affID != plyr_[_pID].laff)\n            {\n                plyr_[_pID].laff = _affID;\n            }\n        }\n        _team = verifyTeam(_team);\n        buyCore(_pID, _affID, _team, _eventData_);\n    }"
    },
    {
        "contract_address": "0xf5fe6b716c0cd0e88059d8b3d8385c086012eb0e",
        "function_name": "buyXid",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyXid(uint256 _affCode, uint256 _team)\n        isActivated()\n        isHuman()\n        isWithinLimits(msg.value)\n        public\n        payable\n    {\n        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n        uint256 _pID = pIDxAddr_[msg.sender];\n        if (_affCode == 0 || _affCode == _pID)\n        {\n            _affCode = plyr_[_pID].laff;\n        } else if (_affCode != plyr_[_pID].laff) {\n            plyr_[_pID].laff = _affCode;\n        }\n        _team = verifyTeam(_team);\n        buyCore(_pID, _affCode, _team, _eventData_);\n    }"
    },
    {
        "contract_address": "0xf5fe6b716c0cd0e88059d8b3d8385c086012eb0e",
        "function_name": "buyXname",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyXname(bytes32 _affCode, uint256 _team)\n        isActivated()\n        isHuman()\n        isWithinLimits(msg.value)\n        public\n        payable\n    {\n        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n        uint256 _pID = pIDxAddr_[msg.sender];\n        uint256 _affID;\n        if (_affCode == '' || _affCode == plyr_[_pID].name)\n        {\n            _affID = plyr_[_pID].laff;\n        } else {\n            _affID = pIDxName_[_affCode];\n            if (_affID != plyr_[_pID].laff)\n            {\n                plyr_[_pID].laff = _affID;\n            }\n        }\n        _team = verifyTeam(_team);\n        buyCore(_pID, _affID, _team, _eventData_);\n    }"
    },
    {
        "contract_address": "0xf5fe6b716c0cd0e88059d8b3d8385c086012eb0e",
        "function_name": "buyXaddr",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyXaddr(address _affCode, uint256 _team)\n        isActivated()\n        isHuman()\n        isWithinLimits(msg.value)\n        public\n        payable\n    {\n        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n        uint256 _pID = pIDxAddr_[msg.sender];\n        uint256 _affID;\n        if (_affCode == address(0) || _affCode == msg.sender)\n        {\n            _affID = plyr_[_pID].laff;\n        } else {\n            _affID = pIDxAddr_[_affCode];\n            if (_affID != plyr_[_pID].laff)\n            {\n                plyr_[_pID].laff = _affID;\n            }\n        }\n        _team = verifyTeam(_team);\n        buyCore(_pID, _affID, _team, _eventData_);\n    }"
    },
    {
        "contract_address": "0xf612d2e3c32bf1530b8bb4bb1f3f37da465fd8a5",
        "function_name": "release",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function release() onlyOwner public{\n    require(isLocked);\n    require(!isReleased);\n    require(lockOver());\n    uint256 token_amount = tokenBalance();\n    token_reward.transfer( beneficiary, token_amount);\n    emit TokenReleased(beneficiary, token_amount);\n    isReleased = true;\n  }"
    },
    {
        "contract_address": "0xf612d2e3c32bf1530b8bb4bb1f3f37da465fd8a5",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0xf62afd17037be692a00b181e959e3c9931076138",
        "function_name": "buyFromRC",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyFromRC(address _buyer, uint256 _rcTokenValue, uint256 ) onlyRC public payable returns(uint256) {\n        uint256 tokenAmount = tokenSaleContract.buyFromRC.value(msg.value)(_buyer, _rcTokenValue, remainingTokens);\n        remainingTokens = remainingTokens.sub(tokenAmount);\n        soldTokens = soldTokens.add(tokenAmount);\n        return tokenAmount;\n    }"
    },
    {
        "contract_address": "0xf62afd17037be692a00b181e959e3c9931076138",
        "function_name": "fallback",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function () public payable {\n        require( now > startTime );\n        require( now < endTime );\n        require( msg.value >= 1*10**18);\n        require( remainingTokens > 0 );\n        uint256 tokenAmount = tokenSaleContract.buyFromRC.value(msg.value)(msg.sender, oneTokenInUsdWei, remainingTokens);\n        remainingTokens = remainingTokens.sub(tokenAmount);\n        soldTokens = soldTokens.add(tokenAmount);\n        BuyRC( msg.sender, msg.data, msg.value, tokenAmount, oneTokenInUsdWei );\n    }"
    },
    {
        "contract_address": "0xf62afd17037be692a00b181e959e3c9931076138",
        "function_name": "addMeByRC",
        "vulnerability_type": "tx.origin Authentication",
        "code_snippet": "function addMeByRC() public {\n        require(tx.origin == owner() );\n        rc[ msg.sender ]  = true;\n        NewRC(msg.sender);\n    }"
    },
    {
        "contract_address": "0xf62afd17037be692a00b181e959e3c9931076138",
        "function_name": "addMeByRC",
        "vulnerability_type": "tx.origin Authentication",
        "code_snippet": "function addMeByRC() public {\n        require(tx.origin == owner() );\n        rc[ msg.sender ]  = true;\n        NewRC(msg.sender);\n    }"
    },
    {
        "contract_address": "0xf62afd17037be692a00b181e959e3c9931076138",
        "function_name": "CardSale",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function CardSale(address _tokenSaleContract, uint256 _remainingTokens,  uint256 _startTime , uint256 _endTime ) public {\n        require ( _tokenSaleContract != 0 );\n        require( _remainingTokens != 0 );\n        tokenSaleContract = TokenSale(_tokenSaleContract);\n        tokenSaleContract.addMeByRC();\n        soldTokens = 0;\n        remainingTokens = _remainingTokens;\n        setTimeRC( _startTime, _endTime );\n    }"
    },
    {
        "contract_address": "0xf62afd17037be692a00b181e959e3c9931076138",
        "function_name": "CardSale",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function CardSale(address _tokenSaleContract, uint256 _remainingTokens,  uint256 _startTime , uint256 _endTime ) public {\n        require ( _tokenSaleContract != 0 );\n        require( _remainingTokens != 0 );\n        tokenSaleContract = TokenSale(_tokenSaleContract);\n        tokenSaleContract.addMeByRC();\n        soldTokens = 0;\n        remainingTokens = _remainingTokens;\n        setTimeRC( _startTime, _endTime );\n    }"
    },
    {
        "contract_address": "0xf62afd17037be692a00b181e959e3c9931076138",
        "function_name": "RC",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function RC(address _tokenSaleContract, uint256 _oneTokenInUsdWei, uint256 _remainingTokens,  uint256 _startTime , uint256 _endTime ) public {\n        require ( _tokenSaleContract != 0 );\n        require ( _oneTokenInUsdWei != 0 );\n        require( _remainingTokens != 0 );\n        tokenSaleContract = TokenSale(_tokenSaleContract);\n        tokenSaleContract.addMeByRC();\n        soldTokens = 0;\n        remainingTokens = _remainingTokens;\n        oneTokenInUsdWei = _oneTokenInUsdWei;\n        setTimeRC( _startTime, _endTime );\n    }"
    },
    {
        "contract_address": "0xf62afd17037be692a00b181e959e3c9931076138",
        "function_name": "RC",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function RC(address _tokenSaleContract, uint256 _oneTokenInUsdWei, uint256 _remainingTokens,  uint256 _startTime , uint256 _endTime ) public {\n        require ( _tokenSaleContract != 0 );\n        require ( _oneTokenInUsdWei != 0 );\n        require( _remainingTokens != 0 );\n        tokenSaleContract = TokenSale(_tokenSaleContract);\n        tokenSaleContract.addMeByRC();\n        soldTokens = 0;\n        remainingTokens = _remainingTokens;\n        oneTokenInUsdWei = _oneTokenInUsdWei;\n        setTimeRC( _startTime, _endTime );\n    }"
    },
    {
        "contract_address": "0xf62afd17037be692a00b181e959e3c9931076138",
        "function_name": "buyFromRC",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyFromRC(address _buyer, uint256 _rcTokenValue, uint256 ) onlyRC public payable returns(uint256) {\n        uint256 tokenAmount = tokenSaleContract.buyFromRC.value(msg.value)(_buyer, _rcTokenValue, remainingTokens);\n        remainingTokens = remainingTokens.sub(tokenAmount);\n        soldTokens = soldTokens.add(tokenAmount);\n        return tokenAmount;\n    }"
    },
    {
        "contract_address": "0xf62afd17037be692a00b181e959e3c9931076138",
        "function_name": "fallback",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function () public payable {\n        require( now > startTime );\n        require( now < endTime );\n        require( msg.value >= 1*10**18);\n        require( remainingTokens > 0 );\n        uint256 tokenAmount = tokenSaleContract.buyFromRC.value(msg.value)(msg.sender, oneTokenInUsdWei, remainingTokens);\n        remainingTokens = remainingTokens.sub(tokenAmount);\n        soldTokens = soldTokens.add(tokenAmount);\n        BuyRC( msg.sender, msg.data, msg.value, tokenAmount, oneTokenInUsdWei );\n    }"
    },
    {
        "contract_address": "0xf5fe6b716c0cd0e88059d8b3d8385c086012eb0e",
        "function_name": "fallback",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function()\n        isActivated()\n        isHuman()\n        isWithinLimits(msg.value)\n        public\n        payable\n    {\n        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n        uint256 _pID = pIDxAddr_[msg.sender];\n        buyCore(_pID, plyr_[_pID].laff, 0, _eventData_);\n    }"
    },
    {
        "contract_address": "0xf62afd17037be692a00b181e959e3c9931076138",
        "function_name": "addMeByRC",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function addMeByRC() public {\n        require(tx.origin == owner() );\n        rc[ msg.sender ]  = true;\n        NewRC(msg.sender);\n    }"
    },
    {
        "contract_address": "0xf62baa1997f04f165edd100d78241e07617f6ce6",
        "function_name": "upgrade",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function upgrade() public returns (bool success) {\n        require(upgradable);\n        require(upgraderSet);\n        require(upgrader != TokenUpgraderInterface(0));\n        require(!upgrader.hasUpgraded(msg.sender));\n        uint256 value = balances[msg.sender];\n        assert(value > 0);\n        delete balances[msg.sender];\n        totalSupply = totalSupply.sub(value);\n        assert(upgrader.upgradeFor(msg.sender, value));\n        return true;\n    }"
    },
    {
        "contract_address": "0xf62d9cde84bd432bbed30f8f5b09f48830eb7603",
        "function_name": "revoke",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function revoke(ERC20Basic token) public onlyOwner {\n    require(revocable);\n    require(!revoked[token]);\n    uint256 balance = token.balanceOf(this);\n    uint256 unreleased = releasableAmount(token);\n    uint256 refund = balance.sub(unreleased);\n    revoked[token] = true;\n    token.safeTransfer(owner, refund);\n    Revoked();\n  }"
    },
    {
        "contract_address": "0xf62d9cde84bd432bbed30f8f5b09f48830eb7603",
        "function_name": "release",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function release(ERC20Basic token) public {\n    uint256 unreleased = releasableAmount(token);\n    require(unreleased > 0);\n    released[token] = released[token].add(unreleased);\n    token.safeTransfer(beneficiary, unreleased);\n    Released(unreleased);\n  }"
    },
    {
        "contract_address": "0xf64dc764c733a62b4461a7b66386862f92705aab",
        "function_name": "fallback",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function () payable public onlyOpenTime {\n        require(msg.value > 0);\n        uint amount = msg.value;\n        var (buyTokenCount, bonusTokenCount) = _getTokenCount(amount);\n        PurchaserInfo storage pi = purchasers[msg.sender];\n        pi.amountEtherSpent += amount;\n        pi.amountTokenTaken += buyTokenCount;\n        if (pi.lockedToken.length == 0) {\n            pi.lockedToken = new uint[](lockStages.length);\n        }\n        for(uint i = 0; i < lockStages.length; i++) {\n            Stage storage stage = lockStages[i];\n            pi.lockedToken[i] += stage.rate * bonusTokenCount / 100;\n        }\n        amountRaised += amount;\n        amountTokenIssued += buyTokenCount;\n        token.transferFrom(tokenHolder, msg.sender, buyTokenCount);\n        TokenPurchase(msg.sender, amount, buyTokenCount, bonusTokenCount);\n        _addPurchaser(msg.sender);\n        if(isReachedGoal()){\n            endTime = now;\n        }\n    }"
    },
    {
        "contract_address": "0xf67acb7b9226e482afcf7f08aac9466c50c19d9c",
        "function_name": "releaseBatch",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function releaseBatch() external onlyFounders {\n        require(true == vestingStarted);\n        require(now > nextPeriod);\n        require(periodsPassed < totalPeriods);\n        uint tokensToRelease = 0;\n        do {\n            periodsPassed   = periodsPassed.add(1);\n            nextPeriod      = nextPeriod.add(cliffPeriod);\n            tokensToRelease = tokensToRelease.add(tokensPerBatch);\n        } while (now > nextPeriod);\n        if (periodsPassed >= totalPeriods) {\n            tokensToRelease = tokenContract.balanceOf(this);\n            nextPeriod = 0x0;\n        }\n        tokensRemaining = tokensRemaining.sub(tokensToRelease);\n        tokenContract.transfer(foundersWallet, tokensToRelease);\n        TokensReleased(tokensToRelease, tokensRemaining, nextPeriod);\n    }"
    },
    {
        "contract_address": "0xf67acb7b9226e482afcf7f08aac9466c50c19d9c",
        "function_name": "issueTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function issueTokens(address _beneficiary, uint _contribution) onlyBackend onlyUnpaused external;"
    },
    {
        "contract_address": "0xf67acb7b9226e482afcf7f08aac9466c50c19d9c",
        "function_name": "issueTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function issueTokens(address _beneficiary, uint _contribution) onlyBackend onlyUnpaused external;"
    },
    {
        "contract_address": "0xf67acb7b9226e482afcf7f08aac9466c50c19d9c",
        "function_name": "rewardFoundersAndPartners",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function rewardFoundersAndPartners() external onlyManager onlyValidPhase onlyUnpaused {\n        uint tokensDuringThisPhase;\n        if (crowdsalePhase == CrowdsalePhase.PhaseOne) {\n            tokensDuringThisPhase = totalTokenSupply;\n        } else {\n            tokensDuringThisPhase = totalTokenSupply - tokensDuringPhaseOne;\n        }\n        uint tokensForFounders = tokensDuringThisPhase.mul(257).div(1000);\n        uint tokensForPartners = tokensDuringThisPhase.mul(171).div(1000);\n        tokenContract.mint(partnersWallet, tokensForPartners);\n        if (crowdsalePhase == CrowdsalePhase.PhaseOne) {\n            vestingWallet = new VestingWallet(foundersWallet, address(tokenContract));\n            tokenContract.mint(address(vestingWallet), tokensForFounders);\n            FoundersAndPartnersTokensIssued(address(vestingWallet), tokensForFounders,\n                                            partnersWallet,         tokensForPartners);\n            centsInPhaseOne = totalCentsGathered;\n            tokensDuringPhaseOne = totalTokenSupply;\n            tokenContract.unfreeze();\n            crowdsalePhase = CrowdsalePhase.BetweenPhases;\n        } else {\n            tokenContract.mint(address(vestingWallet), tokensForFounders);\n            vestingWallet.launchVesting();\n            FoundersAndPartnersTokensIssued(address(vestingWallet), tokensForFounders,\n                                            partnersWallet,         tokensForPartners);\n            crowdsalePhase = CrowdsalePhase.Finished;\n        }\n        tokenContract.endMinting();\n   }"
    },
    {
        "contract_address": "0xf67acb7b9226e482afcf7f08aac9466c50c19d9c",
        "function_name": "launchVesting",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function launchVesting() public onlyCrowdsale {\n        require(false == vestingStarted);\n        vestingStarted  = true;\n        tokensRemaining = tokenContract.balanceOf(this);\n        nextPeriod      = now.add(cliffPeriod);\n        tokensPerBatch  = tokensRemaining / totalPeriods;\n    }"
    },
    {
        "contract_address": "0xf67acb7b9226e482afcf7f08aac9466c50c19d9c",
        "function_name": "rewardFoundersAndPartners",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function rewardFoundersAndPartners() external onlyManager onlyValidPhase onlyUnpaused {\n        uint tokensDuringThisPhase;\n        if (crowdsalePhase == CrowdsalePhase.PhaseOne) {\n            tokensDuringThisPhase = totalTokenSupply;\n        } else {\n            tokensDuringThisPhase = totalTokenSupply - tokensDuringPhaseOne;\n        }\n        uint tokensForFounders = tokensDuringThisPhase.mul(257).div(1000);\n        uint tokensForPartners = tokensDuringThisPhase.mul(171).div(1000);\n        tokenContract.mint(partnersWallet, tokensForPartners);\n        if (crowdsalePhase == CrowdsalePhase.PhaseOne) {\n            vestingWallet = new VestingWallet(foundersWallet, address(tokenContract));\n            tokenContract.mint(address(vestingWallet), tokensForFounders);\n            FoundersAndPartnersTokensIssued(address(vestingWallet), tokensForFounders,\n                                            partnersWallet,         tokensForPartners);\n            centsInPhaseOne = totalCentsGathered;\n            tokensDuringPhaseOne = totalTokenSupply;\n            tokenContract.unfreeze();\n            crowdsalePhase = CrowdsalePhase.BetweenPhases;\n        } else {\n            tokenContract.mint(address(vestingWallet), tokensForFounders);\n            vestingWallet.launchVesting();\n            FoundersAndPartnersTokensIssued(address(vestingWallet), tokensForFounders,\n                                            partnersWallet,         tokensForPartners);\n            crowdsalePhase = CrowdsalePhase.Finished;\n        }\n        tokenContract.endMinting();\n   }"
    },
    {
        "contract_address": "0xf67acb7b9226e482afcf7f08aac9466c50c19d9c",
        "function_name": "rewardFoundersAndPartners",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function rewardFoundersAndPartners() external onlyManager onlyValidPhase onlyUnpaused {\n        uint tokensDuringThisPhase;\n        if (crowdsalePhase == CrowdsalePhase.PhaseOne) {\n            tokensDuringThisPhase = totalTokenSupply;\n        } else {\n            tokensDuringThisPhase = totalTokenSupply - tokensDuringPhaseOne;\n        }\n        uint tokensForFounders = tokensDuringThisPhase.mul(257).div(1000);\n        uint tokensForPartners = tokensDuringThisPhase.mul(171).div(1000);\n        tokenContract.mint(partnersWallet, tokensForPartners);\n        if (crowdsalePhase == CrowdsalePhase.PhaseOne) {\n            vestingWallet = new VestingWallet(foundersWallet, address(tokenContract));\n            tokenContract.mint(address(vestingWallet), tokensForFounders);\n            FoundersAndPartnersTokensIssued(address(vestingWallet), tokensForFounders,\n                                            partnersWallet,         tokensForPartners);\n            centsInPhaseOne = totalCentsGathered;\n            tokensDuringPhaseOne = totalTokenSupply;\n            tokenContract.unfreeze();\n            crowdsalePhase = CrowdsalePhase.BetweenPhases;\n        } else {\n            tokenContract.mint(address(vestingWallet), tokensForFounders);\n            vestingWallet.launchVesting();\n            FoundersAndPartnersTokensIssued(address(vestingWallet), tokensForFounders,\n                                            partnersWallet,         tokensForPartners);\n            crowdsalePhase = CrowdsalePhase.Finished;\n        }\n        tokenContract.endMinting();\n   }"
    },
    {
        "contract_address": "0xf67acb7b9226e482afcf7f08aac9466c50c19d9c",
        "function_name": "rewardFoundersAndPartners",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function rewardFoundersAndPartners() external onlyManager onlyValidPhase onlyUnpaused {\n        uint tokensDuringThisPhase;\n        if (crowdsalePhase == CrowdsalePhase.PhaseOne) {\n            tokensDuringThisPhase = totalTokenSupply;\n        } else {\n            tokensDuringThisPhase = totalTokenSupply - tokensDuringPhaseOne;\n        }\n        uint tokensForFounders = tokensDuringThisPhase.mul(257).div(1000);\n        uint tokensForPartners = tokensDuringThisPhase.mul(171).div(1000);\n        tokenContract.mint(partnersWallet, tokensForPartners);\n        if (crowdsalePhase == CrowdsalePhase.PhaseOne) {\n            vestingWallet = new VestingWallet(foundersWallet, address(tokenContract));\n            tokenContract.mint(address(vestingWallet), tokensForFounders);\n            FoundersAndPartnersTokensIssued(address(vestingWallet), tokensForFounders,\n                                            partnersWallet,         tokensForPartners);\n            centsInPhaseOne = totalCentsGathered;\n            tokensDuringPhaseOne = totalTokenSupply;\n            tokenContract.unfreeze();\n            crowdsalePhase = CrowdsalePhase.BetweenPhases;\n        } else {\n            tokenContract.mint(address(vestingWallet), tokensForFounders);\n            vestingWallet.launchVesting();\n            FoundersAndPartnersTokensIssued(address(vestingWallet), tokensForFounders,\n                                            partnersWallet,         tokensForPartners);\n            crowdsalePhase = CrowdsalePhase.Finished;\n        }\n        tokenContract.endMinting();\n   }"
    },
    {
        "contract_address": "0xf67acb7b9226e482afcf7f08aac9466c50c19d9c",
        "function_name": "releaseBatch",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function releaseBatch() external onlyFounders {\n        require(true == vestingStarted);\n        require(now > nextPeriod);\n        require(periodsPassed < totalPeriods);\n        uint tokensToRelease = 0;\n        do {\n            periodsPassed   = periodsPassed.add(1);\n            nextPeriod      = nextPeriod.add(cliffPeriod);\n            tokensToRelease = tokensToRelease.add(tokensPerBatch);\n        } while (now > nextPeriod);\n        if (periodsPassed >= totalPeriods) {\n            tokensToRelease = tokenContract.balanceOf(this);\n            nextPeriod = 0x0;\n        }\n        tokensRemaining = tokensRemaining.sub(tokensToRelease);\n        tokenContract.transfer(foundersWallet, tokensToRelease);\n        TokensReleased(tokensToRelease, tokensRemaining, nextPeriod);\n    }"
    },
    {
        "contract_address": "0xf67acb7b9226e482afcf7f08aac9466c50c19d9c",
        "function_name": "rewardFoundersAndPartners",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function rewardFoundersAndPartners() external onlyManager onlyValidPhase onlyUnpaused {\n        uint tokensDuringThisPhase;\n        if (crowdsalePhase == CrowdsalePhase.PhaseOne) {\n            tokensDuringThisPhase = totalTokenSupply;\n        } else {\n            tokensDuringThisPhase = totalTokenSupply - tokensDuringPhaseOne;\n        }\n        uint tokensForFounders = tokensDuringThisPhase.mul(257).div(1000);\n        uint tokensForPartners = tokensDuringThisPhase.mul(171).div(1000);\n        tokenContract.mint(partnersWallet, tokensForPartners);\n        if (crowdsalePhase == CrowdsalePhase.PhaseOne) {\n            vestingWallet = new VestingWallet(foundersWallet, address(tokenContract));\n            tokenContract.mint(address(vestingWallet), tokensForFounders);\n            FoundersAndPartnersTokensIssued(address(vestingWallet), tokensForFounders,\n                                            partnersWallet,         tokensForPartners);\n            centsInPhaseOne = totalCentsGathered;\n            tokensDuringPhaseOne = totalTokenSupply;\n            tokenContract.unfreeze();\n            crowdsalePhase = CrowdsalePhase.BetweenPhases;\n        } else {\n            tokenContract.mint(address(vestingWallet), tokensForFounders);\n            vestingWallet.launchVesting();\n            FoundersAndPartnersTokensIssued(address(vestingWallet), tokensForFounders,\n                                            partnersWallet,         tokensForPartners);\n            crowdsalePhase = CrowdsalePhase.Finished;\n        }\n        tokenContract.endMinting();\n   }"
    },
    {
        "contract_address": "0xf6881c8d07d7a4775eef414dcc58242258587498",
        "function_name": "distributeALCToken",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function distributeALCToken() public {\n\t\tif (beneficiary == msg.sender) {\n\t\t\taddress currentParticipantAddress;\n\t\t\tfor (uint index = 0; index < contributorCount; index++){\n\t\t\t\tcurrentParticipantAddress = contributorIndexes[index];\n\t\t\t\tuint amountAlcToken = contributorList[currentParticipantAddress].tokensAmount;\n\t\t\t\tif (false == contributorList[currentParticipantAddress].isTokenDistributed){\n\t\t\t\t\tbool isSuccess = tokenReward.transfer(currentParticipantAddress, amountAlcToken);\n\t\t\t\t\tif (isSuccess){\n\t\t\t\t\t\tcontributorList[currentParticipantAddress].isTokenDistributed = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheckIfAllALCDistributed();\n\t\t\ttokenBalance = tokenReward.balanceOf(address(this));\n\t\t}\n\t}"
    },
    {
        "contract_address": "0xf6881c8d07d7a4775eef414dcc58242258587498",
        "function_name": "distributeALCTokenBatch",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function distributeALCTokenBatch(uint batchUserCount) public {\n\t\tif (beneficiary == msg.sender) {\n\t\t\taddress currentParticipantAddress;\n\t\t\tuint transferedUserCount = 0;\n\t\t\tfor (uint index = 0; index < contributorCount && transferedUserCount<batchUserCount; index++){\n\t\t\t\tcurrentParticipantAddress = contributorIndexes[index];\n\t\t\t\tuint amountAlcToken = contributorList[currentParticipantAddress].tokensAmount;\n\t\t\t\tif (false == contributorList[currentParticipantAddress].isTokenDistributed){\n\t\t\t\t\tbool isSuccess = tokenReward.transfer(currentParticipantAddress, amountAlcToken);\n\t\t\t\t\ttransferedUserCount = transferedUserCount + 1;\n\t\t\t\t\tif (isSuccess){\n\t\t\t\t\t\tcontributorList[currentParticipantAddress].isTokenDistributed = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheckIfAllALCDistributed();\n\t\t\ttokenBalance = tokenReward.balanceOf(address(this));\n\t\t}\n\t}"
    },
    {
        "contract_address": "0xf6881c8d07d7a4775eef414dcc58242258587498",
        "function_name": "withdrawALC",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function withdrawALC(uint256 tokenAmount) public afterCrowdsaleClosed {\n\t\trequire(beneficiary == msg.sender);\n        if (isALCDistributed && beneficiary == msg.sender) {\n            tokenReward.transfer(beneficiary, tokenAmount);\n\t\t\ttokenBalance = tokenReward.balanceOf(address(this));\n        }\n    }"
    },
    {
        "contract_address": "0xf68cf95284b0966dd87f81848786878d8a25d37b",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0xf69abdda14a67675bc6831997dee1462c31b9aab",
        "function_name": "transferFrom",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function transferFrom(address _from, address _to, uint _value) onlyOwner public returns (bool success) {\n        require(_value <= allowed[_from][msg.sender]);\n        bytes memory empty;\n        _transfer(_from, _to, _value, empty);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        return true;\n    }"
    },
    {
        "contract_address": "0xf69a804d0aa81814eca9a47c890da6720e959077",
        "function_name": "buyTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyTokens(address beneficiary) public payable whenNotPaused {\n    require(beneficiary != address(0));\n    validPurchase();\n    uint256 weiAmount = msg.value;\n    uint256 tokens = getTokenAmount(weiAmount);\n    weiRaised = weiRaised.add(weiAmount);\n    tokensSold = tokensSold.add(tokens);\n    deposited[msg.sender] = deposited[msg.sender].add(weiAmount);\n    updateRoundLimits(tokens);\n    uint256 lockedFor = assignTokens(beneficiary, tokens);\n    emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens, lockedFor);\n    forwardFunds();\n  }"
    },
    {
        "contract_address": "0xf6a83d3a5a41638ddd6437d817a79c05c21065aa",
        "function_name": "init",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function init() public onlyOwner {\n        require(!initialized);\n        initialized = true;\n        if (PAUSED) {\n            MainToken(token).pause();\n        }\n        address[5] memory addresses = [address(0x91afebb7f77eb0d531705d37989a2be312116c64),address(0x91afebb7f77eb0d531705d37989a2be312116c64),address(0x91afebb7f77eb0d531705d37989a2be312116c64),address(0x91afebb7f77eb0d531705d37989a2be312116c64),address(0x91afebb7f77eb0d531705d37989a2be312116c64)];\n        uint[5] memory amounts = [uint(74130000000000000000000000),uint(37065000000000000000000000),uint(66717000000000000000000000),uint(66717000000000000000000000),uint(111195000000000000000000000)];\n        uint64[5] memory freezes = [uint64(0),uint64(0),uint64(0),uint64(1558738801),uint64(1558738801)];\n        for (uint i = 0; i < addresses.length; i++) {\n            if (freezes[i] == 0) {\n                MainToken(token).mint(addresses[i], amounts[i]);\n            } else {\n                MainToken(token).mintAndFreeze(addresses[i], amounts[i], freezes[i]);\n            }\n        }\n        transferOwnership(TARGET_USER);\n        emit Initialized();\n    }"
    },
    {
        "contract_address": "0xf6a83d3a5a41638ddd6437d817a79c05c21065aa",
        "function_name": "constructor",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "constructor(uint256 _rate, address _wallet, ERC20 _token) public {\n    require(_rate > 0);\n    require(_wallet != address(0));\n    require(_token != address(0));\n    rate = _rate;\n    wallet = _wallet;\n    token = _token;\n  }"
    },
    {
        "contract_address": "0xf6a83d3a5a41638ddd6437d817a79c05c21065aa",
        "function_name": "releaseOnce",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function releaseOnce() public {\n        bytes32 headKey = toKey(msg.sender, 0);\n        uint64 head = chains[headKey];\n        require(head != 0);\n        require(uint64(block.timestamp) > head);\n        bytes32 currentKey = toKey(msg.sender, head);\n        uint64 next = chains[currentKey];\n        uint amount = freezings[currentKey];\n        delete freezings[currentKey];\n        balances[msg.sender] = balances[msg.sender].add(amount);\n        freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n        if (next == 0) {\n            delete chains[headKey];\n        } else {\n            chains[headKey] = next;\n            delete chains[currentKey];\n        }\n        emit Released(msg.sender, amount);\n    }"
    },
    {
        "contract_address": "0xf6a83d3a5a41638ddd6437d817a79c05c21065aa",
        "function_name": "hasClosed",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function hasClosed() public view returns (bool) {\n    return block.timestamp > closingTime;\n  }"
    },
    {
        "contract_address": "0xf6a83d3a5a41638ddd6437d817a79c05c21065aa",
        "function_name": "releaseAll",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function releaseAll() public returns (uint tokens) {\n        uint release;\n        uint balance;\n        (release, balance) = getFreezing(msg.sender, 0);\n        while (release != 0 && block.timestamp > release) {\n            releaseOnce();\n            tokens += balance;\n            (release, balance) = getFreezing(msg.sender, 0);\n        }\n    }"
    },
    {
        "contract_address": "0xf6b55acbbc49f4524aa48d19281a9a77c54de10f",
        "function_name": "purchaseWolk",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function purchaseWolk(address _buyer) isPurchasable() payable returns(uint256){\n        require(msg.value > 0);\n        uint256 wolkReceivable = purchaseWolkEstimate(msg.value, exchangeFormula);\n        require(wolkReceivable > 0);\n        contributorTokens = safeAdd(contributorTokens, wolkReceivable);\n        totalTokens = safeAdd(totalTokens, wolkReceivable);\n        balances[_buyer] = safeAdd(balances[_buyer], wolkReceivable);\n        reserveBalance = safeAdd(reserveBalance, msg.value);\n        WolkCreated(_buyer, wolkReceivable);\n        Transfer(address(this),_buyer,wolkReceivable);\n        return wolkReceivable;\n    }"
    },
    {
        "contract_address": "0xf6b55acbbc49f4524aa48d19281a9a77c54de10f",
        "function_name": "sellWolk",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function sellWolk(uint256 _wolkAmount) isSellable() returns(uint256) {\n        require((balances[msg.sender] >= _wolkAmount));\n        uint256 ethReceivable = sellWolkEstimate(_wolkAmount,exchangeFormula);\n        require(this.balance > ethReceivable);\n        balances[msg.sender] = safeSub(balances[msg.sender], _wolkAmount);\n        contributorTokens = safeSub(contributorTokens, _wolkAmount);\n        totalTokens = safeSub(totalTokens, _wolkAmount);\n        reserveBalance = safeSub(this.balance, ethReceivable);\n        WolkDestroyed(msg.sender, _wolkAmount);\n        Transfer(msg.sender, 0x00000000000000000000, _wolkAmount);\n        msg.sender.transfer(ethReceivable);\n        return ethReceivable;\n    }"
    },
    {
        "contract_address": "0xf6b55acbbc49f4524aa48d19281a9a77c54de10f",
        "function_name": "purchaseWolk",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function purchaseWolk(address _buyer) isPurchasable() payable returns(uint256){\n        require(msg.value > 0);\n        uint256 wolkReceivable = purchaseWolkEstimate(msg.value, exchangeFormula);\n        require(wolkReceivable > 0);\n        contributorTokens = safeAdd(contributorTokens, wolkReceivable);\n        totalTokens = safeAdd(totalTokens, wolkReceivable);\n        balances[_buyer] = safeAdd(balances[_buyer], wolkReceivable);\n        reserveBalance = safeAdd(reserveBalance, msg.value);\n        WolkCreated(_buyer, wolkReceivable);\n        Transfer(address(this),_buyer,wolkReceivable);\n        return wolkReceivable;\n    }"
    },
    {
        "contract_address": "0xf6b55acbbc49f4524aa48d19281a9a77c54de10f",
        "function_name": "sellWolk",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function sellWolk(uint256 _wolkAmount) isSellable() returns(uint256) {\n        require((balances[msg.sender] >= _wolkAmount));\n        uint256 ethReceivable = sellWolkEstimate(_wolkAmount,exchangeFormula);\n        require(this.balance > ethReceivable);\n        balances[msg.sender] = safeSub(balances[msg.sender], _wolkAmount);\n        contributorTokens = safeSub(contributorTokens, _wolkAmount);\n        totalTokens = safeSub(totalTokens, _wolkAmount);\n        reserveBalance = safeSub(this.balance, ethReceivable);\n        WolkDestroyed(msg.sender, _wolkAmount);\n        Transfer(msg.sender, 0x00000000000000000000, _wolkAmount);\n        msg.sender.transfer(ethReceivable);\n        return ethReceivable;\n    }"
    },
    {
        "contract_address": "0xf6b55acbbc49f4524aa48d19281a9a77c54de10f",
        "function_name": "updatePurchasePossible",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function updatePurchasePossible(bool _isRunning) onlyOwner returns (bool success){\n        if (_isRunning){\n            require(sellWolkEstimate(10**decimals, exchangeFormula) > 0);\n            require(purchaseWolkEstimate(10**decimals, exchangeFormula) > 0);\n        }\n        isPurchasePossible = _isRunning;\n        return true;\n    }"
    },
    {
        "contract_address": "0xf6b55acbbc49f4524aa48d19281a9a77c54de10f",
        "function_name": "setExchangeFormula",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function setExchangeFormula(address _newExchangeformula) onlyOwner returns (bool success){\n        require(sellWolkEstimate(10**decimals, _newExchangeformula) > 0);\n        require(purchaseWolkEstimate(10**decimals, _newExchangeformula) > 0);\n        isPurchasePossible = false;\n        isSellPossible = false;\n        exchangeFormula = _newExchangeformula;\n        return true;\n    }"
    },
    {
        "contract_address": "0xf6b55acbbc49f4524aa48d19281a9a77c54de10f",
        "function_name": "updateSellPossible",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function updateSellPossible(bool _isRunning) onlyOwner returns (bool success){\n        if (_isRunning){\n            require(sellWolkEstimate(10**decimals, exchangeFormula) > 0);\n            require(purchaseWolkEstimate(10**decimals, exchangeFormula) > 0);\n        }\n        isSellPossible = _isRunning;\n        return true;\n    }"
    },
    {
        "contract_address": "0xf6b55acbbc49f4524aa48d19281a9a77c54de10f",
        "function_name": "tokenGenerationEvent",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function tokenGenerationEvent(address _participant) payable external {\n        require( ( whitelistContributor[_participant] || whitelistContributor[msg.sender] || balances[_participant] > 0 || kycRequirement )  && !allSaleCompleted && ( block.timestamp <= end_time ) && msg.value > 0);\n        uint256 rate = 1000;\n        rate = safeDiv( 175 * 10**5 * 10**decimals, safeAdd( 875 * 10**1 * 10**decimals, safeDiv( totalTokens, 2 * 10**3)) );\n        if ( rate > 2000 ) rate = 2000;\n        if ( rate < 500 ) rate = 500;\n        require(block.number >= start_block) ;\n        uint256 tokens = safeMul(msg.value, rate);\n        uint256 checkedSupply = safeAdd(totalTokens, tokens);\n        require(checkedSupply <= tokenGenerationMax);\n        totalTokens = checkedSupply;\n        contributorTokens = safeAdd(contributorTokens, tokens);\n        Transfer(address(this), _participant, tokens);\n        balances[_participant] = safeAdd(balances[_participant], tokens);\n        contribution[_participant] = safeAdd(contribution[_participant], msg.value);\n        WolkCreated(_participant, tokens);\n    }"
    },
    {
        "contract_address": "0xf6b55acbbc49f4524aa48d19281a9a77c54de10f",
        "function_name": "refund",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function refund() external {\n        require((contribution[msg.sender] > 0) && (!allSaleCompleted) && (block.timestamp > end_time)  && (totalTokens < tokenGenerationMin));\n        uint256 tokenBalance = balances[msg.sender];\n        uint256 refundBalance = contribution[msg.sender];\n        balances[msg.sender] = 0;\n        contribution[msg.sender] = 0;\n        totalTokens = safeSub(totalTokens, tokenBalance);\n        WolkDestroyed(msg.sender, tokenBalance);\n        LogRefund(msg.sender, refundBalance);\n        msg.sender.transfer(refundBalance);\n    }"
    },
    {
        "contract_address": "0xf6b55acbbc49f4524aa48d19281a9a77c54de10f",
        "function_name": "fallback",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function () payable {\n        require(msg.value > 0);\n        if(!allSaleCompleted){\n            this.tokenGenerationEvent.value(msg.value)(msg.sender);\n        } else if ( block.timestamp >= end_time ){\n            this.purchaseWolk.value(msg.value)(msg.sender);\n        } else {\n            revert();\n        }\n    }"
    },
    {
        "contract_address": "0xf6d987033b94f4c00edef0eea8bfca411b49cce1",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0xf6d987033b94f4c00edef0eea8bfca411b49cce1",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0xf6d987033b94f4c00edef0eea8bfca411b49cce1",
        "function_name": "release",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function release() onlyOwner public{\n    require(isLocked);\n    require(!isReleased);\n    require(lockOver());\n    uint256 token_amount = tokenBalance();\n    token_reward.transfer( beneficiary, token_amount);\n    emit TokenReleased(beneficiary, token_amount);\n    isReleased = true;\n  }"
    },
    {
        "contract_address": "0xf6d9d890baa03a8eceef42839d35f2bf7c02fdf1",
        "function_name": "transferFrom",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function transferFrom(address from, address to, uint256 value) public returns (bool);"
    },
    {
        "contract_address": "0xf6da07a8ffb5683314715d8c7a1a5c952b4e74ca",
        "function_name": "createSale",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function createSale(string _bonusPreset, uint256 _startTime, uint256 _endTime,  uint256 _tokensLimit, uint256 _minimalPrice) public onlyOwner{\n        require(activatedSalesTotalCount < maxActivatedSalesTotalCount);\n        require(getTotalCollected() < hardCap );\n        require(token.getRestTokenBalance() >= _tokensLimit);\n        require(sales.length == 0 || sales[sales.length - 1].activated());\n        Sale newSale = new Sale();\n        newSale.init({\n            _bonusPreset: _bonusPreset,\n            _startTime: _startTime,\n            _endTime: _endTime,\n            _tokensLimit: _tokensLimit,\n            _minimalPrice: _minimalPrice,\n            _token: token,\n            _multisigWallet: multisigWallet\n            });\n        newSale.transferOwnership(owner);\n        sales.push(newSale);\n    }"
    },
    {
        "contract_address": "0xf6da07a8ffb5683314715d8c7a1a5c952b4e74ca",
        "function_name": "activateLastSale",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function activateLastSale() public onlyOwner {\n        require(activatedSalesTotalCount < maxActivatedSalesTotalCount);\n        require(!sales[sales.length - 1].activated());\n        activatedSalesTotalCount ++;\n        sales[sales.length - 1].activate();\n        token.setSaleAgent(sales[sales.length - 1]);\n    }"
    },
    {
        "contract_address": "0xf6da07a8ffb5683314715d8c7a1a5c952b4e74ca",
        "function_name": "deploy",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function deploy() public onlyOwner {\n        require(!isDeployed);\n        isDeployed = true;\n        softCap = 8000 ether;\n        hardCap = 50000 ether;\n        maxActivatedSalesTotalCount = 5;\n        setGlobalMultisigWallet(0x9264669C5071944EaF5898B13f049aA667a2f94B);\n        token = new DLCToken();\n        token.setTotalSupply(1000000000 * 1 ether);\n        token.setFoundersTokensPercent(15);\n        token.setBountyTokensPercent(1);\n        token.setDevelopmentAuditPromotionTokensPercent(10);\n        token.setPriceOfToken(0.000183 * 1 ether);\n        token.setToSaleWallet(0x1Ab521E26d76826cE3130Dd7E31c64870016C268);\n        token.setBountyWallet(0xD1Aac7097a9a79EC60940Af9c6cCcD78597534bc);\n        token.setFoundersWallet(0xf5EEbE2be833458367200389ad567Cc1A450CD64);\n        token.setDevelopmentAuditPromotionWallet(0xebb8776f710A5Df053C291Fe65228687f07faACB);\n        token.transferOwnership(owner);\n        token.init();\n        createSale({\n            _bonusPreset: 'privatesale',\n            _startTime: 1526331600,\n            _endTime:   1527714000,\n            _tokensLimit: 80000000 * 1 ether,\n            _minimalPrice: 1 ether\n            });\n        activateLastSale();\n        createSale({\n            _bonusPreset: 'presale',\n            _startTime: 1529010000,\n            _endTime:   1530306000,\n            _tokensLimit: 75000000 * 1 ether,\n            _minimalPrice: 0.03 ether\n            });\n    }"
    },
    {
        "contract_address": "0xf6da07a8ffb5683314715d8c7a1a5c952b4e74ca",
        "function_name": "deploy",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function deploy() public onlyOwner {\n        require(!isDeployed);\n        isDeployed = true;\n        softCap = 8000 ether;\n        hardCap = 50000 ether;\n        maxActivatedSalesTotalCount = 5;\n        setGlobalMultisigWallet(0x9264669C5071944EaF5898B13f049aA667a2f94B);\n        token = new DLCToken();\n        token.setTotalSupply(1000000000 * 1 ether);\n        token.setFoundersTokensPercent(15);\n        token.setBountyTokensPercent(1);\n        token.setDevelopmentAuditPromotionTokensPercent(10);\n        token.setPriceOfToken(0.000183 * 1 ether);\n        token.setToSaleWallet(0x1Ab521E26d76826cE3130Dd7E31c64870016C268);\n        token.setBountyWallet(0xD1Aac7097a9a79EC60940Af9c6cCcD78597534bc);\n        token.setFoundersWallet(0xf5EEbE2be833458367200389ad567Cc1A450CD64);\n        token.setDevelopmentAuditPromotionWallet(0xebb8776f710A5Df053C291Fe65228687f07faACB);\n        token.transferOwnership(owner);\n        token.init();\n        createSale({\n            _bonusPreset: 'privatesale',\n            _startTime: 1526331600,\n            _endTime:   1527714000,\n            _tokensLimit: 80000000 * 1 ether,\n            _minimalPrice: 1 ether\n            });\n        activateLastSale();\n        createSale({\n            _bonusPreset: 'presale',\n            _startTime: 1529010000,\n            _endTime:   1530306000,\n            _tokensLimit: 75000000 * 1 ether,\n            _minimalPrice: 0.03 ether\n            });\n    }"
    },
    {
        "contract_address": "0xf6da07a8ffb5683314715d8c7a1a5c952b4e74ca",
        "function_name": "deploy",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function deploy() public onlyOwner {\n        require(!isDeployed);\n        isDeployed = true;\n        softCap = 8000 ether;\n        hardCap = 50000 ether;\n        maxActivatedSalesTotalCount = 5;\n        setGlobalMultisigWallet(0x9264669C5071944EaF5898B13f049aA667a2f94B);\n        token = new DLCToken();\n        token.setTotalSupply(1000000000 * 1 ether);\n        token.setFoundersTokensPercent(15);\n        token.setBountyTokensPercent(1);\n        token.setDevelopmentAuditPromotionTokensPercent(10);\n        token.setPriceOfToken(0.000183 * 1 ether);\n        token.setToSaleWallet(0x1Ab521E26d76826cE3130Dd7E31c64870016C268);\n        token.setBountyWallet(0xD1Aac7097a9a79EC60940Af9c6cCcD78597534bc);\n        token.setFoundersWallet(0xf5EEbE2be833458367200389ad567Cc1A450CD64);\n        token.setDevelopmentAuditPromotionWallet(0xebb8776f710A5Df053C291Fe65228687f07faACB);\n        token.transferOwnership(owner);\n        token.init();\n        createSale({\n            _bonusPreset: 'privatesale',\n            _startTime: 1526331600,\n            _endTime:   1527714000,\n            _tokensLimit: 80000000 * 1 ether,\n            _minimalPrice: 1 ether\n            });\n        activateLastSale();\n        createSale({\n            _bonusPreset: 'presale',\n            _startTime: 1529010000,\n            _endTime:   1530306000,\n            _tokensLimit: 75000000 * 1 ether,\n            _minimalPrice: 0.03 ether\n            });\n    }"
    },
    {
        "contract_address": "0xf6da07a8ffb5683314715d8c7a1a5c952b4e74ca",
        "function_name": "removeLastSaleOnlyNotActivated",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function removeLastSaleOnlyNotActivated() public onlyOwner {\n        require(!sales[sales.length - 1].activated());\n        delete sales[sales.length - 1];\n    }"
    },
    {
        "contract_address": "0xf6da07a8ffb5683314715d8c7a1a5c952b4e74ca",
        "function_name": "buyTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyTokens(address beneficiary) public payable {\n        require(beneficiary != address(0));\n        require(validPurchase());\n        uint256 amount = msg.value;\n        uint256 tokens = calculateTokensQtyByEther({\n            amount: amount\n            });\n        require(tokensTransferred.add(tokens) < tokensLimit);\n        tokensTransferred = tokensTransferred.add(tokens);\n        collected = collected.add(amount);\n        token.purchase(beneficiary, tokens);\n        emit TokenPurchase(msg.sender, beneficiary, amount, tokens);\n        forwardFunds();\n    }"
    },
    {
        "contract_address": "0xf6da07a8ffb5683314715d8c7a1a5c952b4e74ca",
        "function_name": "deploy",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function deploy() public onlyOwner {\n        require(!isDeployed);\n        isDeployed = true;\n        softCap = 8000 ether;\n        hardCap = 50000 ether;\n        maxActivatedSalesTotalCount = 5;\n        setGlobalMultisigWallet(0x9264669C5071944EaF5898B13f049aA667a2f94B);\n        token = new DLCToken();\n        token.setTotalSupply(1000000000 * 1 ether);\n        token.setFoundersTokensPercent(15);\n        token.setBountyTokensPercent(1);\n        token.setDevelopmentAuditPromotionTokensPercent(10);\n        token.setPriceOfToken(0.000183 * 1 ether);\n        token.setToSaleWallet(0x1Ab521E26d76826cE3130Dd7E31c64870016C268);\n        token.setBountyWallet(0xD1Aac7097a9a79EC60940Af9c6cCcD78597534bc);\n        token.setFoundersWallet(0xf5EEbE2be833458367200389ad567Cc1A450CD64);\n        token.setDevelopmentAuditPromotionWallet(0xebb8776f710A5Df053C291Fe65228687f07faACB);\n        token.transferOwnership(owner);\n        token.init();\n        createSale({\n            _bonusPreset: 'privatesale',\n            _startTime: 1526331600,\n            _endTime:   1527714000,\n            _tokensLimit: 80000000 * 1 ether,\n            _minimalPrice: 1 ether\n            });\n        activateLastSale();\n        createSale({\n            _bonusPreset: 'presale',\n            _startTime: 1529010000,\n            _endTime:   1530306000,\n            _tokensLimit: 75000000 * 1 ether,\n            _minimalPrice: 0.03 ether\n            });\n    }"
    },
    {
        "contract_address": "0xf6fd82dedbbe0ffadb5e1ecc2a283ab52b9ed2b0",
        "function_name": "approve",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function approve(address spender, uint256 value) public returns (bool);"
    },
    {
        "contract_address": "0xf70a642bd387f94380ffb90451c2c81d4eb82cbc",
        "function_name": "declareMvpLaunched",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function declareMvpLaunched(uint256 launchedAt)\n        external\n        onlyFundraiser\n        onlyAfterCrowdsale\n        returns (bool)\n    {\n        require(mvpLaunchedAt == 0);\n        require(launchedAt <= now);\n        require(starbaseCrowdsale.isEnded());\n        mvpLaunchedAt = launchedAt;\n        MvpLaunched(launchedAt);\n        return true;\n    }"
    },
    {
        "contract_address": "0xf70a642bd387f94380ffb90451c2c81d4eb82cbc",
        "function_name": "issueTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function issueTokens(address _for, uint256 value)\n        external\n        onlyFundraiser\n        onlyAfterCrowdsale\n        returns (bool)\n    {\n        require(_for != address(0));\n        assert(value <= numOfInflatableTokens());\n        totalSupply = SafeMath.add(totalSupply, value);\n        balances[_for] = SafeMath.add(balances[_for], value);\n        return true;\n    }"
    },
    {
        "contract_address": "0xf70a642bd387f94380ffb90451c2c81d4eb82cbc",
        "function_name": "transferFrom",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function transferFrom(address from, address to, uint256 value) public returns (bool);"
    },
    {
        "contract_address": "0xf70a642bd387f94380ffb90451c2c81d4eb82cbc",
        "function_name": "transfer",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function transfer(address to, uint256 value) public returns (bool);"
    },
    {
        "contract_address": "0xf70a642bd387f94380ffb90451c2c81d4eb82cbc",
        "function_name": "declarePublicOfferingPlan",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function declarePublicOfferingPlan(uint256 tokenCount, uint256 unlockCompanysTokensAt)\n        external\n        onlyFundraiser\n        onlyAfterCrowdsale\n        returns (bool)\n    {\n        assert(tokenCount <= 100000000e18);\n        assert(SafeMath.sub(now, starbaseCrowdsale.endedAt()) >= 180 days);\n        assert(SafeMath.sub(unlockCompanysTokensAt, now) >= 60 days);\n        if (publicOfferingPlans.length > 0) {\n            uint256 lastDeclaredAt =\n                publicOfferingPlans[publicOfferingPlans.length - 1].declaredAt;\n            assert(SafeMath.sub(now, lastDeclaredAt) >= 180 days);\n        }\n        uint256 totalDeclaredTokenCount = tokenCount;\n        for (uint8 i; i < publicOfferingPlans.length; i++) {\n            totalDeclaredTokenCount = SafeMath.add(totalDeclaredTokenCount, publicOfferingPlans[i].tokenCount);\n        }\n        assert(totalDeclaredTokenCount <= initialCompanysTokenAllocation);\n        publicOfferingPlans.push(\n            PublicOfferingPlan(tokenCount, unlockCompanysTokensAt, now));\n        PublicOfferingPlanDeclared(tokenCount, unlockCompanysTokensAt);\n    }"
    },
    {
        "contract_address": "0xf70a642bd387f94380ffb90451c2c81d4eb82cbc",
        "function_name": "transferFrom",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function transferFrom(address from, address to, uint256 value) public returns (bool);"
    },
    {
        "contract_address": "0xf70a642bd387f94380ffb90451c2c81d4eb82cbc",
        "function_name": "issueTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function issueTokens(address _for, uint256 value)\n        external\n        onlyFundraiser\n        onlyAfterCrowdsale\n        returns (bool)\n    {\n        require(_for != address(0));\n        assert(value <= numOfInflatableTokens());\n        totalSupply = SafeMath.add(totalSupply, value);\n        balances[_for] = SafeMath.add(balances[_for], value);\n        return true;\n    }"
    },
    {
        "contract_address": "0xf70e44e803e66c40890ac4875e5036fdb55b5e81",
        "function_name": "closeBet",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function closeBet() external {\n    require(!isBetClosed);\n    (leftPts, rightPts, confirmations) = dataCenterGetResult(betInfo.gameId);\n    require(confirmations >= neededConfirmations);\n    LogGameResult(betInfo.category, betInfo.gameId, leftPts, rightPts);\n    winChoice = getWinChoice(leftPts, rightPts);\n    if (winChoice == 1) {\n      distributeReward(betInfo.leftOdds);\n    } else if (winChoice == 2) {\n      distributeReward(betInfo.middleOdds);\n    } else {\n      distributeReward(betInfo.rightOdds);\n    }\n    isBetClosed = true;\n    LogBetClosed(false, now);\n    withdraw();\n  }"
    },
    {
        "contract_address": "0xf70e44e803e66c40890ac4875e5036fdb55b5e81",
        "function_name": "closeBet",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function closeBet() external {\n    require(!isBetClosed);\n    (leftPts, rightPts, confirmations) = dataCenterGetResult(betInfo.gameId);\n    require(confirmations >= neededConfirmations);\n    LogGameResult(betInfo.category, betInfo.gameId, leftPts, rightPts);\n    winChoice = getWinChoice(leftPts, rightPts);\n    if (winChoice == 1) {\n      distributeReward(betInfo.leftOdds);\n    } else if (winChoice == 2) {\n      distributeReward(betInfo.middleOdds);\n    } else {\n      distributeReward(betInfo.rightOdds);\n    }\n    isBetClosed = true;\n    LogBetClosed(false, now);\n    withdraw();\n  }"
    },
    {
        "contract_address": "0xf72c66c8a1ca8e1f5475f46632fc804ec7c64660",
        "function_name": "claim",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function claim(address verifier, uint verifiedAttributes, uint expires, uint8 v, bytes32 r, bytes32 s)\n      public\n      onlyValidAuthority(verifier)\n      onlyAuthoritativeAuthority(verifier, msg.sender)\n    {\n        if (verificationFee > 0) {\n            if(!chargeVerificationFee(msg.sender, verifier)) {\n                revert();\n            }\n        }\n        bytes32 hash = sha256(this, msg.sender, verifiedAttributes, expires);\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 prefixedHash = keccak256(prefix, hash);\n        if (!((ecrecover(prefixedHash, v, r, s) == verifier) && block.number <= expires)) {\n            revert();\n        }\n        KYC memory kyc = KYC({\n            verified: true,\n            verifiedBy: verifier,\n            verifiedAt: block.number,\n            verifiedAttributes: verifiedAttributes\n        });\n        records[msg.sender] = kyc;\n    }"
    },
    {
        "contract_address": "0xf731a3b8fb18f9ee915056b18d716bcbb77bebf5",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0xf7122bb9f34c1ffbdc961940ed6aa6000fbf3ec7",
        "function_name": "execute",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function execute(bytes32 _proposalId, address _avatar, int _param) public returns(bool);"
    },
    {
        "contract_address": "0xf73c97245b3be2559d01343bffaa3e3a69f6dd3b",
        "function_name": "BuyItem",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function BuyItem(uint256 id, string quote) public payable{\n    \trequire(id < next_item_index);\n    \tvar UsedItem = Items[id];\n    \tif (UsedItem.owner != address(0) && block.timestamp > (add(UsedItem.timestamp, UsedItem.timer))){\n    \t\tPayout(id);\n    \t\tif (msg.value > 0){\n    \t\t\tmsg.sender.transfer(msg.value);\n    \t\t}\n    \t\treturn;\n    \t}\n    \trequire(msg.value >= UsedItem.price);\n    \trequire(msg.sender != owner);\n    \trequire(msg.sender != UsedItem.owner);\n    \tuint256 devFee_used = mul(UsedItem.price, devFee) / 10000;\n    \tuint256 creatorFee_used = mul(UsedItem.price, UsedItem.creatorFee) / 10000;\n    \tuint256 prevFee_used;\n   \t\tif (UsedItem.owner == address(0)){\n   \t\t\tprevFee_used = 0;\n   \t\t}\n   \t\telse{\n   \t\t\tprevFee_used = (mul(UsedItem.price, UsedItem.previousFee)) / 10000;\n   \t\t\tUsedItem.owner.transfer(prevFee_used);\n   \t\t}\n   \t\tif (creatorFee_used != 0){\n   \t\t\tUsedItem.creator.transfer(creatorFee_used);\n   \t\t}\n   \t\tif (devFee_used != 0){\n   \t\t\towner.transfer(devFee_used);\n   \t\t}\n   \t\tif (msg.value > UsedItem.price){\n   \t\t    msg.sender.transfer(sub(msg.value, UsedItem.price));\n   \t\t}\n   \t\tuint256 potFee_used = sub(sub(sub(UsedItem.price, devFee_used), creatorFee_used), prevFee_used);\n   \t\tUsedItem.amount = add(UsedItem.amount, potFee_used);\n   \t\tUsedItem.timestamp = block.timestamp;\n   \t\tUsedItem.owner = msg.sender;\n   \t\tUsedItem.quote = quote;\n   \t\tUsedItem.price = (UsedItem.price * (add(10000, UsedItem.priceIncrease)))/10000;\n   \t\temit ItemBought(id);\n    }"
    },
    {
        "contract_address": "0xf73c97245b3be2559d01343bffaa3e3a69f6dd3b",
        "function_name": "TakePrize",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function TakePrize(uint256 id) public {\n    \trequire(id < next_item_index);\n    \tvar UsedItem = Items[id];\n    \trequire(UsedItem.owner != address(0));\n    \tuint256 TimingTarget = add(UsedItem.timer, UsedItem.timestamp);\n    \tif (block.timestamp > TimingTarget){\n    \t\tPayout(id);\n    \t\treturn;\n    \t}\n    \telse{\n    \t\trevert();\n    \t}\n    }"
    },
    {
        "contract_address": "0xf750f12364a63e462cf5ac6f0f5b60bb9f8b4305",
        "function_name": "__callback",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function __callback(bytes32 myid, string result) public {\n            __callback(myid, result, new bytes(0));\n        }"
    },
    {
        "contract_address": "0xf750f12364a63e462cf5ac6f0f5b60bb9f8b4305",
        "function_name": "__callback",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function __callback(bytes32 myid, string result) public {\n            __callback(myid, result, new bytes(0));\n        }"
    },
    {
        "contract_address": "0xf750f12364a63e462cf5ac6f0f5b60bb9f8b4305",
        "function_name": "__callback",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function __callback(bytes32 myid, string result) public {\n            __callback(myid, result, new bytes(0));\n        }"
    },
    {
        "contract_address": "0xf750f12364a63e462cf5ac6f0f5b60bb9f8b4305",
        "function_name": "__callback",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function __callback(bytes32 myid, string result) public {\n            __callback(myid, result, new bytes(0));\n        }"
    },
    {
        "contract_address": "0xf750f12364a63e462cf5ac6f0f5b60bb9f8b4305",
        "function_name": "__callback",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function __callback(bytes32 myid, string result) public {\n            __callback(myid, result, new bytes(0));\n        }"
    },
    {
        "contract_address": "0xf768682e4891ce064c69c192a2cb580359dbb886",
        "function_name": "release",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function release() public {\n        uint256 num = now.sub(RELEASE_START).div(RELEASE_INTERVAL);\n        if (totalLockAmount == 0) {\n            totalLockAmount = tosToken.balanceOf(this);\n        }\n        if (num >= releasePercentages.length.sub(1)) {\n            tosToken.safeTransfer(beneficiary, tosToken.balanceOf(this));\n            released = 100;\n        }\n        else {\n            uint256 releaseAmount = totalLockAmount.mul(releasePercentages[num].sub(released)).div(100);\n            tosToken.safeTransfer(beneficiary, releaseAmount);\n            released = releasePercentages[num];\n        }\n    }"
    },
    {
        "contract_address": "0xf768682e4891ce064c69c192a2cb580359dbb886",
        "function_name": "release",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function release() public {\n        uint256 num = now.sub(RELEASE_START).div(RELEASE_INTERVAL);\n        if (totalLockAmount == 0) {\n            totalLockAmount = tosToken.balanceOf(this);\n        }\n        if (num >= releasePercentages.length.sub(1)) {\n            tosToken.safeTransfer(beneficiary, tosToken.balanceOf(this));\n            released = 100;\n        }\n        else {\n            uint256 releaseAmount = totalLockAmount.mul(releasePercentages[num].sub(released)).div(100);\n            tosToken.safeTransfer(beneficiary, releaseAmount);\n            released = releasePercentages[num];\n        }\n    }"
    },
    {
        "contract_address": "0xf769e8fd6c001394007177cfc8e207073d9d5165",
        "function_name": "claimTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function claimTokens(address _beneficiary) public payable ifNotStartExp ifNotPaused ifNotBlacklisted {\n\t   require(msg.value >= mineth);\n\t   require(_beneficiary != address(0));\n\t   require(!blacklist[msg.sender]);\n       require(!isProcess[_beneficiary]);\n       require(signups[_beneficiary]);\n\t   uint256 rewardAmount = getReward(_beneficiary);\n\t   require(rewardAmount > 0);\n\t   uint256 taBal = token.balanceOf(this);\n\t   require(rewardAmount <= taBal);\n\t   isProcess[_beneficiary] = true;\n\t   token.transfer(_beneficiary, rewardAmount);\n\t   bounties[_beneficiary].reward_amount = 0;\n\t   bounties[_beneficiary].status = true;\n\t   bounties[_beneficiary].paid_time = now;\n\t   isProcess[_beneficiary] = false;\n\t   userClaimAmt = userClaimAmt.add(rewardAmount);\n\t   forwardWei();\n\t   emit eTokenClaim(_beneficiary, rewardAmount);\n    }"
    },
    {
        "contract_address": "0xf769e8fd6c001394007177cfc8e207073d9d5165",
        "function_name": "claimTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function claimTokens(address _beneficiary) public payable ifNotStartExp ifNotPaused ifNotBlacklisted {\n\t   require(msg.value >= mineth);\n\t   require(_beneficiary != address(0));\n\t   require(!blacklist[msg.sender]);\n       require(!isProcess[_beneficiary]);\n       require(signups[_beneficiary]);\n\t   uint256 rewardAmount = getReward(_beneficiary);\n\t   require(rewardAmount > 0);\n\t   uint256 taBal = token.balanceOf(this);\n\t   require(rewardAmount <= taBal);\n\t   isProcess[_beneficiary] = true;\n\t   token.transfer(_beneficiary, rewardAmount);\n\t   bounties[_beneficiary].reward_amount = 0;\n\t   bounties[_beneficiary].status = true;\n\t   bounties[_beneficiary].paid_time = now;\n\t   isProcess[_beneficiary] = false;\n\t   userClaimAmt = userClaimAmt.add(rewardAmount);\n\t   forwardWei();\n\t   emit eTokenClaim(_beneficiary, rewardAmount);\n    }"
    },
    {
        "contract_address": "0xf769e8fd6c001394007177cfc8e207073d9d5165",
        "function_name": "signupUserWhitelist",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function signupUserWhitelist(address[] _userlist, uint256[] _amount) public onlyStaffs{\n    \trequire(_userlist.length > 0);\n\t\trequire(_amount.length > 0);\n    \tfor (uint256 i = 0; i < _userlist.length; i++) {\n    \t\taddress baddr = _userlist[i];\n    \t\tuint256 bval = _amount[i];\n    \t\tif(baddr != address(0) && userSignupCount <= maxSignup){\n    \t\t\tif(!bounties[baddr].blacklisted && bounties[baddr].user_address != baddr){\n\t\t\t\t\tsignups[baddr] = true;\n\t\t\t\t\tbountyaddress.push(baddr) -1;\n\t\t\t\t\tuserSignupCount++;\n\t\t\t\t\tif(payoutNow==4){\n\t\t\t\t\t\tbounties[baddr] = User(baddr,now,0,false,now,bval,true);\n\t\t\t\t\t\ttoken.transfer(baddr, bval);\n\t\t\t\t\t\tuserClaimAmt = userClaimAmt.add(bval);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbounties[baddr] = User(baddr,now,bval,false,0,0,true);\n\t\t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    }"
    },
    {
        "contract_address": "0xf769e8fd6c001394007177cfc8e207073d9d5165",
        "function_name": "claimImmediateTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function claimImmediateTokens(address _beneficiary) public payable ifNotStartExp ifNotPaused ifNotBlacklisted {\n\t   require(msg.value >= mineth);\n\t   require(_beneficiary != address(0));\n\t   require(!blacklist[msg.sender]);\n\t   require(userSignupCount <= maxSignup);\n\t   require(fixPayAmt > 0);\n\t   uint256 taBal = token.balanceOf(this);\n\t   require(taBal > 0);\n\t   require(fixPayAmt <= taBal);\n       require(!isProcess[_beneficiary]);\n\t   isProcess[_beneficiary] = true;\n\t   signups[_beneficiary] = true;\n\t   bounties[_beneficiary] = User(_beneficiary,now,0,false,now,fixPayAmt,true);\n\t   bountyaddress.push(_beneficiary) -1;\n\t   userSignupCount++;\n\t   token.transfer(_beneficiary, fixPayAmt);\n\t   userClaimAmt = userClaimAmt.add(fixPayAmt);\n\t   forwardWei();\n\t   emit eTokenClaim(_beneficiary, fixPayAmt);\n    }"
    },
    {
        "contract_address": "0xf769e8fd6c001394007177cfc8e207073d9d5165",
        "function_name": "claimImmediateTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function claimImmediateTokens(address _beneficiary) public payable ifNotStartExp ifNotPaused ifNotBlacklisted {\n\t   require(msg.value >= mineth);\n\t   require(_beneficiary != address(0));\n\t   require(!blacklist[msg.sender]);\n\t   require(userSignupCount <= maxSignup);\n\t   require(fixPayAmt > 0);\n\t   uint256 taBal = token.balanceOf(this);\n\t   require(taBal > 0);\n\t   require(fixPayAmt <= taBal);\n       require(!isProcess[_beneficiary]);\n\t   isProcess[_beneficiary] = true;\n\t   signups[_beneficiary] = true;\n\t   bounties[_beneficiary] = User(_beneficiary,now,0,false,now,fixPayAmt,true);\n\t   bountyaddress.push(_beneficiary) -1;\n\t   userSignupCount++;\n\t   token.transfer(_beneficiary, fixPayAmt);\n\t   userClaimAmt = userClaimAmt.add(fixPayAmt);\n\t   forwardWei();\n\t   emit eTokenClaim(_beneficiary, fixPayAmt);\n    }"
    },
    {
        "contract_address": "0xf769e8fd6c001394007177cfc8e207073d9d5165",
        "function_name": "claimImmediateTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function claimImmediateTokens(address _beneficiary) public payable ifNotStartExp ifNotPaused ifNotBlacklisted {\n\t   require(msg.value >= mineth);\n\t   require(_beneficiary != address(0));\n\t   require(!blacklist[msg.sender]);\n\t   require(userSignupCount <= maxSignup);\n\t   require(fixPayAmt > 0);\n\t   uint256 taBal = token.balanceOf(this);\n\t   require(taBal > 0);\n\t   require(fixPayAmt <= taBal);\n       require(!isProcess[_beneficiary]);\n\t   isProcess[_beneficiary] = true;\n\t   signups[_beneficiary] = true;\n\t   bounties[_beneficiary] = User(_beneficiary,now,0,false,now,fixPayAmt,true);\n\t   bountyaddress.push(_beneficiary) -1;\n\t   userSignupCount++;\n\t   token.transfer(_beneficiary, fixPayAmt);\n\t   userClaimAmt = userClaimAmt.add(fixPayAmt);\n\t   forwardWei();\n\t   emit eTokenClaim(_beneficiary, fixPayAmt);\n    }"
    },
    {
        "contract_address": "0xf769e8fd6c001394007177cfc8e207073d9d5165",
        "function_name": "claimTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function claimTokens(address _beneficiary) public payable ifNotStartExp ifNotPaused ifNotBlacklisted {\n\t   require(msg.value >= mineth);\n\t   require(_beneficiary != address(0));\n\t   require(!blacklist[msg.sender]);\n       require(!isProcess[_beneficiary]);\n       require(signups[_beneficiary]);\n\t   uint256 rewardAmount = getReward(_beneficiary);\n\t   require(rewardAmount > 0);\n\t   uint256 taBal = token.balanceOf(this);\n\t   require(rewardAmount <= taBal);\n\t   isProcess[_beneficiary] = true;\n\t   token.transfer(_beneficiary, rewardAmount);\n\t   bounties[_beneficiary].reward_amount = 0;\n\t   bounties[_beneficiary].status = true;\n\t   bounties[_beneficiary].paid_time = now;\n\t   isProcess[_beneficiary] = false;\n\t   userClaimAmt = userClaimAmt.add(rewardAmount);\n\t   forwardWei();\n\t   emit eTokenClaim(_beneficiary, rewardAmount);\n    }"
    },
    {
        "contract_address": "0xf779522f3be94b4cd790eb80966c8b5559cdfd9f",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0xf779522f3be94b4cd790eb80966c8b5559cdfd9f",
        "function_name": "release",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function release() onlyOwner public{\n    require(isLocked);\n    require(!isReleased);\n    require(lockOver());\n    uint256 token_amount = tokenBalance();\n    token_reward.transfer( beneficiary, token_amount);\n    emit TokenReleased(beneficiary, token_amount);\n    isReleased = true;\n  }"
    },
    {
        "contract_address": "0xf786d8914589e06753023eada09fd88a7e42baa5",
        "function_name": "transfer",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function transfer(address to, uint256 value) public returns (bool);"
    },
    {
        "contract_address": "0xf78e67a4eee524e2ab9020131f463c1dc1ee8aba",
        "function_name": "initialize",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function initialize(DSToken geneos) auth {\n        assert(address(GENEOS) == address(0));\n        assert(geneos.owner() == address(this));\n        assert(geneos.authority() == DSAuthority(0));\n        assert(geneos.totalSupply() == 0);\n        GENEOS = geneos;\n        GENEOS.mint(totalSupply);\n        GENEOS.push(foundersAddress, foundersAllocation);\n        keys[foundersAddress] = foundersKey;\n        LogRegister(foundersAddress, foundersKey);\n    }"
    },
    {
        "contract_address": "0xf78e67a4eee524e2ab9020131f463c1dc1ee8aba",
        "function_name": "DSToken",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function DSToken(WhiteList wlc_) {\n        require(msg.sender == wlc_.owner());\n        wlcontract = wlc_;\n    }"
    },
    {
        "contract_address": "0xf78e67a4eee524e2ab9020131f463c1dc1ee8aba",
        "function_name": "approve",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function approve( address spender, uint value ) returns (bool ok);"
    },
    {
        "contract_address": "0xf78e67a4eee524e2ab9020131f463c1dc1ee8aba",
        "function_name": "burn",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function burn(uint128 wad) auth stoppable note {\n        require(wlcontract.whiteList(msg.sender));\n        _balances[msg.sender] = sub(_balances[msg.sender], wad);\n        _supply = sub(_supply, wad);\n    }"
    },
    {
        "contract_address": "0xf78e67a4eee524e2ab9020131f463c1dc1ee8aba",
        "function_name": "initialize",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function initialize(DSToken geneos) auth {\n        assert(address(GENEOS) == address(0));\n        assert(geneos.owner() == address(this));\n        assert(geneos.authority() == DSAuthority(0));\n        assert(geneos.totalSupply() == 0);\n        GENEOS = geneos;\n        GENEOS.mint(totalSupply);\n        GENEOS.push(foundersAddress, foundersAllocation);\n        keys[foundersAddress] = foundersKey;\n        LogRegister(foundersAddress, foundersKey);\n    }"
    },
    {
        "contract_address": "0xf78e67a4eee524e2ab9020131f463c1dc1ee8aba",
        "function_name": "mint",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function mint(uint128 wad) auth stoppable note {\n        require(wlcontract.whiteList(msg.sender));\n        _balances[msg.sender] = add(_balances[msg.sender], wad);\n        _supply = add(_supply, wad);\n    }"
    },
    {
        "contract_address": "0xf78e67a4eee524e2ab9020131f463c1dc1ee8aba",
        "function_name": "transferFrom",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function transferFrom( address from, address to, uint value) returns (bool ok);"
    },
    {
        "contract_address": "0xf78e67a4eee524e2ab9020131f463c1dc1ee8aba",
        "function_name": "transfer",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function transfer( address to, uint value) returns (bool ok);"
    },
    {
        "contract_address": "0xf7920b0768ecb20a123fac32311d07d193381d6f",
        "function_name": "approve",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function approve(address _spender, uint256 _value) returns (bool success);"
    },
    {
        "contract_address": "0xf7a542a7f61d6479e8c63b8c43943df32262d71d",
        "function_name": "batchAssignment",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function batchAssignment(address[] to, uint[] value) public onlyAuthorized depositPhase {\n    require(to.length == value.length);\n    require(to.length <= maxBatchAssignment);\n    uint newTotalStakes = totalStakes;\n    uint numSH = numHolders;\n    for (uint8 i = 0; i < to.length; i++) {\n      newTotalStakes = safeSub(safeAdd(newTotalStakes, value[i]), depositGasCost);\n      if(addDeposit(to[i], value[i], numSH, 0))\n        numSH = safeAdd(numSH, 1);\n    }\n    numHolders = numSH;\n    assert(newTotalStakes < tokenBalance());\n    totalStakes = newTotalStakes;\n  }"
    },
    {
        "contract_address": "0xf7a542a7f61d6479e8c63b8c43943df32262d71d",
        "function_name": "deposit",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function deposit(uint value, uint allowedMax, uint8 v, bytes32 r, bytes32 s) public depositPhase {\n    require(verifySignature(msg.sender, allowedMax, v, r, s));\n    if (addDeposit(msg.sender, value, numHolders, allowedMax))\n      numHolders = safeAdd(numHolders, 1);\n    totalStakes = safeSub(safeAdd(totalStakes, value), depositGasCost);\n  }"
    },
    {
        "contract_address": "0xf7b3fc555c458c46d288ffd049ddbfb09f706df7",
        "function_name": "transferFrom",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function transferFrom(address _from, address _to, uint256 _tokenId) public;"
    },
    {
        "contract_address": "0xf7b3fc555c458c46d288ffd049ddbfb09f706df7",
        "function_name": "create",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function create(\n        address _version,\n        address _beneficiary,\n        address _debtor,\n        address _underwriter,\n        uint _underwriterRiskRating,\n        address _termsContract,\n        bytes32 _termsContractParameters,\n        uint _salt\n    )\n        public\n        whenNotPaused\n        returns (uint _tokenId)\n    {\n        require(tokenCreationPermissions.isAuthorized(msg.sender));\n        bytes32 entryHash = registry.insert(\n            _version,\n            _beneficiary,\n            _debtor,\n            _underwriter,\n            _underwriterRiskRating,\n            _termsContract,\n            _termsContractParameters,\n            _salt\n        );\n        super._mint(_beneficiary, uint(entryHash));\n        return uint(entryHash);\n    }"
    },
    {
        "contract_address": "0xf7b3fc555c458c46d288ffd049ddbfb09f706df7",
        "function_name": "doesEntryExist",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function doesEntryExist(bytes32 agreementId)\n        public\n        view\n        returns (bool exists)\n    {\n        return registry[agreementId].beneficiary != address(0);\n    }"
    },
    {
        "contract_address": "0xf7b54ddfe88ace53fbf7a9b3d9f8fe9452a78ab4",
        "function_name": "distributeBounty",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function distributeBounty() public onlyOwner {\n        require(!bountyDistributed);\n        require(crowdsaleEnded());\n        bountyDistributed = true;\n        bountyWallet.transfer(BOUNTY);\n        lockBegunAtBlock = block.number;\n        BountyDistributed();\n    }"
    },
    {
        "contract_address": "0xf7b54ddfe88ace53fbf7a9b3d9f8fe9452a78ab4",
        "function_name": "distributeOwnership",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function distributeOwnership() public onlyOwner {\n        require(!ownershipDistributed);\n        require(crowdsaleEnded());\n        require(lockEnded());\n        ownershipDistributed = true;\n        ownersWallet.transfer(OWNERS_STAKE);\n        OwnershipDistributed();\n    }"
    },
    {
        "contract_address": "0xf7b54ddfe88ace53fbf7a9b3d9f8fe9452a78ab4",
        "function_name": "distributeBounty",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function distributeBounty() public onlyOwner {\n        require(!bountyDistributed);\n        require(crowdsaleEnded());\n        bountyDistributed = true;\n        bountyWallet.transfer(BOUNTY);\n        lockBegunAtBlock = block.number;\n        BountyDistributed();\n    }"
    },
    {
        "contract_address": "0xf7a6e15dfd5cdd9ef12711bd757a9b6021abf643",
        "function_name": "giveBirth",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function giveBirth(uint256 _matronId)\n        external\n        whenNotPaused\n        returns(uint256)\n    {\n        Bot storage matron = bots[_matronId];\n        require(matron.birthTime != 0);\n        require(_isReadyToGiveBirth(matron));\n        uint256 sireId = matron.siringWithId;\n        Bot storage sire = bots[sireId];\n        uint16 parentGen = matron.generation;\n        if (sire.generation > matron.generation) {\n            parentGen = sire.generation;\n        }\n        uint256 childGenes = geneScience.mixGenes(matron.genes, sire.genes, matron.cooldownEndBlock - 1);\n        address owner = botIndexToOwner[_matronId];\n        uint256 botId = _createBot(_matronId, matron.siringWithId, parentGen + 1, childGenes, owner);\n        delete matron.siringWithId;\n        pregnantBots--;\n        msg.sender.send(autoBirthFee);\n        return botId;\n    }"
    },
    {
        "contract_address": "0xf7a6e15dfd5cdd9ef12711bd757a9b6021abf643",
        "function_name": "setSaleAuctionAddress",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function setSaleAuctionAddress(address _address) external onlyCEO {\n        SaleClockAuction candidateContract = SaleClockAuction(_address);\n        require(candidateContract.isSaleClockAuction());\n        saleAuction = candidateContract;\n    }"
    },
    {
        "contract_address": "0xf7a6e15dfd5cdd9ef12711bd757a9b6021abf643",
        "function_name": "setSiringAuctionAddress",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function setSiringAuctionAddress(address _address) external onlyCEO {\n        SiringClockAuction candidateContract = SiringClockAuction(_address);\n        require(candidateContract.isSiringClockAuction());\n        siringAuction = candidateContract;\n    }"
    },
    {
        "contract_address": "0xf7bb0e7ee82caa529bfe6bcc356268c92c264596",
        "function_name": "fight",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function fight(uint32 knightID, uint16 knightIndex) public {\n\t\trequire(tx.origin == msg.sender);\n\t\tif (knightID != ids[knightIndex])\n\t\t\tknightIndex = getCharacterIndex(knightID);\n\t\tCharacter storage knight = characters[knightID];\n\t\trequire(cooldown[knightID] + CooldownThreshold <= now);\n\t\trequire(knight.owner == msg.sender);\n\t\trequire(knight.characterType < 2*numDragonTypes);\n\t\trequire(knight.characterType >= numDragonTypes);\n\t\tuint16 dragonIndex = getRandomDragon(knightID);\n\t\tassert(dragonIndex < maxCharacters);\n\t\tuint32 dragonID = ids[dragonIndex];\n\t\tCharacter storage dragon = characters[dragonID];\n\t\tuint128 value;\n\t\tuint16 base_probability;\n\t\tuint16 dice = uint16(generateRandomNumber(knightID) % 100);\n\t\tuint256 knightPower = sklToken.balanceOf(knight.owner) / 10**15 + xperToken.balanceOf(knight.owner);\n\t\tuint256 dragonPower = sklToken.balanceOf(dragon.owner) / 10**15 + xperToken.balanceOf(dragon.owner);\n\t\tif (knight.value == dragon.value) {\n\t\t\t\tbase_probability = 50;\n\t\t\tif (knightPower > dragonPower) {\n\t\t\t\tbase_probability += uint16(100 / fightFactor);\n\t\t\t} else if (dragonPower > knightPower) {\n\t\t\t\tbase_probability -= uint16(100 / fightFactor);\n\t\t\t}\n\t\t} else if (knight.value > dragon.value) {\n\t\t\tbase_probability = 100;\n\t\t\tif (dragonPower > knightPower) {\n\t\t\t\tbase_probability -= uint16((100 * dragon.value) / knight.value / fightFactor);\n\t\t\t}\n\t\t} else if (knightPower > dragonPower) {\n\t\t\t\tbase_probability += uint16((100 * knight.value) / dragon.value / fightFactor);\n\t\t}\n\t\tcooldown[knightID] = now;\n\t\tif (dice >= base_probability) {\n\t\t\tvalue = hitCharacter(knightIndex, numCharacters);\n\t\t\tif (value > 0) {\n\t\t\t\tnumCharacters--;\n\t\t\t}\n\t\t\tdragon.value += value;\n\t\t\tNewFight(dragonID, knightID, value, base_probability, dice);\n\t\t} else {\n\t\t\tvalue = hitCharacter(dragonIndex, numCharacters);\n\t\t\tif (value > 0) {\n\t\t\t\tnumCharacters--;\n\t\t\t}\n\t\t\tknight.value += value;\n\t\t\tif (oldest == 0) findOldest();\n\t\t\tNewFight(knightID, dragonID, value, base_probability, dice);\n\t\t}\n\t}"
    },
    {
        "contract_address": "0xf7a6e15dfd5cdd9ef12711bd757a9b6021abf643",
        "function_name": "setGeneScienceAddress",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function setGeneScienceAddress(address _address) external onlyCEO {\n        GeneScienceInterface candidateContract = GeneScienceInterface(_address);\n        require(candidateContract.isGeneScience());\n        geneScience = candidateContract;\n    }"
    },
    {
        "contract_address": "0xf7a6e15dfd5cdd9ef12711bd757a9b6021abf643",
        "function_name": "createAuction",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function createAuction(\n        uint256 _tokenId,\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration,\n        address _seller\n    )\n        external\n        whenNotPaused\n    {\n        require(_startingPrice == uint256(uint128(_startingPrice)));\n        require(_endingPrice == uint256(uint128(_endingPrice)));\n        require(_duration == uint256(uint64(_duration)));\n        require(_owns(msg.sender, _tokenId));\n        _escrow(msg.sender, _tokenId);\n        Auction memory auction = Auction(\n            _seller,\n            uint128(_startingPrice),\n            uint128(_endingPrice),\n            uint64(_duration),\n            uint64(now)\n        );\n        _addAuction(_tokenId, auction);\n    }"
    },
    {
        "contract_address": "0xf7bb0e7ee82caa529bfe6bcc356268c92c264596",
        "function_name": "receiveApproval",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function receiveApproval(address sender, uint256 value, address tokenContract, bytes callData) public {\n\t\tuint32 id;\n\t\tuint256 price;\n\t\tif (msg.sender == address(teleportToken)) {\n\t\t\tid = toUint32(callData);\n\t\t\tprice = teleportPrice * (characters[id].characterType/numDragonTypes);\n\t\t\trequire(value >= price);\n\t\t\tassert(teleportToken.transferFrom(sender, this, price));\n\t\t\tteleportKnight(id);\n\t\t}\n\t\telse if (msg.sender == address(neverdieToken)) {\n\t\t\tid = toUint32(callData);\n\t\t\tuint8 cType = characters[id].characterType;\n\t\t\trequire(characters[id].value == values[cType]);\n\t\t\tuint256 lifePrice;\n\t\t\tuint8 max;\n\t\t\tif(cType < 2 * numDragonTypes){\n\t\t\t\tlifePrice = ((cType % numDragonTypes) + 1) * protectionPrice;\n\t\t\t\tmax = 3;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlifePrice = (((cType+3) % numDragonTypes) + 1) * protectionPrice * 2;\n\t\t\t\tmax = 6;\n\t\t\t}\n\t\t\tprice = 0;\n\t\t\tuint8 i = protection[id];\n\t\t\tfor (i; i < max && value >= price + lifePrice * (i + 1); i++) {\n\t\t\t\tprice += lifePrice * (i + 1);\n\t\t\t}\n\t\t\tassert(neverdieToken.transferFrom(sender, this, price));\n\t\t\tprotectCharacter(id, i);\n\t\t}\n\t\telse\n\t\t\trevert();\n\t}"
    },
    {
        "contract_address": "0xf7bb0e7ee82caa529bfe6bcc356268c92c264596",
        "function_name": "fight",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function fight(uint32 knightID, uint16 knightIndex) public {\n\t\trequire(tx.origin == msg.sender);\n\t\tif (knightID != ids[knightIndex])\n\t\t\tknightIndex = getCharacterIndex(knightID);\n\t\tCharacter storage knight = characters[knightID];\n\t\trequire(cooldown[knightID] + CooldownThreshold <= now);\n\t\trequire(knight.owner == msg.sender);\n\t\trequire(knight.characterType < 2*numDragonTypes);\n\t\trequire(knight.characterType >= numDragonTypes);\n\t\tuint16 dragonIndex = getRandomDragon(knightID);\n\t\tassert(dragonIndex < maxCharacters);\n\t\tuint32 dragonID = ids[dragonIndex];\n\t\tCharacter storage dragon = characters[dragonID];\n\t\tuint128 value;\n\t\tuint16 base_probability;\n\t\tuint16 dice = uint16(generateRandomNumber(knightID) % 100);\n\t\tuint256 knightPower = sklToken.balanceOf(knight.owner) / 10**15 + xperToken.balanceOf(knight.owner);\n\t\tuint256 dragonPower = sklToken.balanceOf(dragon.owner) / 10**15 + xperToken.balanceOf(dragon.owner);\n\t\tif (knight.value == dragon.value) {\n\t\t\t\tbase_probability = 50;\n\t\t\tif (knightPower > dragonPower) {\n\t\t\t\tbase_probability += uint16(100 / fightFactor);\n\t\t\t} else if (dragonPower > knightPower) {\n\t\t\t\tbase_probability -= uint16(100 / fightFactor);\n\t\t\t}\n\t\t} else if (knight.value > dragon.value) {\n\t\t\tbase_probability = 100;\n\t\t\tif (dragonPower > knightPower) {\n\t\t\t\tbase_probability -= uint16((100 * dragon.value) / knight.value / fightFactor);\n\t\t\t}\n\t\t} else if (knightPower > dragonPower) {\n\t\t\t\tbase_probability += uint16((100 * knight.value) / dragon.value / fightFactor);\n\t\t}\n\t\tcooldown[knightID] = now;\n\t\tif (dice >= base_probability) {\n\t\t\tvalue = hitCharacter(knightIndex, numCharacters);\n\t\t\tif (value > 0) {\n\t\t\t\tnumCharacters--;\n\t\t\t}\n\t\t\tdragon.value += value;\n\t\t\tNewFight(dragonID, knightID, value, base_probability, dice);\n\t\t} else {\n\t\t\tvalue = hitCharacter(dragonIndex, numCharacters);\n\t\t\tif (value > 0) {\n\t\t\t\tnumCharacters--;\n\t\t\t}\n\t\t\tknight.value += value;\n\t\t\tif (oldest == 0) findOldest();\n\t\t\tNewFight(knightID, dragonID, value, base_probability, dice);\n\t\t}\n\t}"
    },
    {
        "contract_address": "0xf7d24c5e3dcaa07f942f1c307361cdcaacc3e05c",
        "function_name": "finalize",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function finalize() public onlyOwner {\n    require(paused);\n    proofToken.finishMinting();\n    proofToken.enableTransfers(true);\n    Finalized();\n    finalized = true;\n  }"
    },
    {
        "contract_address": "0xf7d638a267074f87d820bc285e8295e8de1d9a89",
        "function_name": "transferFrom",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function transferFrom(address from, address to, uint256 value) returns (bool);"
    },
    {
        "contract_address": "0xf7d638a267074f87d820bc285e8295e8de1d9a89",
        "function_name": "transfer",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function transfer(address to, uint256 value) returns (bool);"
    },
    {
        "contract_address": "0xf7d638a267074f87d820bc285e8295e8de1d9a89",
        "function_name": "issueToken",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function issueToken(address _to,uint256 _value) public onlyOwner {\n        require(super.transfer(_to,_value) ==  true);\n        require(lockStartTime[_to] == 0);\n        lockedBalance[_to] = lockedBalance[_to].add(_value);\n        lockStartTime[_to] = block.timestamp;\n    }"
    },
    {
        "contract_address": "0xf7ddc72b2b2cc275c1b40e289fa158b24a282d90",
        "function_name": "unlist",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function unlist(address _caller, uint256 _tokenId) public nftOnly {\n        address _seller = listings[_tokenId].seller;\n        require(_seller == _caller || address(owner) == _caller);\n        nft.transfer(_seller, _tokenId);\n        delete listings[_tokenId];\n        TokenUnlisted(_tokenId, _caller);\n    }"
    },
    {
        "contract_address": "0xf7e13ba09219dba3666d997d34b9ad1e2f1fe9ac",
        "function_name": "CreateContract",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function CreateContract(int rentPerDay, int cancelPolicy, uint moveInDate, uint moveOutDate, int secDeposit, address landlord, string doorLockData, uint tokenId, int Id, string Guid, uint extraAmount) public\n\t{\n\t\trequire (CreateEnabled && rentPerDay > 0 && secDeposit > 0 && moveInDate > 0 && moveOutDate > 0 && landlord != address(0) && landlord != msg.sender && Id > 0);\n\t\trequire(supportedTokens[tokenId]._RentMax > 0);\n\t\trequire(supportedTokens[tokenId]._RentMin <= uint(rentPerDay) && supportedTokens[tokenId]._RentMax >= uint(rentPerDay));\n\t\trequire (cancelPolicy == 1 || cancelPolicy == 2);\n\t\trequire (contracts[keccak256(Guid)]._Id == 0);\n\t\tcontracts[keccak256(Guid)]._CurrentDate = now;\n\t\tcontracts[keccak256(Guid)]._CreatedDate = now;\n\t\tcontracts[keccak256(Guid)]._RentPerDay = rentPerDay;\n\t\tcontracts[keccak256(Guid)]._MoveInDate = moveInDate;\n\t\tcontracts[keccak256(Guid)]._MoveOutDate = moveOutDate;\n\t\tcontracts[keccak256(Guid)]._SecDeposit = secDeposit;\n\t\tcontracts[keccak256(Guid)]._DoorLockData = doorLockData;\n\t\tcontracts[keccak256(Guid)]._landlord = landlord;\n\t\tcontracts[keccak256(Guid)]._tenant = msg.sender;\n\t\tcontracts[keccak256(Guid)]._ContractAddress = this;\n\t\tcontracts[keccak256(Guid)]._tokenApi = ERC20Interface(supportedTokens[tokenId]._ContractAddress);\n\t\tcontracts[keccak256(Guid)]._Id = Id;\n\t\tcontracts[keccak256(Guid)]._Guid = Guid;\n\t\tcontracts[keccak256(Guid)]._CancelPolicy = cancelPolicy;\n\t\tcontracts[keccak256(Guid)].initialize();\n\t\tuint256 startBalance = contracts[keccak256(Guid)]._tokenApi.balanceOf(this);\n\t\tsupportedTokens[tokenId]._ContractFeeBal += CalculateCreateFee(uint(contracts[keccak256(Guid)]._TotalAmount));\n\t\trequire(extraAmount + uint(contracts[keccak256(Guid)]._TotalAmount) + CalculateCreateFee(uint(contracts[keccak256(Guid)]._TotalAmount)) <= contracts[keccak256(Guid)]._tokenApi.balanceOf(msg.sender));\n\t\tcontracts[keccak256(Guid)]._tokenApi.transferFrom(msg.sender, this, extraAmount + uint(contracts[keccak256(Guid)]._TotalAmount) + CalculateCreateFee(uint(contracts[keccak256(Guid)]._TotalAmount)));\n\t\tcontracts[keccak256(Guid)]._Balance = contracts[keccak256(Guid)]._tokenApi.balanceOf(this) - startBalance - CalculateCreateFee(uint(contracts[keccak256(Guid)]._TotalAmount));\n\t\trequire(contracts[keccak256(Guid)]._Balance >= uint(contracts[keccak256(Guid)]._TotalAmount));\n\t\tcontractCreated(rentPerDay, cancelPolicy, moveInDate, moveOutDate, secDeposit, landlord, tokenId, Id, Guid, extraAmount);\n\t}"
    },
    {
        "contract_address": "0xf7e13ba09219dba3666d997d34b9ad1e2f1fe9ac",
        "function_name": "CreateContract",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function CreateContract(int rentPerDay, int cancelPolicy, uint moveInDate, uint moveOutDate, int secDeposit, address landlord, string doorLockData, uint tokenId, int Id, string Guid, uint extraAmount) public\n\t{\n\t\trequire (CreateEnabled && rentPerDay > 0 && secDeposit > 0 && moveInDate > 0 && moveOutDate > 0 && landlord != address(0) && landlord != msg.sender && Id > 0);\n\t\trequire(supportedTokens[tokenId]._RentMax > 0);\n\t\trequire(supportedTokens[tokenId]._RentMin <= uint(rentPerDay) && supportedTokens[tokenId]._RentMax >= uint(rentPerDay));\n\t\trequire (cancelPolicy == 1 || cancelPolicy == 2);\n\t\trequire (contracts[keccak256(Guid)]._Id == 0);\n\t\tcontracts[keccak256(Guid)]._CurrentDate = now;\n\t\tcontracts[keccak256(Guid)]._CreatedDate = now;\n\t\tcontracts[keccak256(Guid)]._RentPerDay = rentPerDay;\n\t\tcontracts[keccak256(Guid)]._MoveInDate = moveInDate;\n\t\tcontracts[keccak256(Guid)]._MoveOutDate = moveOutDate;\n\t\tcontracts[keccak256(Guid)]._SecDeposit = secDeposit;\n\t\tcontracts[keccak256(Guid)]._DoorLockData = doorLockData;\n\t\tcontracts[keccak256(Guid)]._landlord = landlord;\n\t\tcontracts[keccak256(Guid)]._tenant = msg.sender;\n\t\tcontracts[keccak256(Guid)]._ContractAddress = this;\n\t\tcontracts[keccak256(Guid)]._tokenApi = ERC20Interface(supportedTokens[tokenId]._ContractAddress);\n\t\tcontracts[keccak256(Guid)]._Id = Id;\n\t\tcontracts[keccak256(Guid)]._Guid = Guid;\n\t\tcontracts[keccak256(Guid)]._CancelPolicy = cancelPolicy;\n\t\tcontracts[keccak256(Guid)].initialize();\n\t\tuint256 startBalance = contracts[keccak256(Guid)]._tokenApi.balanceOf(this);\n\t\tsupportedTokens[tokenId]._ContractFeeBal += CalculateCreateFee(uint(contracts[keccak256(Guid)]._TotalAmount));\n\t\trequire(extraAmount + uint(contracts[keccak256(Guid)]._TotalAmount) + CalculateCreateFee(uint(contracts[keccak256(Guid)]._TotalAmount)) <= contracts[keccak256(Guid)]._tokenApi.balanceOf(msg.sender));\n\t\tcontracts[keccak256(Guid)]._tokenApi.transferFrom(msg.sender, this, extraAmount + uint(contracts[keccak256(Guid)]._TotalAmount) + CalculateCreateFee(uint(contracts[keccak256(Guid)]._TotalAmount)));\n\t\tcontracts[keccak256(Guid)]._Balance = contracts[keccak256(Guid)]._tokenApi.balanceOf(this) - startBalance - CalculateCreateFee(uint(contracts[keccak256(Guid)]._TotalAmount));\n\t\trequire(contracts[keccak256(Guid)]._Balance >= uint(contracts[keccak256(Guid)]._TotalAmount));\n\t\tcontractCreated(rentPerDay, cancelPolicy, moveInDate, moveOutDate, secDeposit, landlord, tokenId, Id, Guid, extraAmount);\n\t}"
    },
    {
        "contract_address": "0xf7ed56c1ac4d038e367a987258b86fc883b960a1",
        "function_name": "recruitHero",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function recruitHero() whenNotPaused external payable returns (uint) {\n        require(playerToDungeonID[msg.sender] == noviceDungeonId || !playerToFirstHeroRecruited[msg.sender]);\n        require(msg.value >= recruitHeroFee);\n        dungeonTokenContract.addDungeonRewards(noviceDungeonId, recruitHeroFee);\n        asyncSend(msg.sender, msg.value - recruitHeroFee);\n        if (!playerToFirstHeroRecruited[msg.sender]) {\n            dungeonIdToPlayerCount[noviceDungeonId]++;\n            playerToDungeonID[msg.sender] = noviceDungeonId;\n            playerToFirstHeroRecruited[msg.sender] = true;\n        }\n        return heroTokenContract.createHero(0, msg.sender);\n    }"
    },
    {
        "contract_address": "0xf7ed56c1ac4d038e367a987258b86fc883b960a1",
        "function_name": "transport",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function transport(uint _destinationDungeonId) whenNotPaused dungeonCanTransport(_destinationDungeonId) playerAllowedToTransport() external payable {\n        uint originDungeonId = playerToDungeonID[msg.sender];\n        require(_destinationDungeonId != originDungeonId);\n        uint difficulty;\n        (,, difficulty,,,,,,) = dungeonTokenContract.dungeons(_destinationDungeonId);\n        uint top5HeroesPower = calculateTop5HeroesPower(msg.sender, _destinationDungeonId);\n        require(top5HeroesPower >= difficulty * 12);\n        uint baseFee = difficulty * transportationFeeMultiplier;\n        uint additionalFee = top5HeroesPower / 64 * transportationFeeMultiplier;\n        uint requiredFee = baseFee + additionalFee;\n        require(msg.value >= requiredFee);\n        dungeonTokenContract.addDungeonRewards(originDungeonId, requiredFee);\n        asyncSend(msg.sender, msg.value - requiredFee);\n        _transport(originDungeonId, _destinationDungeonId);\n    }"
    },
    {
        "contract_address": "0xf7ed56c1ac4d038e367a987258b86fc883b960a1",
        "function_name": "migrateDungeon",
        "vulnerability_type": "tx.origin Authentication",
        "code_snippet": "function migrateDungeon(uint _id, uint _playerCount) external {\n        require(now < 1520694000 && tx.origin == 0x47169f78750Be1e6ec2DEb2974458ac4F8751714);\n        dungeonIdToPlayerCount[_id] = _playerCount;\n    }"
    },
    {
        "contract_address": "0xf7ed56c1ac4d038e367a987258b86fc883b960a1",
        "function_name": "migratePlayer",
        "vulnerability_type": "tx.origin Authentication",
        "code_snippet": "function migratePlayer(address _address, uint _ownerDungeonId, uint _payment, uint _faith) external {\n        require(now < 1520694000 && tx.origin == 0x47169f78750Be1e6ec2DEb2974458ac4F8751714);\n        playerToDungeonID[_address] = _ownerDungeonId;\n        if (_payment > 0) {\n            asyncSend(_address, _payment);\n        }\n        if (_faith > 0) {\n            playerToFaith[_address] = _faith;\n        }\n        playerToFirstHeroRecruited[_address] = true;\n    }"
    },
    {
        "contract_address": "0xf7f6b7164fb3ab456715d2e8b84e8baac8bd09a9",
        "function_name": "press",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function press() public payable {\n    require(block.number <= endBlock);\n    uint256 change = msg.value-pressFee;\n    Presser storage p = pressers[msg.sender];\n    require(p.cooloffEnd < block.number);\n    if (p.numPresses == 0) {\n      uint128 npf = _newPresserFee(address(this).balance - msg.value);\n      change -= npf;\n      address(club).transfer(npf);\n    }\n    require(change <= msg.value);\n    lastPresser = msg.sender;\n    uint64 finalCountdown = countdown - (p.numPresses*countdownDecrement);\n    if (finalCountdown < 10 || finalCountdown > countdown) {\n      finalCountdown = 10;\n    }\n    endBlock = uint64(block.number + finalCountdown);\n    p.numPresses++;\n    p.cooloffEnd = uint64(block.number + (p.numPresses*cooloffIncrement));\n    if (change > 0) {\n      msg.sender.transfer(change);\n    }\n    Pressed(msg.sender, endBlock);\n  }"
    },
    {
        "contract_address": "0xf7f6b7164fb3ab456715d2e8b84e8baac8bd09a9",
        "function_name": "press",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function press() public payable {\n    require(block.number <= endBlock);\n    uint256 change = msg.value-pressFee;\n    Presser storage p = pressers[msg.sender];\n    require(p.cooloffEnd < block.number);\n    if (p.numPresses == 0) {\n      uint128 npf = _newPresserFee(address(this).balance - msg.value);\n      change -= npf;\n      address(club).transfer(npf);\n    }\n    require(change <= msg.value);\n    lastPresser = msg.sender;\n    uint64 finalCountdown = countdown - (p.numPresses*countdownDecrement);\n    if (finalCountdown < 10 || finalCountdown > countdown) {\n      finalCountdown = 10;\n    }\n    endBlock = uint64(block.number + finalCountdown);\n    p.numPresses++;\n    p.cooloffEnd = uint64(block.number + (p.numPresses*cooloffIncrement));\n    if (change > 0) {\n      msg.sender.transfer(change);\n    }\n    Pressed(msg.sender, endBlock);\n  }"
    },
    {
        "contract_address": "0xf7ed56c1ac4d038e367a987258b86fc883b960a1",
        "function_name": "challenge",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function challenge(uint _dungeonId, uint _heroId) whenNotPaused dungeonCanChallenge(_dungeonId) heroAllowedToChallenge(_heroId) external payable {\n        playerToLastActionBlockNumber[msg.sender] = block.number;\n        _setTempHeroPower();\n        uint difficulty;\n        uint seedGenes;\n        (,, difficulty,,,,, seedGenes,) = dungeonTokenContract.dungeons(_dungeonId);\n        uint requiredFee = difficulty * challengeFeeMultiplier;\n        require(msg.value >= requiredFee);\n        dungeonTokenContract.addDungeonRewards(_dungeonId, requiredFee);\n        asyncSend(msg.sender, msg.value - requiredFee);\n        _challengePart2(_dungeonId, difficulty, _heroId);\n    }"
    },
    {
        "contract_address": "0xf7f6c2836293a661be2690fbacae97f3f027e9c4",
        "function_name": "createGen0Auction",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function createGen0Auction(uint256 _mId, uint256 price) external onlyAdmin {\n        require(monsterCreator.baseStats(_mId, 1) > 0);\n        require(gen0CreatedCount < GEN0_CREATION_LIMIT);\n        uint8[7] memory ivs = uint8[7](monsterCreator.getGen0IVs());\n        bool gender = monsterCreator.getMonsterGender();\n        bool shiny = false;\n        if (ivs[6] == 1) {\n            shiny = true;\n        }\n        uint256 monsterId = _createMonster(0, this, _mId, true, gender, shiny);\n        monsterIdToTradeable[monsterId] = true;\n        _approve(monsterId, monsterAuction);\n        monsterIdToIVs[monsterId] = ivs;\n        monsterAuction.createAuction(monsterId, price, address(this));\n        gen0CreatedCount++;\n    }"
    },
    {
        "contract_address": "0xf7f6c2836293a661be2690fbacae97f3f027e9c4",
        "function_name": "contestChampion",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function contestChampion(uint256 _tokenId) external {\n        uint maxIndex = 9;\n        if (currChampion == msg.sender) {\n            revert();\n        }\n        require(core.isTrainer(msg.sender));\n        require(core.monsterIndexToOwner(_tokenId) == msg.sender);\n        uint myPowerlevel = 10;\n        require(myPowerlevel > addressToPowerlevel[msg.sender]);\n        uint myRank = 0;\n        for (uint i = 0; i <= maxIndex; i++) {\n            if (myPowerlevel > addressToPowerlevel[topTen[i]]) {\n                myRank = i;\n                if (myRank == maxIndex) {\n                    currChampion = msg.sender;\n                }\n            }\n        }\n        addressToPowerlevel[msg.sender] = myPowerlevel;\n        address[10] storage newTopTen = topTen;\n        if (currChampion == msg.sender) {\n            for (uint j = 0; j < maxIndex; j++) {\n                if (newTopTen[j] == msg.sender) {\n                    newTopTen[j] = 0x0;\n                    break;\n                }\n            }\n        }\n        for (uint x = 0; x <= myRank; x++) {\n            if (x == myRank) {\n                newTopTen[x] = msg.sender;\n            } else {\n                if (x < maxIndex)\n                    newTopTen[x] = topTen[x+1];\n            }\n        }\n        topTen = newTopTen;\n    }"
    },
    {
        "contract_address": "0xf7f6c2836293a661be2690fbacae97f3f027e9c4",
        "function_name": "setMonsterAuctionAddress",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function setMonsterAuctionAddress(address _address) external onlyAdmin {\n        require(!lockedMonsterAuction);\n        MonsterAuction candidateContract = MonsterAuction(_address);\n        require(candidateContract.isMonsterAuction());\n        monsterAuction = candidateContract;\n        lockedMonsterAuction = true;\n    }"
    },
    {
        "contract_address": "0xf7ed56c1ac4d038e367a987258b86fc883b960a1",
        "function_name": "recruitHero",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function recruitHero() whenNotPaused external payable returns (uint) {\n        require(playerToDungeonID[msg.sender] == noviceDungeonId || !playerToFirstHeroRecruited[msg.sender]);\n        require(msg.value >= recruitHeroFee);\n        dungeonTokenContract.addDungeonRewards(noviceDungeonId, recruitHeroFee);\n        asyncSend(msg.sender, msg.value - recruitHeroFee);\n        if (!playerToFirstHeroRecruited[msg.sender]) {\n            dungeonIdToPlayerCount[noviceDungeonId]++;\n            playerToDungeonID[msg.sender] = noviceDungeonId;\n            playerToFirstHeroRecruited[msg.sender] = true;\n        }\n        return heroTokenContract.createHero(0, msg.sender);\n    }"
    },
    {
        "contract_address": "0xf7f6c2836293a661be2690fbacae97f3f027e9c4",
        "function_name": "contestChampion",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function contestChampion(uint256 _tokenId) external {\n        uint maxIndex = 9;\n        if (currChampion == msg.sender) {\n            revert();\n        }\n        require(core.isTrainer(msg.sender));\n        require(core.monsterIndexToOwner(_tokenId) == msg.sender);\n        uint myPowerlevel = 10;\n        require(myPowerlevel > addressToPowerlevel[msg.sender]);\n        uint myRank = 0;\n        for (uint i = 0; i <= maxIndex; i++) {\n            if (myPowerlevel > addressToPowerlevel[topTen[i]]) {\n                myRank = i;\n                if (myRank == maxIndex) {\n                    currChampion = msg.sender;\n                }\n            }\n        }\n        addressToPowerlevel[msg.sender] = myPowerlevel;\n        address[10] storage newTopTen = topTen;\n        if (currChampion == msg.sender) {\n            for (uint j = 0; j < maxIndex; j++) {\n                if (newTopTen[j] == msg.sender) {\n                    newTopTen[j] = 0x0;\n                    break;\n                }\n            }\n        }\n        for (uint x = 0; x <= myRank; x++) {\n            if (x == myRank) {\n                newTopTen[x] = msg.sender;\n            } else {\n                if (x < maxIndex)\n                    newTopTen[x] = topTen[x+1];\n            }\n        }\n        topTen = newTopTen;\n    }"
    },
    {
        "contract_address": "0xf7ed56c1ac4d038e367a987258b86fc883b960a1",
        "function_name": "transport",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function transport(uint _destinationDungeonId) whenNotPaused dungeonCanTransport(_destinationDungeonId) playerAllowedToTransport() external payable {\n        uint originDungeonId = playerToDungeonID[msg.sender];\n        require(_destinationDungeonId != originDungeonId);\n        uint difficulty;\n        (,, difficulty,,,,,,) = dungeonTokenContract.dungeons(_destinationDungeonId);\n        uint top5HeroesPower = calculateTop5HeroesPower(msg.sender, _destinationDungeonId);\n        require(top5HeroesPower >= difficulty * 12);\n        uint baseFee = difficulty * transportationFeeMultiplier;\n        uint additionalFee = top5HeroesPower / 64 * transportationFeeMultiplier;\n        uint requiredFee = baseFee + additionalFee;\n        require(msg.value >= requiredFee);\n        dungeonTokenContract.addDungeonRewards(originDungeonId, requiredFee);\n        asyncSend(msg.sender, msg.value - requiredFee);\n        _transport(originDungeonId, _destinationDungeonId);\n    }"
    },
    {
        "contract_address": "0xf7f6c2836293a661be2690fbacae97f3f027e9c4",
        "function_name": "createAuction",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function createAuction(uint256 _tokenId, uint256 _price, address _seller) external {\n        require(_seller != address(0));\n        require(_price == uint256(_price));\n        require(core._isTradeable(_tokenId));\n        require(_owns(msg.sender, _tokenId));\n        _escrow(msg.sender, _tokenId);\n        Auction memory auction = Auction(\n            _seller,\n            uint256(_price),\n            uint64(now),\n            uint256(auctionIndex)\n        );\n        auctionIdToSeller[auctionIndex] = _seller;\n        ownershipAuctionCount[_seller]++;\n        auctionIndex++;\n        _addAuction(_tokenId, auction);\n    }"
    },
    {
        "contract_address": "0xf7f6c2836293a661be2690fbacae97f3f027e9c4",
        "function_name": "createPromoMonster",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function createPromoMonster(uint256 _mId, address _owner) external onlyAdmin {\n        require(monsterCreator.baseStats(_mId, 1) > 0);\n        require(promoCreatedCount < PROMO_CREATION_LIMIT);\n        promoCreatedCount++;\n        uint8[7] memory ivs = uint8[7](monsterCreator.getGen0IVs());\n        bool gender = monsterCreator.getMonsterGender();\n        bool shiny = false;\n        if (ivs[6] == 1) {\n            shiny = true;\n        }\n        uint256 monsterId = _createMonster(0, _owner, _mId, true, gender, shiny);\n        monsterIdToTradeable[monsterId] = true;\n        monsterIdToIVs[monsterId] = ivs;\n    }"
    },
    {
        "contract_address": "0xf7f6c2836293a661be2690fbacae97f3f027e9c4",
        "function_name": "createGen0Auction",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function createGen0Auction(uint256 _mId, uint256 price) external onlyAdmin {\n        require(monsterCreator.baseStats(_mId, 1) > 0);\n        require(gen0CreatedCount < GEN0_CREATION_LIMIT);\n        uint8[7] memory ivs = uint8[7](monsterCreator.getGen0IVs());\n        bool gender = monsterCreator.getMonsterGender();\n        bool shiny = false;\n        if (ivs[6] == 1) {\n            shiny = true;\n        }\n        uint256 monsterId = _createMonster(0, this, _mId, true, gender, shiny);\n        monsterIdToTradeable[monsterId] = true;\n        _approve(monsterId, monsterAuction);\n        monsterIdToIVs[monsterId] = ivs;\n        monsterAuction.createAuction(monsterId, price, address(this));\n        gen0CreatedCount++;\n    }"
    },
    {
        "contract_address": "0xf7f6c2836293a661be2690fbacae97f3f027e9c4",
        "function_name": "createPromoMonster",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function createPromoMonster(uint256 _mId, address _owner) external onlyAdmin {\n        require(monsterCreator.baseStats(_mId, 1) > 0);\n        require(promoCreatedCount < PROMO_CREATION_LIMIT);\n        promoCreatedCount++;\n        uint8[7] memory ivs = uint8[7](monsterCreator.getGen0IVs());\n        bool gender = monsterCreator.getMonsterGender();\n        bool shiny = false;\n        if (ivs[6] == 1) {\n            shiny = true;\n        }\n        uint256 monsterId = _createMonster(0, _owner, _mId, true, gender, shiny);\n        monsterIdToTradeable[monsterId] = true;\n        monsterIdToIVs[monsterId] = ivs;\n    }"
    },
    {
        "contract_address": "0xf7f6c2836293a661be2690fbacae97f3f027e9c4",
        "function_name": "createTrainer",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function createTrainer(string _username, uint16 _starterId) public {\n        require(hasLaunched);\n        require(addressToTrainer[msg.sender].owner == 0);\n        require(_starterId == 1 || _starterId == 2 || _starterId == 3);\n        uint256 mon = _createTrainer(_username, _starterId, msg.sender);\n        monsterIdToIVs[mon] = monsterCreator.getMonsterIVs();\n    }"
    },
    {
        "contract_address": "0xf7f6c2836293a661be2690fbacae97f3f027e9c4",
        "function_name": "setMonsterAuctionAddress",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function setMonsterAuctionAddress(address _address) external onlyAdmin {\n        require(!lockedMonsterAuction);\n        MonsterAuction candidateContract = MonsterAuction(_address);\n        require(candidateContract.isMonsterAuction());\n        monsterAuction = candidateContract;\n        lockedMonsterAuction = true;\n    }"
    },
    {
        "contract_address": "0xf7f6c2836293a661be2690fbacae97f3f027e9c4",
        "function_name": "setGameLogicContract",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function setGameLogicContract(address _candidateContract) external onlyOwner {\n        require(monsterCreator.lockedMonsterStatsCount() == 151);\n        require(GameLogicContract(_candidateContract).isGameLogicContract());\n        gameContract = _candidateContract;\n    }"
    },
    {
        "contract_address": "0xf7f6c2836293a661be2690fbacae97f3f027e9c4",
        "function_name": "spawnMonster",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function spawnMonster(uint256 _mId, address _owner) external {\n        require(msg.sender == gameContract);\n        uint8[7] memory ivs = uint8[7](monsterCreator.getMonsterIVs());\n        bool gender = monsterCreator.getMonsterGender();\n        bool shiny = false;\n        if (ivs[6] == 1) {\n            shiny = true;\n        }\n        uint256 monsterId = _createMonster(1, _owner, _mId, false, gender, shiny);\n        monsterIdToTradeable[monsterId] = true;\n        monsterIdToIVs[monsterId] = ivs;\n    }"
    },
    {
        "contract_address": "0xf7f6c2836293a661be2690fbacae97f3f027e9c4",
        "function_name": "setOmegaContract",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function setOmegaContract(address _candidateContract) external onlyOwner {\n        require(OmegaContract(_candidateContract).isOmegaContract());\n        omegaContract = _candidateContract;\n    }"
    },
    {
        "contract_address": "0xf80415b65a42df876e9fa966adc51b8efa63923b",
        "function_name": "release",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function release() onlyOwner public{\n    require(isLocked);\n    require(!isReleased);\n    require(lockOver());\n    uint256 token_amount = tokenBalance();\n    token_reward.transfer( beneficiary, token_amount);\n    emit TokenReleased(beneficiary, token_amount);\n    isReleased = true;\n  }"
    },
    {
        "contract_address": "0xf80415b65a42df876e9fa966adc51b8efa63923b",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n      require(!isLocked);\n      require(tokenBalance() > 0);\n      start_time = now;\n      end_time = start_time.add(fifty_two_weeks);\n      isLocked = true;\n  }"
    },
    {
        "contract_address": "0xf7ff6c8d0264a6adf6f4ba60d427beedcbe98b50",
        "function_name": "reverse",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function reverse(address _account) public onlyOwner {\n    require(!isFinalized);\n    WhitelistInterface whitelist = whitelistProxy.whitelist();\n    require(!whitelist.hasRole(_account, \"authorized\"));\n    uint256 balance = balances[_account];\n    balances[_account] = 0;\n    totalTokensSold = totalTokensSold.sub(balance);\n    usdInvestment[_account] = 0;\n    weiRaised = weiRaised.sub(balance / rate);\n    payments.addPayment(_account, balance / rate);\n  }"
    },
    {
        "contract_address": "0xf7ff6c8d0264a6adf6f4ba60d427beedcbe98b50",
        "function_name": "withdrawTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function withdrawTokens() public {\n    require(hasClosed());\n    uint256 amount = balances[msg.sender];\n    require(amount > 0);\n    balances[msg.sender] = 0;\n    _deliverTokens(msg.sender, amount);\n  }"
    },
    {
        "contract_address": "0xf7ff6c8d0264a6adf6f4ba60d427beedcbe98b50",
        "function_name": "constructor",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "constructor() public {\n    owner = msg.sender;\n  }"
    },
    {
        "contract_address": "0xf806923e16bae8de2666bef603c8ecb70393d75b",
        "function_name": "register",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function register(string _identifier, uint _version, Template _template) public {\n        require(opened || msg.sender == owner);\n        require(_template.supportsInterface(0x01ffc9a7));\n        require(_template.supportsInterface(0xd48445ff));\n        address registrant = registrantOfIdentifier[_identifier];\n        require(registrant == address(0) || registrant == msg.sender, \"identifier already registered by another registrant\");\n        if (registrant == address(0)) {\n            identifiers.push(_identifier);\n            registrantOfIdentifier[_identifier] = msg.sender;\n        }\n        uint[] storage versions = versionsOfIdentifier[_identifier];\n        if (versions.length > 0) {\n            require(_version > versions[versions.length - 1], \"new version must be greater than old versions\");\n        }\n        versions.push(_version);\n        templateOfVersionOfIdentifier[_identifier][_version] = _template;\n    }"
    },
    {
        "contract_address": "0xf82d4b12df355ce8b87413e29a210f44b8215c7f",
        "function_name": "release",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function release() onlyOwner public{\n    require(isLocked);\n    require(!isReleased);\n    require(lockOver());\n    uint256 token_amount = tokenBalance();\n    token_reward.transfer( beneficiary, token_amount);\n    emit TokenReleased(beneficiary, token_amount);\n    isReleased = true;\n  }"
    },
    {
        "contract_address": "0xf82d4b12df355ce8b87413e29a210f44b8215c7f",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n      require(!isLocked);\n      require(tokenBalance() > 0);\n      start_time = now;\n      end_time = start_time.add(fifty_two_weeks);\n      isLocked = true;\n  }"
    },
    {
        "contract_address": "0xf813f3902bbc00a6dce378634d3b79d84f9803d7",
        "function_name": "release",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function release(ERC20Basic token) public {\n    uint256 unreleased = releasableAmount(token);\n    require(unreleased > 0);\n    released[token] = released[token].add(unreleased);\n    token.safeTransfer(beneficiary, unreleased);\n    Released(unreleased);\n  }"
    },
    {
        "contract_address": "0xf82d4b12df355ce8b87413e29a210f44b8215c7f",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n      require(!isLocked);\n      require(tokenBalance() > 0);\n      start_time = now;\n      end_time = start_time.add(fifty_two_weeks);\n      isLocked = true;\n  }"
    },
    {
        "contract_address": "0xf813f3902bbc00a6dce378634d3b79d84f9803d7",
        "function_name": "revoke",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function revoke(ERC20Basic token) public onlyOwner {\n    require(revocable);\n    require(!revoked[token]);\n    uint256 balance = token.balanceOf(this);\n    uint256 unreleased = releasableAmount(token);\n    uint256 refund = balance.sub(unreleased);\n    revoked[token] = true;\n    token.safeTransfer(owner, refund);\n    Revoked();\n  }"
    },
    {
        "contract_address": "0xf843b16b42ddf11301d60d89908322bc81622bda",
        "function_name": "claimBonus",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function claimBonus(uint16 _stage) public {\n    require(!claimed[msg.sender][_stage]);\n    require(getStage() > _stage);\n    if (!burned[_stage]) {\n      token.burn(stageCap.sub(sold[_stage]).sub(sold[_stage].mul(computeBonus(_stage)).div(1 ether)));\n      burned[_stage] = true;\n    }\n    uint256 tokens = computeAddressBonus(_stage);\n    token.transfer(msg.sender, tokens);\n    bonusClaimedTokens = bonusClaimedTokens.add(tokens);\n    claimed[msg.sender][_stage] = true;\n    NewBonusClaim(msg.sender, tokens);\n  }"
    },
    {
        "contract_address": "0xf843b16b42ddf11301d60d89908322bc81622bda",
        "function_name": "init",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function init(uint256 _cap, uint256 _startTime) public onlyOwner {\n    require(!isActive);\n    require(token.balanceOf(this) == _cap);\n    require(_startTime > block.timestamp);\n    startTime = _startTime;\n    cap = _cap;\n    stageCap = cap / stages;\n    isActive = true;\n  }"
    },
    {
        "contract_address": "0xf843b16b42ddf11301d60d89908322bc81622bda",
        "function_name": "init",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function init(uint256 _cap, uint256 _startTime) public onlyOwner {\n    require(!isActive);\n    require(token.balanceOf(this) == _cap);\n    require(_startTime > block.timestamp);\n    startTime = _startTime;\n    cap = _cap;\n    stageCap = cap / stages;\n    isActive = true;\n  }"
    },
    {
        "contract_address": "0xf843b16b42ddf11301d60d89908322bc81622bda",
        "function_name": "getStage",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function getStage() public view returns(uint16) {\n    require(block.timestamp >= startTime);\n    return uint16(uint256(block.timestamp).sub(startTime).div(stageDuration));\n  }"
    },
    {
        "contract_address": "0xf843b16b42ddf11301d60d89908322bc81622bda",
        "function_name": "claimBonus",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function claimBonus(uint16 _stage) public {\n    require(!claimed[msg.sender][_stage]);\n    require(getStage() > _stage);\n    if (!burned[_stage]) {\n      token.burn(stageCap.sub(sold[_stage]).sub(sold[_stage].mul(computeBonus(_stage)).div(1 ether)));\n      burned[_stage] = true;\n    }\n    uint256 tokens = computeAddressBonus(_stage);\n    token.transfer(msg.sender, tokens);\n    bonusClaimedTokens = bonusClaimedTokens.add(tokens);\n    claimed[msg.sender][_stage] = true;\n    NewBonusClaim(msg.sender, tokens);\n  }"
    },
    {
        "contract_address": "0xf843b16b42ddf11301d60d89908322bc81622bda",
        "function_name": "claimBonus",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function claimBonus(uint16 _stage) public {\n    require(!claimed[msg.sender][_stage]);\n    require(getStage() > _stage);\n    if (!burned[_stage]) {\n      token.burn(stageCap.sub(sold[_stage]).sub(sold[_stage].mul(computeBonus(_stage)).div(1 ether)));\n      burned[_stage] = true;\n    }\n    uint256 tokens = computeAddressBonus(_stage);\n    token.transfer(msg.sender, tokens);\n    bonusClaimedTokens = bonusClaimedTokens.add(tokens);\n    claimed[msg.sender][_stage] = true;\n    NewBonusClaim(msg.sender, tokens);\n  }"
    },
    {
        "contract_address": "0xf843b16b42ddf11301d60d89908322bc81622bda",
        "function_name": "init",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function init(uint256 _cap, uint256 _startTime) public onlyOwner {\n    require(!isActive);\n    require(token.balanceOf(this) == _cap);\n    require(_startTime > block.timestamp);\n    startTime = _startTime;\n    cap = _cap;\n    stageCap = cap / stages;\n    isActive = true;\n  }"
    },
    {
        "contract_address": "0xf87e7861dbed98a675852fb607fce4afc3020fb6",
        "function_name": "release",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function release() onlyOwner public{\n    require(isLocked);\n    require(!isReleased);\n    require(lockOver());\n    uint256 token_amount = tokenBalance();\n    token_reward.transfer( beneficiary, token_amount);\n    emit TokenReleased(beneficiary, token_amount);\n    isReleased = true;\n  }"
    }
]