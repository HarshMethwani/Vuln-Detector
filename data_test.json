[
    {
        "contract_address": "0x0778cc2e8bbad3d483e82371606d100cc8604522",
        "function_name": "exchangeToken",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function exchangeToken() {\n        coin.exchangeBounty(msg.sender, balances[msg.sender]);\n        totalSupply -= balances[msg.sender];\n        balances[msg.sender] = 0;\n    }"
    },
    {
        "contract_address": "0x55272df80297fbc078952d80ebe82b62e4b0dee2",
        "function_name": "canCollect",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function canCollect(uint256 promiseId)\n    constant\n    returns(bool)\n  {\n    return (promises[promiseId].state == PromiseState.confirmed || promises[promiseId].state == PromiseState.pending)\n      && block.timestamp >= promises[promiseId].lockedUntil;\n  }"
    },
    {
        "contract_address": "0x19cc7ddcbee48843e5e27d0ae5ef3b72c93ab21b",
        "function_name": "draftNewCard",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function draftNewCard() external payable whenNotPaused returns (uint256) {\n\t\trequire(msg.value == cardDrawPrice, \"fee must be equal to draw price\");\n\t\trequire(address(marketplace) != address(0), \"marketplace not set\");\n\t\thogsmashToken.setApprovalForAllByContract(msg.sender, marketplace, true);\n\t\ttotalDeveloperCut = totalDeveloperCut.add(cardDrawPrice);\n\t\treturn _createCard(msg.sender, 1);\n\t}"
    },
    {
        "contract_address": "0x8ca22cb28f565cdb12f95b227d06a937f80eb07f",
        "function_name": "proxyPayment",
        "vulnerability_type": "safe",
        "code_snippet": "function proxyPayment(address _owner) payable returns(bool);"
    },
    {
        "contract_address": "0x7897d06ace9e153d7026839d2efd714a773b4560",
        "function_name": "enableTransfer",
        "vulnerability_type": "safe",
        "code_snippet": "function enableTransfer(bool _enable) public onlyOwner returns (bool success){\n        transferEnabled=_enable;\n\t\treturn true;\n    }"
    },
    {
        "contract_address": "0x6ffd92d59b9da3b9608ac58b3a08729b556bfec8",
        "function_name": "approve",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function approve( address spender, uint value ) returns (bool ok);"
    },
    {
        "contract_address": "0x41c0542f41251d6d81526ed2dbc8f0008b13fe48",
        "function_name": "fallback",
        "vulnerability_type": "safe",
        "code_snippet": "function () public payable {\n        require(block.number >= 6661266);\n        if(msg.value > 0){\n            require(gasleft() >= 250000);\n            require(msg.value >= 0.01 ether && msg.value <= calcMaxDeposit());\n            require(depositNumber[msg.sender] == 0);\n            queue.push( Deposit(msg.sender, msg.value, 0) );\n            depositNumber[msg.sender] = queue.length;\n            totalInvested += msg.value;\n            if (amountForSupport < 10 ether) {\n                uint fee = msg.value / 5;\n                amountForSupport += fee;\n                support.transfer(fee);\n            }\n            pay();\n        }\n    }"
    },
    {
        "contract_address": "0x4a9c04bb8948237e8134b72a7e1192ab89469c80",
        "function_name": "fallback",
        "vulnerability_type": "safe",
        "code_snippet": "function()\n        payable\n        public\n    {\n        purchaseTokens(msg.value, 0x0);\n    }"
    },
    {
        "contract_address": "0x1f5b7179a643570effb4da05a0ca0760b36ceed3",
        "function_name": "changeFundings",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function changeFundings(bytes32 _proposalId, uint256[] _newMilestoneFundings, uint256 _finalReward)\n        external\n    {\n        require(sender_is(CONTRACT_DAO));\n        bytes32 _finalVersion = proposalsById[_proposalId].finalVersion;\n        require(_finalVersion != EMPTY_BYTES);\n        proposalsById[_proposalId].proposalVersions[_finalVersion].milestoneFundings = _newMilestoneFundings;\n        proposalsById[_proposalId].proposalVersions[_finalVersion].finalReward = _finalReward;\n    }"
    },
    {
        "contract_address": "0x7409a88f44ac96cfae981f444d377b025002906a",
        "function_name": "__callback",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function __callback(bytes32 myid, string result) public {\n        __callback(myid, result, new bytes(0));\n    }"
    },
    {
        "contract_address": "0x444b5b08a72ee164e5d574b4a24eb5c12c1d35fe",
        "function_name": "HodlTokens3",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function HodlTokens3(address ERC, uint256 amount, uint256 AvailableBalances, uint256 AvailableCashback, address ref) public {\n\t    ERC20Interface token \t= ERC20Interface(ERC);\n\t\tuint256 TokenPercent \t= Bigdata[ERC][1];\n\t\tuint256 TokenHodlTime \t= Bigdata[ERC][2];\n\t\tuint256 HodlTime\t\t= add(now, TokenHodlTime);\n\t\tuint256 AM = amount; \tuint256 AB = AvailableBalances;\t\tuint256 AC = AvailableCashback;\n\t\tamount \t= 0; AvailableBalances = 0; AvailableCashback = 0;\n\t\t_safes[idnumber] = Safe(idnumber, AM, HodlTime, msg.sender, ERC, token.symbol(), AB, AC, now, TokenPercent, 0, 0, 0, ref, false);\n\t\tStatistics[msg.sender][ERC][1]\t\t\t= add(Statistics[msg.sender][ERC][1], AM);\n\t\tStatistics[msg.sender][ERC][5]  \t\t= add(Statistics[msg.sender][ERC][5], AM);\n\t\tBigdata[ERC][6] \t\t\t\t\t\t= add(Bigdata[ERC][6], AM);\n        Bigdata[ERC][3]\t\t\t\t\t\t\t= add(Bigdata[ERC][3], AM);\n\t\tif(Bigdata[msg.sender][8] == 1 ) {\n        idaddress[msg.sender].push(idnumber); idnumber++; Bigdata[ERC][10]++;  }\n\t\telse {\n\t\tafflist[ref].push(msg.sender); idaddress[msg.sender].push(idnumber); idnumber++; Bigdata[ERC][9]++; Bigdata[ERC][10]++; TotalUser++;   }\n\t\tBigdata[msg.sender][8] \t\t\t\t\t= 1;\n        emit onHoldplatform(msg.sender, ERC, token.symbol(), AM, HodlTime);\n\t\tBigdata[msg.sender][19]\t\t= 333;\n\t}"
    },
    {
        "contract_address": "0x2f707010e498b60455b5e69205455f59c128b08b",
        "function_name": "revoke",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function revoke(ERC20Basic token) public onlyOwner {\n    require(revocable);\n    require(!revoked[token]);\n    uint256 balance = token.balanceOf(this);\n    uint256 unreleased = releasableAmount(token);\n    uint256 refund = balance.sub(unreleased);\n    revoked[token] = true;\n    token.safeTransfer(owner, refund);\n    Revoked();\n  }"
    },
    {
        "contract_address": "0xc7084c6d155967505b5c3250fbfea1a0493dbe37",
        "function_name": "receiveApproval",
        "vulnerability_type": "safe",
        "code_snippet": "function receiveApproval(address from, uint256 tokens, address token, bytes data) public;"
    },
    {
        "contract_address": "0xf4d9d8f5c75067d3bc050cbe5c7d69c85934b213",
        "function_name": "setDestination",
        "vulnerability_type": "safe",
        "code_snippet": "function setDestination(address _destination) public {\n        destination = _destination;\n    }"
    },
    {
        "contract_address": "0x00edca4652f6e117c0c1f04f2280a86ae08bdd0c",
        "function_name": "DiceRoll",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function DiceRoll() public {\n        owner = msg.sender;\n        houseEdge = 20;\n        maxProfitAsPercentOfHouse = 100;\n        minBet = 0.1 ether;\n        maxBet = 1 ether;\n        jackpotOfHouseEdge = 500;\n        minJackpotBet = 0.1 ether;\n        jackpotPersent = 100;\n        oraclizeGasLimit = 300000;\n        oraclizeFee = 1200000000000000;\n        oraclize_setCustomGasPrice(4000000000);\n        nextJackpotTime = uint64(block.timestamp);\n        oraclize_setProof(proofType_Ledger);\n    }"
    },
    {
        "contract_address": "0x2ff6a461d6c744dfb9bcfb3d89016f85d92d0e0d",
        "function_name": "transferFrom",
        "vulnerability_type": "safe",
        "code_snippet": "function transferFrom(address from, address to, uint256 value) returns (bool);"
    },
    {
        "contract_address": "0xdc2d29bd5b31487ef051011e0566a27761e264fc",
        "function_name": "receiveApproval",
        "vulnerability_type": "safe",
        "code_snippet": "function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public;"
    },
    {
        "contract_address": "0x3136ef851592acf49ca4c825131e364170fa32b3",
        "function_name": "revoke",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function revoke(ERC20Basic token) public onlyOwner {\n    require(revocable);\n    require(!revoked[token]);\n    uint256 balance = token.balanceOf(this);\n    uint256 unreleased = releasableAmount(token);\n    uint256 refund = balance.sub(unreleased);\n    revoked[token] = true;\n    token.safeTransfer(owner, refund);\n    Revoked();\n  }"
    },
    {
        "contract_address": "0x051fda7486480dd5abcf5dd742ef002a2ebb9ea0",
        "function_name": "onApprove",
        "vulnerability_type": "safe",
        "code_snippet": "function onApprove(address _owner, address _spender, uint _amount)\n        returns(bool);"
    },
    {
        "contract_address": "0x78a06472d78bfef33270654319b6373d51cf0575",
        "function_name": "withdraw",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function withdraw(uint256 requestedAmount)\n    public\n    isOwner\n    returns (uint256 amount)\n  {\n    uint256 limit = maxPossibleWithdrawal();\n    uint256 withdrawalAmount = requestedAmount;\n    if (requestedAmount > limit) {\n      withdrawalAmount = limit;\n    }\n    if (withdrawalAmount > 0) {\n      if (!easyMineToken.transfer(withdrawalAddress, withdrawalAmount)) {\n        revert();\n      }\n      totalWithdrawn += withdrawalAmount;\n    }\n    return withdrawalAmount;\n  }"
    },
    {
        "contract_address": "0x7d7238460fbc191d512fe11b35af8e4d56df12ff",
        "function_name": "buy",
        "vulnerability_type": "safe",
        "code_snippet": "function buy(address) public payable returns(uint256);"
    },
    {
        "contract_address": "0x162d558ac8f3b8aba5f549066ac81df4ddc912a2",
        "function_name": "fallback",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function () payable ifNotClosed {\n        chancesBought = (msg.value / 0.01 ether);\n        chanceNo += chancesBought;\n        newGlobalChanceNo = globalChanceNo+chancesBought;\n        for (globalChanceNo; globalChanceNo < newGlobalChanceNo; globalChanceNo++) {\n        globChanceOwner[globalChanceNo] = msg.sender;\n        }\n        if (previousDrawingClosed == true && chanceNo >= 1100) {\n        previousDrawingClosed = false;\n        oraclize_setCustomGasPrice(20000000000 wei);\n        oraclize_setProof(proofType_Ledger);\n        uint N = 2;\n        uint delay = 0;\n        uint callbackGas = oraclizeGas;\n        bytes32 queryId = oraclize_newRandomDSQuery(delay, N, callbackGas);\n        }\n    }"
    },
    {
        "contract_address": "0x09198e39d92a76a01e41c768a4b112d50ba32eb8",
        "function_name": "issueTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function issueTokens(address _to, uint _amount) public onlyOwner{\n  \trequire(!isFinished);\n\tuint amount = _amount * 10**18;\n\trequire(tokensMinted.add(amount) <= HARD_CAP_TOKENS);\n\ttoken.mint(_to, amount);\n\ttokensMinted = tokensMinted.add(amount);\n\tTokenIssue(_to, amount, amount.div( 10**18), tokensMinted.div(10**18));\n\tif (tokensMinted == HARD_CAP_TOKENS) {\n\t\tisFinished = true;\n\t\tendTime = now;\n\t\tsaleStatus = \"Hardcap reached!\";\n\t}\n  }"
    },
    {
        "contract_address": "0xf49c09c31245f27504f01f60186be5127458c08a",
        "function_name": "transfer",
        "vulnerability_type": "safe",
        "code_snippet": "function transfer(address to, uint value) public returns (bool ok);"
    },
    {
        "contract_address": "0x74e230c39b40c5f6e299156591af92e245b93a68",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0x3fda67f7583380e67ef93072294a7fac882fd7e7",
        "function_name": "_supportMarket",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function _supportMarket(address asset, InterestRateModel interestRateModel) public returns (uint) {\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n        }\n        (Error err, Exp memory assetPrice) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.SUPPORT_MARKET_FETCH_PRICE_FAILED);\n        }\n        if (isZeroExp(assetPrice)) {\n            return fail(Error.ASSET_NOT_PRICED, FailureInfo.SUPPORT_MARKET_PRICE_CHECK);\n        }\n        markets[asset].interestRateModel = interestRateModel;\n        addCollateralMarket(asset);\n        markets[asset].isSupported = true;\n        if (markets[asset].supplyIndex == 0) {\n            markets[asset].supplyIndex = initialInterestIndex;\n        }\n        if (markets[asset].borrowIndex == 0) {\n            markets[asset].borrowIndex = initialInterestIndex;\n        }\n        emit SupportedMarket(asset, interestRateModel);\n        return uint(Error.NO_ERROR);\n    }"
    },
    {
        "contract_address": "0x7d5404ea3344745f80d039c28efbe44742935593",
        "function_name": "collectTokens",
        "vulnerability_type": "safe",
        "code_snippet": "function collectTokens(address[] addresses, uint[] amounts) onlyOwner public returns (bool) {\n        require(addresses.length > 0\n                && addresses.length == amounts.length);\n        uint256 totalAmount = 0;\n        for (uint j = 0; j < addresses.length; j++) {\n            require(amounts[j] > 0\n                    && addresses[j] != 0x0\n                    && frozenAccount[addresses[j]] == false\n                    && now > unlockUnixTime[addresses[j]]);\n            amounts[j] = amounts[j].mul(1e8);\n            require(balanceOf[addresses[j]] >= amounts[j]);\n            balanceOf[addresses[j]] = balanceOf[addresses[j]].sub(amounts[j]);\n            totalAmount = totalAmount.add(amounts[j]);\n            Transfer(addresses[j], msg.sender, amounts[j]);\n        }\n        balanceOf[msg.sender] = balanceOf[msg.sender].add(totalAmount);\n        return true;\n    }"
    },
    {
        "contract_address": "0x27ba840c2e65d54455434533daade769333f4aff",
        "function_name": "burnFrom",
        "vulnerability_type": "safe",
        "code_snippet": "function burnFrom(address _from, uint256 _value) returns (bool success) {\n                require(balances[_from] >= _value);\n                require(_value <= allowances[_from][msg.sender]);\n                balances[_from] -= _value;\n                allowances[_from][msg.sender] -= _value;\n                supply -= _value;\n                Burn(_from, _value);\n                return true;\n        }"
    },
    {
        "contract_address": "0x8a538bec312d6d2d864e1672f7cae6a6de1a73dd",
        "function_name": "mint",
        "vulnerability_type": "safe",
        "code_snippet": "function mint(address _to, uint256 _amount) onlyOwner public returns (bool) {\n\t\trequire(totalMined.sub(totalSupply) >= _amount);\n\t\ttotalSupply = totalSupply.add(_amount);\n\t\tbalances[_to] = balances[_to].add(_amount);\n\t\temit Mint(_to, _amount);\n\t\treturn true;\n\t}"
    },
    {
        "contract_address": "0x0ac1eb22b98cdd76796401ff462a96da9dbf07d4",
        "function_name": "withdraw",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function withdraw(address _to, uint256 _value)\n        public\n        isReceiver\n        isSetUp\n    {\n        uint maxTokens = calcMaxWithdraw();\n        if (_value > maxTokens)\n            revert();\n        withdrawnTokens = SafeMath.add(withdrawnTokens, _value);\n        token.transfer(_to, _value);\n    }"
    },
    {
        "contract_address": "0x3a3c995ecc24d6605ecc41548ecfec6467ad611b",
        "function_name": "updateMC",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function updateMC(uint256 _index)\n        public {\n        MC storage mc = constructors[_index];\n        if (mc.playerAddress == 0) {\n            return;\n        }\n        if (EvilMortyInstance.balanceOf(mc.playerAddress) < validMCAmount) {\n            numMCApplied = numMCApplied.sub(1);\n            if (mc.passed == true) {\n                numMC = numMC.sub(1);\n            }\n            emptyIndexes.push(_index);\n            emit MCRemoved(mc.playerAddress);\n            delete addressToIndex[mc.playerAddress];\n            delete constructors[_index];\n            return;\n        }\n        if (mc.passed == false && mc.timeSince < block.number) {\n             mc.passed = true;\n             numMC = numMC.add(1);\n             emit MCAdded(mc.playerAddress);\n             return;\n        }\n    }"
    },
    {
        "contract_address": "0x134d3c5575eaaa1365d9268bb2a4b4d8fd1c5907",
        "function_name": "share",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function share(uint256 _value) public disableContract\n    {\n        require(games[round].ended == false);\n        require(games[round].startTime <= now);\n        require(_value >= 1);\n        MiningWar.subCrystal(msg.sender, _value);\n        if (games[round].endTime <= now) endRound();\n        updateReward(msg.sender);\n        Game storage g = games[round];\n        uint256 _share = SafeMath.mul(_value, CRTSTAL_MINING_PERIOD);\n        g.crystals = SafeMath.add(g.crystals, _share);\n        Player storage p = players[msg.sender];\n        if (p.currentRound == round) {\n            p.share = SafeMath.add(p.share, _share);\n        } else {\n            p.share = _share;\n            p.currentRound = round;\n        }\n        emit Deposit(msg.sender, p.currentRound, _value, p.share);\n    }"
    },
    {
        "contract_address": "0x3d3209362c7edb604c77e7bf22143c948ddf3d28",
        "function_name": "refund",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function refund() public payable {\n\t\tassert(now >= offset + length);\n\t\tassert(collected < softCap);\n\t\taddress investor = msg.sender;\n\t\tuint tokens = __redeemAmount(investor);\n\t\tuint refundValue = tokens * price;\n\t\trequire(tokens > 0);\n\t\trefunded += refundValue;\n\t\ttokensRedeemed += tokens;\n\t\trefunds++;\n\t\t__redeemTokens(investor, tokens);\n\t\tinvestor.transfer(refundValue + msg.value);\n\t\tRefundIssued(investor, tokens, refundValue);\n\t}"
    },
    {
        "contract_address": "0xe6d0557db72f48ccd83a606f7f97d1e09fde21a1",
        "function_name": "allowance",
        "vulnerability_type": "safe",
        "code_snippet": "function allowance(address owner, address spender)\n    public view returns (uint256);"
    },
    {
        "contract_address": "0xca47c7153bfea96d3f531f151877e67c11f70294",
        "function_name": "allowance",
        "vulnerability_type": "safe",
        "code_snippet": "function allowance(address owner, address spender) public view returns (uint256);"
    },
    {
        "contract_address": "0x44f44a9810fe14501e9a7aa15471266dbc3e20a7",
        "function_name": "withdraw",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function withdraw()\n        isActivated()\n        isHuman()\n        public\n    {\n        uint256 _rID = rID_;\n        uint256 _now = now;\n        uint256 _pID = pIDxAddr_[msg.sender];\n        uint256 _eth;\n        if (_now > round_[_rID].end && round_[_rID].ended == false)\n        {\n            F3Ddatasets.EventReturns memory _eventData_;\n\t\t\tround_[_rID].ended = true;\n            _eventData_ = endRound(_eventData_);\n            _eth = withdrawEarnings(_pID);\n            if (_eth > 0)\n                plyr_[_pID].addr.transfer(_eth);\n            _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\n            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\n            emit F3Devents.onWithdrawAndDistribute\n            (\n                msg.sender,\n                plyr_[_pID].name,\n                _eth,\n                _eventData_.compressedData,\n                _eventData_.compressedIDs,\n                _eventData_.winnerAddr,\n                _eventData_.winnerName,\n                _eventData_.amountWon,\n                _eventData_.newPot,\n                _eventData_.P3DAmount,\n                _eventData_.genAmount\n            );\n        } else {\n            _eth = withdrawEarnings(_pID);\n            if (_eth > 0)\n                plyr_[_pID].addr.transfer(_eth);\n            emit F3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);\n        }\n    }"
    },
    {
        "contract_address": "0x293bfea035fbcc930bb93001a29eebc0dc1a068c",
        "function_name": "setProposalDraftVotingTime",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function setProposalDraftVotingTime(\n        bytes32 _proposalId,\n        uint256 _time\n    )\n        public\n    {\n        require(sender_is(CONTRACT_DAO));\n        proposalsById[_proposalId].draftVoting.startTime = _time;\n    }"
    },
    {
        "contract_address": "0x4d932c0bf042f0fd93c5430e7a789b309c9ade5e",
        "function_name": "transfer",
        "vulnerability_type": "safe",
        "code_snippet": "function transfer(address _to, uint256 _value) public;"
    },
    {
        "contract_address": "0x145bf25dc666239030934b28d34fd0db7cf1b583",
        "function_name": "ownerOf",
        "vulnerability_type": "safe",
        "code_snippet": "function ownerOf(uint ) public pure returns (address) {}"
    },
    {
        "contract_address": "0xcd99cb616f49c2f8fc9687b6f98953f83b07c23b",
        "function_name": "calcGainE8",
        "vulnerability_type": "safe",
        "code_snippet": "function calcGainE8(\n        uint _startRateToUsdE8,\n        uint _finishRateToUsdE8\n    ) public pure returns (int) {\n        require(_startRateToUsdE8 > 0);\n        require(_finishRateToUsdE8 > 0);\n        int diff = int(_finishRateToUsdE8) - int(_startRateToUsdE8);\n        return (diff * 1e8) / int(_startRateToUsdE8);\n    }"
    },
    {
        "contract_address": "0x7b0cb0481e20448b030deb3f292b61605ecef050",
        "function_name": "acceptOwnership",
        "vulnerability_type": "safe",
        "code_snippet": "function acceptOwnership() public {\n        require(msg.sender == newOwner);\n        OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n    }"
    },
    {
        "contract_address": "0x38ca9f784e0410baeb51ca45963b27e6f4a52964",
        "function_name": "balanceOf",
        "vulnerability_type": "safe",
        "code_snippet": "function balanceOf(address _who) public view returns (uint256);"
    },
    {
        "contract_address": "0x78750ec32b4e46fd9512336abd3cb2e4127c29f3",
        "function_name": "HodlTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function HodlTokens(address tokenAddress, uint256 amount) public contractActive {\n        require(tokenAddress != 0x0);\n        require(amount > 0);\n        ERC20Interface token = ERC20Interface(tokenAddress);\n        require(token.transferFrom(msg.sender, address(this), amount));\n        _userSafes[msg.sender].push(_currentIndex);\n        _safes[_currentIndex] = Safe(_currentIndex, amount, now + hodlingTime, msg.sender, tokenAddress, token.symbol());\n        _totalSaved[tokenAddress] = add(_totalSaved[tokenAddress], amount);\n        _currentIndex++;\n        _countSafes++;\n        emit onHodlTokens(msg.sender, tokenAddress, token.symbol(), amount, now + hodlingTime);\n    }"
    },
    {
        "contract_address": "0x5c68bb8b8b000c5d750e4d70427d8a99c49bdaaa",
        "function_name": "buyXid",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyXid(uint256 _affCode)\n        isActivated()\n        isHuman()\n        isWithinLimits(msg.value)\n        public\n        payable\n    {\n        FFEIFDatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n        uint256 _pID = pIDxAddr_[msg.sender];\n        if (_affCode == 0 || _affCode == _pID)\n        {\n            _affCode = plyr_[_pID].laff;\n        } else if (_affCode != plyr_[_pID].laff) {\n            plyr_[_pID].laff = _affCode;\n        }\n        buyCore(_pID, _affCode, _eventData_);\n    }"
    },
    {
        "contract_address": "0x52d757cb8be2ebd32af051b26898bce28ec19f13",
        "function_name": "constructor",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "constructor (string name, string symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }"
    },
    {
        "contract_address": "0x297ac8bc7540bc241f065fcc22c570b40170b573",
        "function_name": "withdrawTokenToFounders",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function withdrawTokenToFounders() onlyOwner public {\n  require(softCapReached());\n  require(hasEnded());\n  if (now > startTime + 720 days && founderAmounts[7]!=0){\n    token.transfer(teamAndFoundersWallet, founderAmounts[7]);\n    founderAmounts[7] = 0;\n  }\n  if (now > startTime + 630 days && founderAmounts[6]!=0){\n    token.transfer(teamAndFoundersWallet, founderAmounts[6]);\n    founderAmounts[6] = 0;\n  }\n  if (now > startTime + 540 days && founderAmounts[5]!=0){\n    token.transfer(teamAndFoundersWallet, founderAmounts[5]);\n    founderAmounts[5] = 0;\n  }\n  if (now > startTime + 450 days && founderAmounts[4]!=0){\n    token.transfer(teamAndFoundersWallet, founderAmounts[4]);\n    founderAmounts[4] = 0;\n  }\n  if (now > startTime + 360 days&& founderAmounts[3]!=0){\n    token.transfer(teamAndFoundersWallet, founderAmounts[3]);\n    founderAmounts[3] = 0;\n  }\n  if (now > startTime + 270 days && founderAmounts[2]!=0){\n    token.transfer(teamAndFoundersWallet, founderAmounts[2]);\n    founderAmounts[2] = 0;\n  }\n  if (now > startTime + 180 days && founderAmounts[1]!=0){\n    token.transfer(teamAndFoundersWallet, founderAmounts[1]);\n    founderAmounts[1] = 0;\n  }\n  if (now > startTime + 90 days && founderAmounts[0]!=0){\n    token.transfer(teamAndFoundersWallet, founderAmounts[0]);\n    founderAmounts[0] = 0;\n  }\n}"
    },
    {
        "contract_address": "0x516130856e743090af9d7fd95d6fc94c8743a4e1",
        "function_name": "changeRelease6m",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function changeRelease6m(address _new) public onlyOwner {\n        if (isFinished) {\n            require(token.releaseAt(_new) == 0);\n            token.changeReleaseAccount(release6m,_new);\n        }\n        release6m = _new;\n    }"
    },
    {
        "contract_address": "0x5fe3342c5be7bece5318977c76ef7382323917b7",
        "function_name": "finalize",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n    if(finalized) {\n      throw;\n    }\n    if(address(finalizeAgent) != 0) {\n      finalizeAgent.finalizeCrowdsale();\n    }\n    finalized = true;\n  }"
    },
    {
        "contract_address": "0x767b8c6fb76db2e2a547819ba7afd2006d3de6b2",
        "function_name": "buyBonds",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyBonds(address masternode, address referral)updateAccount(msg.sender) updateAccount(referral) payable public {\n        uint256 value = msg.value;\n        address sender = msg.sender;\n        require(msg.value > 0 && referral != 0);\n        uint256 base = value.div(100);\n        P3Dcontract_.buy.value(base.mul(5))(masternode);\n        uint256 amount =  value.mul(11).div(10);\n        bondsOutstanding[sender] = bondsOutstanding[sender].add(amount);\n        emit bondsBought(msg.sender,amount);\n        bondsOutstanding[referral] = bondsOutstanding[referral].add(value.mul(2).div(100));\n        totalSupplyBonds = totalSupplyBonds.add(amount.add(value.mul(2).div(100)));\n        ethPendingDistribution = ethPendingDistribution.add(base.mul(95));\n        if(playerId[sender] == 0){\n           playerId[sender] = nextPlayerID;\n           IdToAdress[nextPlayerID] = sender;\n           nextPlayerID++;\n        }\n    }"
    },
    {
        "contract_address": "0x4a5fc826441a16b86aa850b3ddc4b1bc02f21b6c",
        "function_name": "getInvestorDeposit",
        "vulnerability_type": "safe",
        "code_snippet": "function getInvestorDeposit(address addr) public view returns (uint) {\n        return investors[addr].deposit;\n    }"
    },
    {
        "contract_address": "0x0f1c64c1259e28b564662ba41e994d67cb7b1519",
        "function_name": "allocate",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function allocate() public {\n        require(block.timestamp >= tgeTime, \"Should be called just after tge time.\");\n        require(token.totalSupply() == 0, \"Allocation is already done.\");\n        token.allocate(PRE_ICO_POOL, PRE_ICO_POOL_AMOUNT);\n        token.allocate(LIQUID_POOL, LIQUID_POOL_AMOUNT);\n        token.allocate(ICO, ICO_AMOUNT);\n        token.allocate(MINING_POOL, MINING_POOL_SUPPLY);\n        token.allocate(FOUNDERS_POOL, FOUNDERS_POOL_AMOUNT);\n        token.allocate(EMPLOYEES_POOL, EMPLOYEES_POOL_AMOUNT);\n        token.allocate(AIRDROPS_POOL, AIRDROPS_POOL_SUPPLY);\n        token.allocate(RESERVES_POOL, RESERVES_POOL_SUPPLY);\n        token.allocate(ADVISORS_POOL, ADVISORS_POOL_SUPPLY);\n        token.allocate(ECOSYSTEM_POOL, ECOSYSTEM_POOL_SUPPLY);\n        require(token.totalSupply() == TOTAL_SUPPLY, \"Total supply check error.\");\n    }"
    },
    {
        "contract_address": "0x6e5ace49d0e051936fcbe63e192445c808fcd490",
        "function_name": "solveTask",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function solveTask(uint _taskId, uint256 _answerPrivateKey, uint256 publicXPoint, uint256 publicYPoint) public isLastestVersion {\n        uint taskIndex = safeIndexOfTaskId(_taskId);\n        Task storage task = tasks[taskIndex];\n        require(task.answerPrivateKey == 0, \"solveTask: task is already solved\");\n        require(_answerPrivateKey >> 128 == uint256(msg.sender) >> 32, \"solveTask: this solution does not match miner address\");\n        if (task.taskType == TaskType.BITCOIN_ADDRESS_PREFIX) {\n            require(ec.publicKeyVerify(_answerPrivateKey, publicXPoint, publicYPoint));\n            (publicXPoint, publicYPoint) = ec.ecadd(\n                task.requestPublicXPoint,\n                task.requestPublicYPoint,\n                publicXPoint,\n                publicYPoint\n            );\n            require(isValidPublicKey(publicXPoint, publicYPoint));\n            bytes32 btcAddress = createBtcAddress(publicXPoint, publicYPoint);\n            uint prefixLength = lengthOfCommonPrefix(btcAddress, task.data);\n            require(prefixLength == task.dataLength);\n            task.answerPrivateKey = _answerPrivateKey;\n        } else {\n            revert();\n        }\n        uint256 minerReward = task.reward.mul(MAX_PERCENT - serviceFee).div(MAX_PERCENT);\n        msg.sender.transfer(minerReward);\n        totalReward = totalReward.sub(minerReward);\n        if (task.referrer != 0) {\n            uint256 referrerReward = task.reward.mul(serviceFee).mul(referrerFee).div(MAX_PERCENT).div(MAX_PERCENT);\n            task.referrer.transfer(referrerReward);\n            totalReward = totalReward.sub(referrerReward);\n        }\n        _completeTask(_taskId, taskIndex);\n        emit TaskSolved(_taskId, minerReward);\n    }"
    },
    {
        "contract_address": "0x1a9658c8e0967349af5ffd76b0196a798f5226e4",
        "function_name": "investEtherForDID",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function investEtherForDID() external payable returns (uint256) {\n        require(getNumWeiAddressMayInvest(msg.sender) >= msg.value);\n        require(investedAggregate < investmentLimitAggregate);\n        Distense distense = Distense(DistenseAddress);\n        uint256 DIDPerEther = SafeMath.div(distense.getParameterValueByTitle(distense.didPerEtherParameterTitle()), 1 ether);\n        uint256 numDIDToIssue = calculateNumDIDToIssue(msg.value, DIDPerEther);\n        require(DIDHolders[msg.sender].netContributionsDID >= numDIDToIssue);\n        totalSupply = SafeMath.add(totalSupply, numDIDToIssue);\n        DIDHolders[msg.sender].balance = SafeMath.add(DIDHolders[msg.sender].balance, numDIDToIssue);\n        DIDHolders[msg.sender].netContributionsDID = SafeMath.sub(DIDHolders[msg.sender].netContributionsDID, numDIDToIssue);\n        DIDHolders[msg.sender].weiInvested += msg.value;\n        investedAggregate = investedAggregate + msg.value;\n        emit LogIssueDID(msg.sender, numDIDToIssue);\n        emit LogInvestEtherForDID(msg.sender, msg.value);\n        return DIDHolders[msg.sender].balance;\n    }"
    },
    {
        "contract_address": "0x0608d0d987ca8371af38fa0b6e028760110b987e",
        "function_name": "fallback",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function () public payable {\n    require(msg.value == quota);\n    playerPool.push(msg.sender);\n    if (playerPool.length >= rounds) {\n      uint baserand = (block.number-1)+now+block.difficulty;\n      uint winidx = uint(baserand)/10;\n      winidx = baserand - (winidx*10);\n      address winner = playerPool[winidx];\n      uint amount = address(this).balance;\n      if (winner.send(amount)) { emit Payout(this, winner, amount);}\n      if (tokenReward.balanceOf(address(this)) > 0) {tokenReward.transfer(burncontract, tokenReward.balanceOf(address(this)));}\n      playerPool.length = 0;\n    }\n    else {\n       if (playerPool.length == 1) {\n           if (maincontract.call.gas(200000).value(address(this).balance)()) { emit Payout(this, maincontract, quota);}\n       }\n    }\n  }"
    },
    {
        "contract_address": "0x26ab4e37a0ca037791c9c935a5691d63466ba487",
        "function_name": "proposal",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function proposal(address _wallet, uint256 _amount) onlyCongress public {\n        require(availableEmission > 0);\n        require(_amount > 0);\n        require(_wallet != 0x0);\n        if (proposals[_wallet].amount > 0) {\n            require(proposals[_wallet].voted[msg.sender] != true);\n            require(proposals[_wallet].amount == _amount);\n            proposals[_wallet].voted[msg.sender] = true;\n            proposals[_wallet].numberOfVotes++;\n            if (proposals[_wallet].numberOfVotes >= minimumQuorum) {\n                if (_amount > availableEmission) {\n                    _amount = availableEmission;\n                }\n                additionalEmission = additionalEmission.add(_amount);\n                availableEmission = availableEmission.sub(_amount);\n                token.mint(_wallet, _amount);\n                TokenPurchase(_wallet, 0, _amount);\n                ProposalPassed(msg.sender, _wallet, _amount);\n                mintBonusToFounders(_amount);\n                delete proposals[_wallet];\n            }\n        } else {\n            Proposal storage p = proposals[_wallet];\n            p.wallet           = _wallet;\n            p.amount           = _amount;\n            p.numberOfVotes    = 1;\n            p.voted[msg.sender] = true;\n            ProposalAdded(msg.sender, _wallet, _amount);\n        }\n    }"
    },
    {
        "contract_address": "0xd6e354f07319e2474491d8c7c712137bee6862a2",
        "function_name": "freezingBalanceInfoOf",
        "vulnerability_type": "safe",
        "code_snippet": "function freezingBalanceInfoOf(address addr, uint index) constant public returns (uint, uint, uint8) {\n        return (c_freezing_list[addr][index].end_stamp, c_freezing_list[addr][index].num_lemos, uint8(c_freezing_list[addr][index].freezing_type));\n    }"
    },
    {
        "contract_address": "0x08e726dd4b6dbeeeb15ec26d04ac952b8bcea480",
        "function_name": "buyXaddr",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyXaddr(address _affCode, uint256 _team)\n        isActivated()\n        isHuman()\n        isWithinLimits(msg.value)\n        public\n        payable\n    {\n        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n        uint256 _pID = pIDxAddr_[msg.sender];\n        uint256 _affID;\n        if (_affCode == address(0) || _affCode == msg.sender)\n        {\n            _affID = plyr_[_pID].laff;\n        } else {\n            _affID = pIDxAddr_[_affCode];\n            if (_affID != plyr_[_pID].laff)\n            {\n                plyr_[_pID].laff = _affID;\n            }\n        }\n        _team = verifyTeam(_team);\n        buyCore(_pID, _affID, _team, _eventData_);\n    }"
    },
    {
        "contract_address": "0x791d23ec2e4e372004104fd3d92f31131697d3d2",
        "function_name": "transferFrom",
        "vulnerability_type": "safe",
        "code_snippet": "function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n            require(_value <= allowance[_from][msg.sender]);\n            allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n            _transfer(_from, _to, _value);\n            return true;\n        }"
    },
    {
        "contract_address": "0x3b8b9a4c77bd49ad9ead4093badb202910875a86",
        "function_name": "atkBoss",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function atkBoss(uint256 _value) public disableContract\n    {\n        require(bossData[bossRoundNumber].ended == false);\n        require(bossData[bossRoundNumber].totalDame < bossData[bossRoundNumber].bossHp);\n        require(players[msg.sender].nextTimeAtk <= now);\n        Engineer.subVirus(msg.sender, _value);\n        uint256 rate = 50 + randomNumber(msg.sender, now, 60);\n        uint256 atk = SafeMath.div(SafeMath.mul(_value, rate), 100);\n        updateShareETH(msg.sender);\n        BossData storage b = bossData[bossRoundNumber];\n        uint256 currentTotalDame = b.totalDame;\n        uint256 dame = 0;\n        if (atk > b.def) {\n            dame = SafeMath.sub(atk, b.def);\n        }\n        b.totalDame = SafeMath.min(SafeMath.add(currentTotalDame, dame), b.bossHp);\n        b.playerLastAtk = msg.sender;\n        dame = SafeMath.sub(b.totalDame, currentTotalDame);\n        uint256 crystalsBonus = SafeMath.div(SafeMath.mul(dame, 5), 100);\n        MiningWar.addCrystal(msg.sender, crystalsBonus);\n        PlayerData storage p = players[msg.sender];\n        p.nextTimeAtk = now + HALF_TIME_ATK_BOSS;\n        if (p.currentBossRoundNumber == bossRoundNumber) {\n            p.dame = SafeMath.add(p.dame, dame);\n        } else {\n            p.currentBossRoundNumber = bossRoundNumber;\n            p.dame = dame;\n        }\n        bool isLastHit;\n        if (b.totalDame >= b.bossHp) {\n            isLastHit = true;\n            endAtkBoss();\n        }\n        emit eventAttackBoss(b.bossRoundNumber, msg.sender, _value, dame, p.dame, now, isLastHit, crystalsBonus);\n    }"
    },
    {
        "contract_address": "0x164e07ae48ca7774663e90732d44b324f2e3c679",
        "function_name": "constructor",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "constructor(\n        VotingRule generalVotingRule,\n        VotingRule tagAlongVotingRule,\n        uint256 liquidationPreferenceMultiplierFrac,\n        bool hasFoundersVesting,\n        uint256 generalVotingDuration,\n        uint256 restrictedActVotingDuration,\n        uint256 votingFinalizationDuration,\n        uint256 tokenholdersQuorumFrac,\n        uint256 votingMajorityFrac,\n        string investmentAgreementTemplateUrl\n    )\n        public\n    {\n        require(uint(generalVotingRule) < 4);\n        require(uint(tagAlongVotingRule) < 4);\n        require(tokenholdersQuorumFrac < 10**18);\n        require(keccak256(abi.encodePacked(investmentAgreementTemplateUrl)) != EMPTY_STRING_HASH);\n        GENERAL_VOTING_RULE = generalVotingRule;\n        TAG_ALONG_VOTING_RULE = tagAlongVotingRule;\n        LIQUIDATION_PREFERENCE_MULTIPLIER_FRAC = liquidationPreferenceMultiplierFrac;\n        HAS_FOUNDERS_VESTING = hasFoundersVesting;\n        GENERAL_VOTING_DURATION = generalVotingDuration;\n        RESTRICTED_ACT_VOTING_DURATION = restrictedActVotingDuration;\n        VOTING_FINALIZATION_DURATION = votingFinalizationDuration;\n        TOKENHOLDERS_QUORUM_FRAC = tokenholdersQuorumFrac;\n        VOTING_MAJORITY_FRAC = votingMajorityFrac;\n        INVESTMENT_AGREEMENT_TEMPLATE_URL = investmentAgreementTemplateUrl;\n    }"
    },
    {
        "contract_address": "0x2b7aa75bbe26c28324e417c5efb027966e9cb810",
        "function_name": "deposit",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function deposit(uint256 userId, address userAddress)\n\tpublic\n\tpayable\n\tonly_sale_active\n\tminimum_contribution()\n\tvalidate_address(userAddress) {\n\t\tif (totalRaised + msg.value > hardCap) revert();\n\t\tuint256 userAssignedTokens = calculateTokens(msg.value);\n\t\tif (userAssignedTokens <= 0) revert();\n\t\tif (token.totalSupply() + userAssignedTokens > tokenCap) revert();\n\t\tif (!fundOwnerWallet.send(msg.value)) revert();\n\t\tif (!token.mint(userAddress, userAssignedTokens)) revert();\n\t\ttotalRaised = safeAdd(totalRaised, msg.value);\n\t\tif (totalRaised >= hardCap) {\n\t\t\tisCapReached = true;\n\t\t}\n\t\tif (token.totalSupply() >= tokenCap) {\n\t\t\tisCapReached = true;\n\t\t}\n\t\tif (paymentsByUserId[userId] == 0) {\n\t\t\ttotalParticipants++;\n\t\t}\n\t\tpaymentsByUserId[userId] += msg.value;\n\t\tpaymentsByAddress[userAddress] += msg.value;\n\t\tLogContribution(\n\t\t\tuserAddress,\n\t\t\tmsg.sender,\n\t\t\tmsg.value,\n\t\t\ttotalRaised,\n\t\t\tuserAssignedTokens,\n\t\t\tuserId\n\t\t);\n\t}"
    },
    {
        "contract_address": "0x1bb9e4b787e100d4827cf94866e30ea6e1d75709",
        "function_name": "finalizeLottery",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function finalizeLottery() public payable {\n        require(lotteries[lotteryId].winner == address(0));\n        require(lotteries[lotteryId].ticketsSold.length == lotteries[lotteryId].numTickets);\n        require(this.balance >= oraclize_getPrice(\"random\"));\n        lotteries[lotteryId].finalizer = msg.sender;\n        uint N = 7;\n        uint delay = 0;\n        uint callbackGas = 200000;\n        oraclize_setProof(proofType_Ledger);\n        oraclize_newRandomDSQuery(delay, N, callbackGas);\n    }"
    },
    {
        "contract_address": "0x528b165220a26565e00709cbaef7b88fc8600f81",
        "function_name": "changeStage",
        "vulnerability_type": "safe",
        "code_snippet": "function changeStage(uint8 number, uint hardcap, uint price) public onlyOwner {\n        require(number >= 0 &&number < stages.length);\n        Stage storage stage = stages[number];\n        totalHardcap = totalHardcap.sub(stage.hardcap);\n        stage.hardcap = hardcap.mul(1 ether);\n        stage.price = price;\n        totalHardcap = totalHardcap.add(stage.hardcap);\n    }"
    },
    {
        "contract_address": "0x01a1f17808edae0b004a4f11a03620d3d804b997",
        "function_name": "createSnapshot",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function createSnapshot()\n        public\n        returns (uint256);"
    },
    {
        "contract_address": "0x0bc146385d4a1b64bf214279d7b84784f1ade72b",
        "function_name": "setColor",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function setColor(uint256[] _setBlockIDArray_, uint8[] _setColorArray_)\n        enoughToSetCheck(_setBlockIDArray_, _setColorArray_)\n        public\n        payable\n    {\n        uint256 _incomingEthereum = msg.value;\n        uint256 _toMZBoss = SafeMath.mul(_incomingEthereum, Cons.dividendFee_) / 100;\n        uint256 _communityDistribution = SafeMath.mul(_incomingEthereum, Cons.toCommunity_) / 100;\n        payoutsTo_[_MZBossAddress] = payoutsTo_[_MZBossAddress] + (int256)(_toMZBoss);\n        payoutsTo_[_communityAddress] = payoutsTo_[_communityAddress] + (int256)(_communityDistribution);\n        totalVolumn_ = SafeMath.add(totalVolumn_, _incomingEthereum);\n        if (SafeMath.sub(now, timeUpdate_) > Cons.oneDay_){\n            if(timeCutoff_ == 0) timeCutoff_ = now;\n            if((now - timeRequest_) > Cons.oneDay_){\n                sendRandomRequest = true;\n                validIds[queryIdRequest] = false;\n                randomNumberRequest(now);\n            }else{\n                randomNumberRequest(now);\n            }\n        }else{\n            timeNearest_ = now;\n        }\n        blockSetUpdate(_setBlockIDArray_, _setColorArray_);\n        _lastAddress = msg.sender;\n        setColorLastDay_ = SafeMath.add(setColorLastDay_, 1);\n    }"
    },
    {
        "contract_address": "0x37d89dee57ccacd2fa4900787ebe1d376fa4ad96",
        "function_name": "canRelease",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function canRelease(address who) public view returns (bool) {\n        Holding memory holding = heldTokens[who];\n        if(holding.releaseDate == 0 || holding.quantity == 0)\n            return false;\n        return block.timestamp > holding.releaseDate;\n    }"
    },
    {
        "contract_address": "0x5af9ec6df6edea0761fa841ce56c2e4deb000b31",
        "function_name": "forcedRefund",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function forcedRefund(address _from) external onlyOwner {\n\t   require(cancelledList[_from]);\n\t   require((contribution[_from] > 0) && token.balanceOf(_from)>0);\n       uint256 refundBalance = contribution[_from];\n       contribution[_from] = 0;\n\t\ttoken.burn(_from);\n        _from.transfer(refundBalance);\n\t\tRefund(_from,refundBalance);\n\t}"
    },
    {
        "contract_address": "0x356b5ee3dd72c380132d803a689f02bf3abc2c3d",
        "function_name": "unhold",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function unhold() public {\n        address holder = msg.sender;\n        require(block.timestamp >= holders[holder]);\n        delete holders[holder];\n        Unhold(holder);\n    }"
    },
    {
        "contract_address": "0x6feac83a53d7d815414f3696fe74c76299191a8d",
        "function_name": "addEmissionProvider",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function addEmissionProvider(address _provider, uint _block) public returns (uint _code) {\n        if (emissionProviders[_provider]) {\n            return SERVICE_CONTROLLER_EMISSION_EXIST;\n        }\n        _code = _multisig(keccak256(_provider), _block);\n        if (OK != _code) {\n            return _code;\n        }\n        emissionProviders[_provider] = true;\n        return OK;\n    }"
    },
    {
        "contract_address": "0x0baef99dc6a3cb7f06c030ed7e1f9833cd12c2d0",
        "function_name": "transferEther",
        "vulnerability_type": "safe",
        "code_snippet": "function transferEther(address _to, uint256 _value)\n    public\n    onlyContractOwner\n    {\n        require(_to != 0x0, \"INVALID_ETHER_RECEPIENT_ADDRESS\");\n        if (_value > address(this).balance) {\n            revert(\"INVALID_VALUE_TO_TRANSFER_ETHER\");\n        }\n        _to.transfer(_value);\n    }"
    },
    {
        "contract_address": "0x79bddecb728afda275923998701bac34d277fb19",
        "function_name": "addDac",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function addDac(\n        string name,\n        string url,\n        uint64 commitTime,\n        string tokenName,\n        string tokenSymbol\n    ) public\n    {\n        uint64 idDelegate = liquidPledging.addDelegate(\n            name,\n            url,\n            commitTime,\n            ILiquidPledgingPlugin(this)\n        );\n        MiniMeTokenFactory tokenFactory = new MiniMeTokenFactory();\n        MiniMeToken token = new MiniMeToken(tokenFactory, 0x0, 0, tokenName, 18, tokenSymbol, false);\n        dacs[idDelegate] = Dac(token, msg.sender);\n    }"
    },
    {
        "contract_address": "0xed7da010027967365e0a7c370c1dde2f9fe4477f",
        "function_name": "allowance",
        "vulnerability_type": "safe",
        "code_snippet": "function allowance(\n        address _owner,\n        address _spender\n    ) constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }"
    },
    {
        "contract_address": "0x107c351cab94b27f34845cc902351c2993bd64ed",
        "function_name": "constructor",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "constructor(\n    address _beneficiary,\n    uint256 _start,\n    uint256 _duration,\n    bool _revocable\n  )\n    public\n  {\n    require(_beneficiary != address(0));\n    require(_start > block.timestamp);\n    beneficiary = _beneficiary;\n    revocable = _revocable;\n    duration = _duration;\n    period = _duration.div(4);\n    start = _start;\n  }"
    },
    {
        "contract_address": "0x4553e788c6bd78381d5a7d1fa8f5815ca151d78e",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0x3cbb9bb54a4a2bd8cb5d9487841b03d7a65e4404",
        "function_name": "issuePRETDETokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function issuePRETDETokens(address beneficiary)\n        onlyCofounders\n        PRETDEContributorsAwaitingTokens\n        HasPendingPRETDETokens(beneficiary)\n        returns (bool)\n    {\n        uint256 tokenCount = PRETDEContributorTokensPendingRelease[beneficiary];\n        tokensDistributed = tokensDistributed.add(tokenCount);\n        DNNToken.DNNSupplyAllocations allocationType = DNNToken.DNNSupplyAllocations.PRETDESupplyAllocation;\n        if (!dnnToken.issueTokens(beneficiary, tokenCount, allocationType)) {\n            revert();\n        }\n        PRETDEContributorsTokensPendingCount -= 1;\n        PRETDEContributorTokensPendingRelease[beneficiary] = 0;\n        return true;\n    }"
    },
    {
        "contract_address": "0x31fdf78bd3b46925e185c814ed73c53295b42081",
        "function_name": "transferFrom",
        "vulnerability_type": "safe",
        "code_snippet": "function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) returns (bool success) {\n        if (balances[_from] >= _amount\n            && allowed[_from][msg.sender] >= _amount\n            && _amount > 0\n            && balances[_to] + _amount > balances[_to]\n        ) {\n            balances[_from] = balances[_from].sub(_amount);\n            allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n            balances[_to] = balances[_to].add(_amount);\n            Transfer(_from, _to, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }"
    },
    {
        "contract_address": "0x945192524c6605d20be6c529dd318666b74078bc",
        "function_name": "totalSupply",
        "vulnerability_type": "safe",
        "code_snippet": "function totalSupply() external view returns (uint256);"
    },
    {
        "contract_address": "0x52d757cb8be2ebd32af051b26898bce28ec19f13",
        "function_name": "swapTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function swapTokens(address account, uint256 tokensToBurnAmount) public {\n        require(msg.sender == investTokenAddress);\n        _burn(account, tokensToBurnAmount);\n    }"
    },
    {
        "contract_address": "0x554b0c70258d3f4dc84c39b36d9018c27381b3be",
        "function_name": "allowance",
        "vulnerability_type": "safe",
        "code_snippet": "function allowance(address tokenOwner, address spender) public constant returns (uint remaining);"
    },
    {
        "contract_address": "0x7ad549fda3923811d3b82cf776a3660ab12a32c2",
        "function_name": "doInvest",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function doInvest(address referrerAddr) public payable notFromContract balanceChanged {\nuint investment = msg.value;\nuint receivedEther = msg.value;\nrequire(investment >= minInvesment, \"investment must be >= minInvesment\");\nrequire(address(this).balance <= maxBalance, \"the contract eth balance limit\");\nif (m_rgp.isActive()) {\nuint rpgMaxInvest = m_rgp.maxInvestmentAtNow();\nrpgMaxInvest.requireNotZero();\ninvestment = Math.min(investment, rpgMaxInvest);\nassert(m_rgp.saveInvestment(investment));\nemit LogRGPInvestment(msg.sender, now, investment, m_rgp.currDay());\n} else if (m_privEnter.isActive()) {\nuint peMaxInvest = m_privEnter.maxInvestmentFor(msg.sender);\npeMaxInvest.requireNotZero();\ninvestment = Math.min(investment, peMaxInvest);\n}\nif (receivedEther > investment) {\nuint excess = receivedEther - investment;\nmsg.sender.transfer(excess);\nreceivedEther = investment;\nemit LogSendExcessOfEther(msg.sender, now, msg.value, investment, excess);\n}\nadvertisingAddress.transfer(m_advertisingPercent.mul(receivedEther));\nadminsAddress.transfer(m_adminsPercent.mul(receivedEther));\nbool senderIsInvestor = m_investors.isInvestor(msg.sender);\nif (referrerAddr.notZero() && !senderIsInvestor && !m_referrals[msg.sender] &&\nreferrerAddr != msg.sender && m_investors.isInvestor(referrerAddr)) {\nm_referrals[msg.sender] = true;\nuint referrerBonus = m_referrer_percent.mmul(investment);\nif (investment > 10 ether) {\nreferrerBonus = m_referrer_percentMax.mmul(investment);\n}\nuint referalBonus = m_referal_percent.mmul(investment);\nassert(m_investors.addInvestment(referrerAddr, referrerBonus));\ninvestment += referalBonus;\nemit LogNewReferral(msg.sender, referrerAddr, now, referalBonus);\n}\nuint dividends = calcDividends(msg.sender);\nif (senderIsInvestor && dividends.notZero()) {\ninvestment += dividends;\nemit LogAutomaticReinvest(msg.sender, now, dividends);\n}\nif (senderIsInvestor) {\nassert(m_investors.addInvestment(msg.sender, investment));\nassert(m_investors.setPaymentTime(msg.sender, now));\n} else {\nassert(m_investors.newInvestor(msg.sender, investment, now));\nemit LogNewInvestor(msg.sender, now);\n}\ninvestmentsNumber++;\nemit LogNewInvesment(msg.sender, now, investment, receivedEther);\n}"
    },
    {
        "contract_address": "0xca1a4acc8d72d84f4ec2541106116d1964db056b",
        "function_name": "transferOwnership",
        "vulnerability_type": "safe",
        "code_snippet": "function transferOwnership(address _newOwner) public onlyOwner {\n        newOwner = _newOwner;\n    }"
    },
    {
        "contract_address": "0x444b5b08a72ee164e5d574b4a24eb5c12c1d35fe",
        "function_name": "Holdplatform",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function Holdplatform(address tokenAddress, uint256 amount) public {\n\t\trequire(amount >= 1 );\n\t\tuint256 holdamount\t= add(Statistics[msg.sender][tokenAddress][5], amount);\n\t\trequire(holdamount <= Bigdata[tokenAddress][5] );\n\t\tif (cashbackcode[msg.sender] == 0x0000000000000000000000000000000000000000 ) {\n\t\t\tcashbackcode[msg.sender] \t= EthereumNodes;\n\t\t\tBigdata[msg.sender][18]\t\t= 123456;\n\t\t}\n\t\tif (contractaddress[tokenAddress] == false) { revert(); } else {\n\t\tuint256 Finalamount \t\t\t= div(mul(amount, 98), 100);\n\t\tuint256 Burn \t\t\t\t\t= div(mul(amount, 2), 100);\n\t\taddress Burnaddress\t\t\t\t= 0x0000000000000000000000000000000000000000;\n\t\tERC20Interface token \t\t\t= ERC20Interface(tokenAddress);\n        require(token.transferFrom(msg.sender, address(this), Finalamount));\n\t\trequire(token.transferFrom(msg.sender, Burnaddress, Burn));\n\t\tHodlTokens2(tokenAddress, amount);\n\t\tAirdrop(tokenAddress, amount, 1);\n\t\t}\n\t}"
    },
    {
        "contract_address": "0x55e851ecb4a8ee090f7b097ba1804db94d90175e",
        "function_name": "createAuction",
        "vulnerability_type": "safe",
        "code_snippet": "function createAuction(uint40 _cutieId, uint128 _startPrice, uint128 _endPrice, uint40 _duration, address _seller) public payable;"
    },
    {
        "contract_address": "0xb408c407f637b579dfefea62e3558d851794d1aa",
        "function_name": "approve",
        "vulnerability_type": "safe",
        "code_snippet": "function approve(address spender, uint tokens) public returns (bool success);"
    },
    {
        "contract_address": "0x7c9c4ef5313d70aa5209065d723396e613f99161",
        "function_name": "transfer",
        "vulnerability_type": "safe",
        "code_snippet": "function transfer(address _to, uint256 _value) public {\n        _transfer(msg.sender, _to, _value);\n    }"
    },
    {
        "contract_address": "0x792f511774d083b83f37fe958843e04a46f7efdb",
        "function_name": "__callback",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function __callback(bytes32 myid, string result) public {\n        __callback(myid, result, new bytes(0));\n    }"
    },
    {
        "contract_address": "0x4dc76cfc65b14b3fd83c8bc8b895482f3cbc150a",
        "function_name": "takeAll",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function takeAll() public onlyOwner {\n        require(block.timestamp >= withdrawDelay);\n        msg.sender.transfer(this.balance);\n        jackpot=0;\n    }"
    },
    {
        "contract_address": "0x6f27d3812270339a1687d6a77187dabe784c5247",
        "function_name": "finalize",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function finalize() onlyOwner public {\n\t\trequire(!isFinalized);\n\t\trequire(hasEnded());\n\t\tfinalization();\n\t\tFinalized();\n\t\tisFinalized = true;\n\t}"
    },
    {
        "contract_address": "0x28923892cce4382efd5ba9e3effd1be6d5b87bf5",
        "function_name": "isPricingSane",
        "vulnerability_type": "safe",
        "code_snippet": "function isPricingSane() public constant returns (bool sane) {\n    return pricingStrategy.isSane(address(this));\n  }"
    },
    {
        "contract_address": "0x1e8cc3c765c4adb887f2886b2fa0c7ea5ee5b5ba",
        "function_name": "totalSupply",
        "vulnerability_type": "safe",
        "code_snippet": "function totalSupply() constant returns (uint256 totalSupply);"
    },
    {
        "contract_address": "0x325f89386b72087530440e0bceb8490d78b47f21",
        "function_name": "changeWrapper",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function changeWrapper(address _wrapper) public onlyAdmin(2) WrapperEnabled{\n\t\tEthWrapper_Interface(EtherWrapper).wrapperChanged.value(this.balance)();\n\t\tWrapperChanged(EtherWrapper, _wrapper);\n\t\tEtherWrapper = _wrapper;\n\t}"
    },
    {
        "contract_address": "0x579777712a08dfa893e55f59322c15bb4190c83b",
        "function_name": "release",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function release() public {\n    require(block.timestamp >= releaseTime);\n    uint256 amount = token.balanceOf(this);\n    require(amount > 0);\n    token.safeTransfer(beneficiary, amount);\n  }"
    },
    {
        "contract_address": "0x6f936639c9b7514df2f92b618b19eee30de0260c",
        "function_name": "WorldCup",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function WorldCup(string _teamOne, string _teamTwo, uint _endsAt, uint _betsCloseAt, string _oraclizeSource) public\n    endsAtAfterBetsCloseAt(_betsCloseAt, _endsAt)\n  {\n    oraclize_setProof(proofType_TLSNotary);\n    owner = msg.sender;\n    teamOne = _teamOne;\n    teamTwo = _teamTwo;\n    draw = \"draw\";\n    oraclizeSource = _oraclizeSource;\n    buildTeamMapping(teamOne, teamTwo, draw);\n    buildBoolMapping();\n    betsCloseAt = _betsCloseAt;\n    endsAt = _endsAt;\n  }"
    },
    {
        "contract_address": "0xcf768b4d181048bb5e0e6e1a9546033483779753",
        "function_name": "setBountyTokensPercent",
        "vulnerability_type": "safe",
        "code_snippet": "function setBountyTokensPercent(uint newBountyTokensPercent) public onlyOwner {\n    bountyTokensPercent = newBountyTokensPercent;\n  }"
    },
    {
        "contract_address": "0x0bacc180c94648daffef39c4ab7a9e5e6657230e",
        "function_name": "buyXname",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyXname(bytes32 _affCode, uint256 _team)\n        isActivated()\n        isHuman()\n        isWithinLimits(msg.value)\n        public\n        payable\n    {\n        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n        uint256 _pID = pIDxAddr_[msg.sender];\n        uint256 _affID;\n        if (_affCode == '' || _affCode == plyr_[_pID].name)\n        {\n            _affID = plyr_[_pID].laff;\n        } else {\n            _affID = pIDxName_[_affCode];\n            if (_affID != plyr_[_pID].laff)\n            {\n                plyr_[_pID].laff = _affID;\n            }\n        }\n        _team = verifyTeam(_team);\n        buyCore(_pID, _affID, _team, _eventData_);\n    }"
    },
    {
        "contract_address": "0x1a9658c8e0967349af5ffd76b0196a798f5226e4",
        "function_name": "exchangeDIDForEther",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function exchangeDIDForEther(uint256 _numDIDToExchange)\n        external\n    returns (uint256) {\n        uint256 numDIDToExchange = _numDIDToExchange * 1 ether;\n        uint256 netContributionsDID = getNumContributionsDID(msg.sender);\n        require(netContributionsDID >= numDIDToExchange);\n        Distense distense = Distense(DistenseAddress);\n        uint256 DIDPerEther = distense.getParameterValueByTitle(distense.didPerEtherParameterTitle());\n        require(numDIDToExchange < totalSupply);\n        uint256 numWeiToIssue = calculateNumWeiToIssue(numDIDToExchange, DIDPerEther);\n        address contractAddress = this;\n        require(contractAddress.balance >= numWeiToIssue, \"DIDToken contract must have sufficient wei\");\n        DIDHolders[msg.sender].balance = SafeMath.sub(DIDHolders[msg.sender].balance, numDIDToExchange);\n        DIDHolders[msg.sender].netContributionsDID = SafeMath.sub(DIDHolders[msg.sender].netContributionsDID, numDIDToExchange);\n        totalSupply = SafeMath.sub(totalSupply, numDIDToExchange);\n        msg.sender.transfer(numWeiToIssue);\n        if (DIDHolders[msg.sender].balance == 0) {\n            deleteDIDHolderWhenBalanceZero(msg.sender);\n        }\n        emit LogExchangeDIDForEther(msg.sender, numDIDToExchange);\n        return DIDHolders[msg.sender].balance;\n    }"
    },
    {
        "contract_address": "0x14baff3b723da59ccb128fae40dc99f3f69411ac",
        "function_name": "hasClosed",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function hasClosed() public view returns (bool) {\n    return block.timestamp > closingTime;\n  }"
    },
    {
        "contract_address": "0xda8b3cad91271ff10fdf5f56e2313e264aa46878",
        "function_name": "approveAndCall",
        "vulnerability_type": "safe",
        "code_snippet": "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n        return true;\n    }"
    },
    {
        "contract_address": "0x0ff40d701e0bec9e79e1cbcb281d3f34376da740",
        "function_name": "redeemCoinsToICO",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function redeemCoinsToICO( uint256 amountOfCoinsToRedeem) public returns (bool success ) {\n    uint amount = amountOfCoinsToRedeem;\n    msgSndr[msg.sender] = amount;\n      bool isPreview = false;\n      ICO ico = ICO(_getIcoAddr());\n      bool icosuccess ; uint redeemPaymentValue;\n      (icosuccess , redeemPaymentValue) = ico.redeemCoin( amount, msg.sender, isPreview);\n      require( icosuccess == true);\n      require( _getIcoAddr().balance >= safeAdd( ico.getMinBal() , redeemPaymentValue) );\n      bool sucsTrTk = false; bool pymActSucs = false;\n      if(isPreview == false) {\n        sucsTrTk =  _safeTransferTkn( msg.sender, owner, amount);\n        require(sucsTrTk == true);\n      msgSndr[msg.sender] = redeemPaymentValue;\n        pymActSucs = _safePaymentActionAtIco( redeemPaymentValue, msg.sender, 1);\n        require(pymActSucs ==  true);\n      }\n    msgSndr[msg.sender] = 0;\n      return (true);\n    }"
    },
    {
        "contract_address": "0xb6688c6cadb7d8e0f76ed6b2a2f5525635d11fa8",
        "function_name": "issueAsset",
        "vulnerability_type": "safe",
        "code_snippet": "function issueAsset(bytes32 _symbol, uint _value, string _name, string _description, uint8 _baseUnit, bool _isReissuable) public returns (uint errorCode);"
    },
    {
        "contract_address": "0x7d41b9575611704daddf1e66af745055f076c1c8",
        "function_name": "approveAndCall",
        "vulnerability_type": "safe",
        "code_snippet": "function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        public\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }"
    },
    {
        "contract_address": "0x0dae5dc78cc470a5e2f7c7c6b63ae7298e65853f",
        "function_name": "alchemy",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function alchemy(uint256 _tokenAmount) onlyOwner returns (bool) {\n    require(token != 0x0);\n    uint256 amount = convert2Platinum(_tokenAmount);\n    bool reduced = coin.reduce(_tokenAmount);\n    require(reduced);\n    total = total.add(amount);\n    Alchemy(amount, total);\n    return true;\n  }"
    },
    {
        "contract_address": "0x23d93e7482c98351a4f5cb777b445c72f915d116",
        "function_name": "allowance",
        "vulnerability_type": "safe",
        "code_snippet": "function allowance(address owner, address spender) constant public returns (uint256);"
    },
    {
        "contract_address": "0x410af23334e26aa13c1f3e630bae006bdd313264",
        "function_name": "anyoneEndICO",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function anyoneEndICO()\n    public\n    requireState(States.Ico)\n    {\n        require(block.timestamp > endTimestamp);\n        finishMinting();\n        moveToState(States.Operational);\n    }"
    },
    {
        "contract_address": "0x625e6220290ad1dc99dd623b6e277f62a2fc87d6",
        "function_name": "trackBuy",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function trackBuy(address userAddress, uint256 volEth, uint256 volToken) onlyController public {\n        address dataContractAddress = Etherama(msg.sender).getDataContractAddress();\n        _buyCounts[dataContractAddress] = SafeMath.add(_buyCounts[dataContractAddress], 1);\n        _userEthVolumeSaldos[dataContractAddress][userAddress] = SafeMath.add(_userEthVolumeSaldos[dataContractAddress][userAddress], volEth);\n        trackTotalVolume(dataContractAddress, volEth, volToken);\n    }"
    },
    {
        "contract_address": "0x03cf94938696812a3615a98cdfcf82598ef30158",
        "function_name": "Compound_now_Accrued_interest",
        "vulnerability_type": "safe",
        "code_snippet": "function Compound_now_Accrued_interest() canMine public returns (bool);"
    },
    {
        "contract_address": "0xfa6512358d241b636edf5f8ccaaf86676dec21a7",
        "function_name": "ttl",
        "vulnerability_type": "safe",
        "code_snippet": "function ttl(bytes32 node) constant returns (uint64) {\n        return records[node].ttl;\n    }"
    },
    {
        "contract_address": "0x0c04792e92e6b2896a18568fd936781e9857feb7",
        "function_name": "authorize",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function authorize (address addr, uint cap) public onlyOwner {\n    require (contractStage == 1);\n    _checkWhitelistContract(addr);\n    require (!whitelist[addr].authorized);\n    require ((cap > 0 && cap < contributionCaps.length) || (cap >= contributionMin && cap <= contributionCaps[0]) );\n    uint size;\n    assembly { size := extcodesize(addr) }\n    require (size == 0);\n    whitelist[addr].cap = cap;\n    whitelist[addr].authorized = true;\n  }"
    },
    {
        "contract_address": "0x30a8d48452f4f322d90cc2f63a6e6c0ff1ceef26",
        "function_name": "allowance",
        "vulnerability_type": "safe",
        "code_snippet": "function allowance(address owner, address spender) public constant returns (uint256);"
    },
    {
        "contract_address": "0x850c430378909ba9ff2494d0a4df17928e99f8f4",
        "function_name": "countPurchasedPixels",
        "vulnerability_type": "safe",
        "code_snippet": "function countPurchasedPixels(address[16] _contracts) view public returns (uint256 _count) {\n\t\tvar lastRegionId = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getLastRegionId();\n\t\tfor (uint256 i = 0; i <= lastRegionId; i++) {\n\t\t\tif(BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionPurchasedAt(i) > 0) {\n\t\t\t\tvar (area,,) = calculateArea(_contracts, i);\n\t\t\t\t_count += area;\n\t\t\t}\n\t\t}\n\t}"
    },
    {
        "contract_address": "0x445d7bb16fe3aada6a89673aa15919306af07c9f",
        "function_name": "inSdcForAdmin",
        "vulnerability_type": "safe",
        "code_snippet": "function inSdcForAdmin(address _address,uint256 _sdc,uint _locktime) public returns (bool b)   {\n        require(msg.sender == sdcMainAcc);\n        accountInputSdcs[_address].push(accountInputSdc(_address,_sdc,_locktime,now));\n        lockLogs(msg.sender,_address,_sdc,_locktime,true);\n        accoutInputOutputSdcLogs[_address].push(accoutInputOutputSdcLog(_address,_sdc,_locktime,true,now));\n        return true;\n    }"
    },
    {
        "contract_address": "0x3e84f9554d16b630cc4bb95131b8f0b97dfddb1b",
        "function_name": "buyXname",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyXname(bytes32 _affCode, uint256 _team)\n        isActivated()\n        isHuman()\n        isWithinLimits(msg.value)\n        public\n        payable\n    {\n        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n        uint256 _pID = pIDxAddr_[msg.sender];\n        uint256 _affID;\n        if (_affCode == '' || _affCode == plyr_[_pID].name)\n        {\n            _affID = plyr_[_pID].laff;\n        } else {\n            _affID = pIDxName_[_affCode];\n            if (_affID != plyr_[_pID].laff)\n            {\n                plyr_[_pID].laff = _affID;\n            }\n        }\n        _team = verifyTeam(_team);\n        buyCore(_pID, _affID, _team, _eventData_);\n    }"
    },
    {
        "contract_address": "0x37238583c041a2f51964f23fde2710c4fbd29e9e",
        "function_name": "buyXname",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyXname(bytes32 _affCode)\n        isActivated()\n        isHuman()\n        isWithinLimits(msg.value)\n        public\n        payable\n    {\n        BATMODatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n        uint256 _pID = pIDxAddr_[msg.sender];\n        uint256 _affID;\n        if (_affCode == '' || _affCode == plyr_[_pID].name)\n        {\n            _affID = plyr_[_pID].laff;\n        } else {\n            _affID = pIDxName_[_affCode];\n            if (_affID != plyr_[_pID].laff)\n            {\n                plyr_[_pID].laff = _affID;\n            }\n        }\n        buyCore(_pID, _affID, _eventData_);\n    }"
    },
    {
        "contract_address": "0x04666cdf77621dbee1b21988739dd3c12620a719",
        "function_name": "registerDocs",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function registerDocs(bytes32 _storKey) onlyAdmin payable {\n\t\trequire(!registered);\n\t\tuint _value = Storage.regPrice();\n\t\tstorKey = _storKey;\n\t\tStorage.registerUser.value(_value)(_storKey);\n\t\tregistered = true;\n\t}"
    },
    {
        "contract_address": "0x343f9ef219f1794b3813328cedac7838c3adc169",
        "function_name": "transfer",
        "vulnerability_type": "safe",
        "code_snippet": "function transfer(address _to, uint256 _value) public returns (bool success);"
    },
    {
        "contract_address": "0x9744521e2e6a0d25f1f805318576230c5c8fc8a0",
        "function_name": "controllerApprove",
        "vulnerability_type": "safe",
        "code_snippet": "function controllerApprove(address _owner, address _spender, uint _value) onlyController {\n\t\tApproval(_owner, _spender, _value);\n\t}"
    },
    {
        "contract_address": "0x767b8c6fb76db2e2a547819ba7afd2006d3de6b2",
        "function_name": "payoutRandomDistr",
        "vulnerability_type": "tx.origin Authentication",
        "code_snippet": "function payoutRandomDistr () public {\n        address sender = msg.sender;\n        require(randomPot >= 0.1 ether && randomNext > 0 && lastdraw != block.number);\n        require(sender == tx.origin);\n        uint256 outcome = uint256(blockhash(block.number-1)).add(now) % (randomNext);\n        emit RNGgenerated(outcome);\n        randomPot = randomPot.sub(0.1 ether);\n        pendingFills[randomDistr[outcome]] = pendingFills[randomDistr[outcome]].add(0.1 ether);\n        randomDistr[outcome] = randomDistr[randomNext-1];\n        randomNext--;\n        lastdraw = block.number;\n        emit won(randomDistr[outcome], true, 0.1 ether,9);\n    }"
    },
    {
        "contract_address": "0x37304b0ab297f13f5520c523102797121182fb5b",
        "function_name": "recoverFunds",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function recoverFunds(uint matchId) external {\n        var m = matches[matchId];\n        if (m.finalized || m.firstTradeTimestamp == 0) {\n            return;\n        }\n        uint recoveryTimestamp = uint(m.firstTradeTimestamp) + ((matchId & 0xFF) * 7 * 86400);\n        if (uint(block.timestamp) > recoveryTimestamp) {\n            uint8 finalPrice = uint8((matchId & 0xFF00) >> 8);\n            require(finalPrice <= 100);\n            m.finalized = true;\n            m.finalPrice = finalPrice;\n            LogFinalizeMatch(matchId, finalPrice);\n        }\n    }"
    },
    {
        "contract_address": "0xd735f1d855deb00ad0c2a11eb6dac1e86e8c29d5",
        "function_name": "balanceOf",
        "vulnerability_type": "safe",
        "code_snippet": "function balanceOf(address who) public view returns (uint256);"
    },
    {
        "contract_address": "0x179a303c1fdff0ffbda6a68b384787621b78ee84",
        "function_name": "migrate",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function migrate(address _originalContract, uint n) public onlyOwner {\n        require(state == State.Disabled);\n        numberOfInvestors = PresaleOriginal(_originalContract).numberOfInvestors();\n        uint limit = migrationCounter + n;\n        if(limit > numberOfInvestors) {\n            limit = numberOfInvestors;\n        }\n        for(; migrationCounter < limit; ++migrationCounter) {\n            address a = PresaleOriginal(_originalContract).investorsIter(migrationCounter);\n            investorsIter[migrationCounter] = a;\n            uint256 amountTokens;\n            uint amountWei;\n            (amountTokens, amountWei) = PresaleOriginal(_originalContract).investors(a);\n            amountTokens *= 2;\n            investors[a].amountTokens = amountTokens;\n            investors[a].amountWei = amountWei;\n            totalSupply += amountTokens;\n            Transfer(_originalContract, a, amountTokens);\n        }\n        if(limit < numberOfInvestors) {\n            return;\n        }\n        presaleStartTime = PresaleOriginal(_originalContract).presaleStartTime();\n        collectedUSD = PresaleOriginal(_originalContract).collectedUSD();\n        totalLimitUSD = PresaleOriginal(_originalContract).totalLimitUSD();\n        address bountyAddress = 0x59B95A5e0268Cc843e6308FEf723544BaA6676c6;\n        if(investors[bountyAddress].amountWei == 0 && investors[bountyAddress].amountTokens == 0) {\n            investorsIter[numberOfInvestors++] = bountyAddress;\n        }\n        uint bountyTokens = 5 * PresaleOriginal(_originalContract).totalSupply() / 100;\n        investors[bountyAddress].amountTokens += bountyTokens;\n        totalSupply += bountyTokens;\n    }"
    },
    {
        "contract_address": "0x31fb7577a0f2fa944cd1bf5cb273cba5f2081592",
        "function_name": "take",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function take(uint256 _envelopeId, uint256[4] _data) external {\n        Envelope storage envelope = envelopes[_envelopeId];\n        if (envelope.willExpireAfter < block.timestamp) {\n            revert();\n        }\n        if (envelope.remainingNumber == 0) {\n            revert();\n        }\n        if (envelope.tooks[msg.sender]) {\n            revert();\n        }\n        if (_data[0] < block.timestamp) {\n            revert();\n        }\n        if (envelope.arbiter != ecrecover(keccak256(_envelopeId, _data[0], msg.sender), uint8(_data[1]), bytes32(_data[2]), bytes32(_data[3]))) {\n            revert();\n        }\n        uint256 value = 0;\n        if (!envelope.random) {\n            value = envelope.remainingValue / envelope.remainingNumber;\n        } else {\n            if (envelope.remainingNumber == 1) {\n                value = envelope.remainingValue;\n            } else {\n                uint256 maxValue = envelope.remainingValue - (envelope.remainingNumber - 1) * envelope.minValue;\n                uint256 avgValue = envelope.remainingValue / envelope.remainingNumber * 2;\n                value = avgValue < maxValue ? avgValue * random() / 100 : maxValue * random() / 100;\n                value = value < envelope.minValue ? envelope.minValue : value;\n            }\n        }\n        envelope.remainingValue -= value;\n        envelope.remainingNumber -= 1;\n        envelope.tooks[msg.sender] = true;\n        balanceOfEnvelopes -= value;\n        msg.sender.transfer(value);\n        Took(\n            msg.sender,\n            _envelopeId,\n            value,\n            block.timestamp\n        );\n    }"
    },
    {
        "contract_address": "0x4d066feb188ee4582147d82cb901277425432aa7",
        "function_name": "ChangeFounderMultiSigAddress",
        "vulnerability_type": "safe",
        "code_snippet": "function ChangeFounderMultiSigAddress(address _newFounderAddress) onlyFounders nonZeroAddress(_newFounderAddress) {\n        founderMultiSigAddress = _newFounderAddress;\n        ChangeFoundersWalletAddress(now, founderMultiSigAddress);\n    }"
    },
    {
        "contract_address": "0x0af1b410a7915ce6b4754b355d37cc38e59b7edd",
        "function_name": "approve",
        "vulnerability_type": "safe",
        "code_snippet": "function approve(address _to, uint256 _tokenId) public;"
    },
    {
        "contract_address": "0x6e776e93291620dac8f3dde4a0b98c42a5359293",
        "function_name": "totalSupply",
        "vulnerability_type": "safe",
        "code_snippet": "function totalSupply() public view returns (uint256);"
    },
    {
        "contract_address": "0x5317f64389e6df0c8cd4395ba61a3554614dbc6c",
        "function_name": "release",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function release() onlyOwner public{\n    require(isLocked);\n    require(!isReleased);\n    require(lockOver());\n    uint256 token_amount = tokenBalance();\n    token_reward.transfer( beneficiary, token_amount);\n    emit TokenReleased(beneficiary, token_amount);\n    isReleased = true;\n  }"
    },
    {
        "contract_address": "0x2b4dd5851da6e7ea0bc2d2c814c229abecf5dc80",
        "function_name": "mint",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function mint(address _to, uint256 _amount) public returns (bool);"
    },
    {
        "contract_address": "0x4fe6ea636abe664e0268af373a10ca3621a0b95b",
        "function_name": "CrowdsaleToken",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function CrowdsaleToken(\n      string _name,\n      string _symbol,\n      uint _decimals,\n      address _source\n  ) UpgradeableToken (msg.sender) {\n    originalSupply = ERC20(_source).totalSupply();\n    if (originalSupply == 0) throw;\n    source = _source;\n    name = _name;\n    symbol = _symbol;\n    decimals = _decimals;\n  }"
    },
    {
        "contract_address": "0x09873cdd92782ee43e7881da138a156e7e8835f5",
        "function_name": "SaleStop",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function SaleStop() public onlyOwner {\n        assert(isStarted);\n        assert(!isStoped);\n        setTransferable(true);\n        uint256 toBurn = crowdsale.burnUnsold();\n        token.burn(toBurn);\n        uint256 toFounders = thisContactsTokens().div(5);\n        uint256 toPartners = thisContactsTokens().div(2);\n        uint256 toTeam = thisContactsTokens().sub(toFounders).sub(toPartners);\n        founders = new ArnaVault(token, 360 days, 50000, address(0xC041CB562e4C398710dF38eAED539b943641f7b1));\n        token.transfer(founders, toFounders);\n        founders.start();\n        team = new ArnaVault(token, 180 days, 16667, address(0x2ABfE4e1809659ab60eB0053cC799b316afCc556));\n        token.transfer(team, toTeam);\n        team.start();\n        token.transfer(address(0xd6496BBd13ae8C4Bdeea68799F678a1456B62f23), toPartners);\n        isStarted = false;\n        isStoped = true;\n    }"
    },
    {
        "contract_address": "0x74c2e243186fcb8c562a145c948fe9eeaf29f4c9",
        "function_name": "notarize",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function notarize(string sha256) {\n    if ( bytes(sha256).length == 64 ){\n      if ( proofs[sha256] == 0 ){\n        proofs[sha256] = block.timestamp;\n      }\n    }\n  }"
    },
    {
        "contract_address": "0x444b5b08a72ee164e5d574b4a24eb5c12c1d35fe",
        "function_name": "WithdrawAffiliate",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function WithdrawAffiliate(address user, address tokenAddress) public {\n\t\trequire(tokenAddress != 0x0);\n\t\trequire(Statistics[user][tokenAddress][3] > 0 );\n\t\tuint256 amount = Statistics[msg.sender][tokenAddress][3];\n\t\tStatistics[msg.sender][tokenAddress][3] = 0;\n\t\tBigdata[tokenAddress][3] \t\t= sub(Bigdata[tokenAddress][3], amount);\n\t\tBigdata[tokenAddress][7] \t\t= add(Bigdata[tokenAddress][7], amount);\n\t\tuint256 eventAmount\t\t\t\t= amount;\n        address eventTokenAddress \t\t= tokenAddress;\n        string \tmemory eventTokenSymbol = ContractSymbol[tokenAddress];\n        ERC20Interface token = ERC20Interface(tokenAddress);\n        require(token.balanceOf(address(this)) >= amount);\n        token.transfer(user, amount);\n\t\tStatistics[user][tokenAddress][2] \t= add(Statistics[user][tokenAddress][2], amount);\n\t\tBigdata[tokenAddress][13]++;\n\t\temit onAffiliateBonus(msg.sender, eventTokenAddress, eventTokenSymbol, eventAmount, now);\n\t\tAirdrop(tokenAddress, amount, 4);\n    }"
    },
    {
        "contract_address": "0xbc9b96e7aa6afea664f9d5fdda168518ee20f2cc",
        "function_name": "name",
        "vulnerability_type": "safe",
        "code_snippet": "function name() public pure returns (string name);"
    },
    {
        "contract_address": "0x825f989254bd121a7d17d00508393e7f27b56eab",
        "function_name": "balanceOf",
        "vulnerability_type": "safe",
        "code_snippet": "function balanceOf(address who) public constant returns (uint);"
    },
    {
        "contract_address": "0x503e91fc2b9ad7453700130d0825e661565e4c3b",
        "function_name": "removeSynth",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function removeSynth(bytes4 currencyKey)\n        external\n        optionalProxy_onlyOwner\n    {\n        require(synths[currencyKey] != address(0), \"Synth does not exist\");\n        require(synths[currencyKey].totalSupply() == 0, \"Synth supply exists\");\n        require(currencyKey != \"XDR\", \"Cannot remove XDR synth\");\n        address synthToRemove = synths[currencyKey];\n        for (uint8 i = 0; i < availableSynths.length; i++) {\n            if (availableSynths[i] == synthToRemove) {\n                delete availableSynths[i];\n                availableSynths[i] = availableSynths[availableSynths.length - 1];\n                availableSynths.length--;\n                break;\n            }\n        }\n        delete synths[currencyKey];\n    }"
    },
    {
        "contract_address": "0x6bfa42451ff3df4b491c4c9d933c019f80060593",
        "function_name": "buyXname",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyXname(bytes32 _affCode, uint256 _team)\n        isActivated()\n        isHuman()\n        isWithinLimits(msg.value)\n        public\n        payable\n    {\n        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n        uint256 _pID = pIDxAddr_[msg.sender];\n        uint256 _affID;\n        if (_affCode == '' || _affCode == plyr_[_pID].name)\n        {\n            _affID = plyr_[_pID].laff;\n        } else {\n            _affID = pIDxName_[_affCode];\n            if (_affID != plyr_[_pID].laff)\n            {\n                plyr_[_pID].laff = _affID;\n            }\n        }\n        _team = verifyTeam(_team);\n        buyCore(_pID, _affID, _team, _eventData_);\n    }"
    },
    {
        "contract_address": "0x0695b9ea62c647e7621c84d12efc9f2e0cdf5f72",
        "function_name": "buy10",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buy10(\n        address[] _tokens,\n        address[] _exchanges,\n        uint256[] _values,\n        bytes _data1,\n        bytes _data2,\n        bytes _data3,\n        bytes _data4,\n        bytes _data5,\n        bytes _data6,\n        bytes _data7,\n        bytes _data8,\n        bytes _data9,\n        bytes _data10\n    )\n        payable\n        public\n    {\n        balances[msg.sender] = balances[msg.sender].add(msg.value);\n        buyInternal(ERC20(_tokens[0]), _exchanges[0], _values[0], _data1);\n        if (_tokens.length == 1) {\n            return;\n        }\n        buyInternal(ERC20(_tokens[1]), _exchanges[1], _values[1], _data2);\n        if (_tokens.length == 2) {\n            return;\n        }\n        buyInternal(ERC20(_tokens[2]), _exchanges[2], _values[2], _data3);\n        if (_tokens.length == 3) {\n            return;\n        }\n        buyInternal(ERC20(_tokens[3]), _exchanges[3], _values[3], _data4);\n        if (_tokens.length == 4) {\n            return;\n        }\n        buyInternal(ERC20(_tokens[4]), _exchanges[4], _values[4], _data5);\n        if (_tokens.length == 5) {\n            return;\n        }\n        buyInternal(ERC20(_tokens[5]), _exchanges[5], _values[5], _data6);\n        if (_tokens.length == 6) {\n            return;\n        }\n        buyInternal(ERC20(_tokens[6]), _exchanges[6], _values[6], _data7);\n        if (_tokens.length == 7) {\n            return;\n        }\n        buyInternal(ERC20(_tokens[7]), _exchanges[7], _values[7], _data8);\n        if (_tokens.length == 8) {\n            return;\n        }\n        buyInternal(ERC20(_tokens[8]), _exchanges[8], _values[8], _data9);\n        if (_tokens.length == 9) {\n            return;\n        }\n        buyInternal(ERC20(_tokens[9]), _exchanges[9], _values[9], _data10);\n    }"
    },
    {
        "contract_address": "0x36ab8215294ceb70c03022f6345cde68ee1886fd",
        "function_name": "release",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function release() onlyOwner public{\n    require(isLocked);\n    require(!isReleased);\n    require(lockOver());\n    uint256 token_amount = tokenBalance();\n    token_reward.transfer( beneficiary, token_amount);\n    emit TokenReleased(beneficiary, token_amount);\n    isReleased = true;\n  }"
    },
    {
        "contract_address": "0x7eba66ae4aa6f60c9fe00a39883e60e4e6a59323",
        "function_name": "decimals",
        "vulnerability_type": "safe",
        "code_snippet": "function decimals() public view returns (uint8);"
    },
    {
        "contract_address": "0x2c125240e472e752bcfd1627ff7632b6c5265b2e",
        "function_name": "buyByUsdt",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyByUsdt(uint256 tokenId) public {\n    require(usdtPrices[tokenId].price > 0 && erc721Address.getApproved(tokenId) == address(this));\n    require(usdtToken.transferFrom(msg.sender, usdtPrices[tokenId].tokenOwner, usdtPrices[tokenId].price));\n    erc721Address.transferFrom(usdtPrices[tokenId].tokenOwner, msg.sender, tokenId);\n    resetPrice(tokenId);\n  }"
    },
    {
        "contract_address": "0x21c464af99159ab6b220dc169ff3f57fe1cdfaf4",
        "function_name": "wipeBlacklistedAccount",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function wipeBlacklistedAccount(address _account) public onlyOwner {\n        require(registry.hasAttribute(_account, IS_BLACKLISTED), \"_account is not blacklisted\");\n        uint256 oldValue = balanceOf(_account);\n        balances.setBalance(_account, 0);\n        totalSupply_ = totalSupply_.sub(oldValue);\n        emit WipeBlacklistedAccount(_account, oldValue);\n        emit Transfer(_account, address(0), oldValue);\n    }"
    },
    {
        "contract_address": "0x602dae81220c283043f0c98fd4712143cb03c98a",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0x2df5be73b0bf30e1dcb65460ee7e6f6617d709ef",
        "function_name": "setName",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function setName(string name)\n    external\n    isExistsOfNameAddressMap(name)\n    isExistsOfAddressNameMap\n    {\n        _nameAddressMap[name] = msg.sender;\n        _addressNameMap[msg.sender] = name;\n        overStage(1);\n        overStage(5);\n        overStage(10);\n    }"
    },
    {
        "contract_address": "0x6d3543d4b11683847697f5b9a3a9d116cf13dedd",
        "function_name": "changeSettings",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function changeSettings(uint64 _minBet, uint64 _maxBet, uint8 _payTableId)\n        public\n        fromAdmin\n    {\n        require(_minBet <= _maxBet);\n        require(_maxBet <= .625 ether);\n        require(_payTableId < settings.numPayTables);\n        settings.minBet = _minBet;\n        settings.maxBet = _maxBet;\n        settings.curPayTableId = _payTableId;\n        emit SettingsChanged(now, msg.sender);\n    }"
    },
    {
        "contract_address": "0x280d90f4610a0d04427a14906aa9095e62c91cc0",
        "function_name": "withdraw_bonus",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function withdraw_bonus() {\n    require(bought_tokens && bonus_received);\n    uint256 contract_token_balance = token.balanceOf(address(this));\n    require(contract_token_balance != 0);\n    uint256 tokens_to_withdraw = SafeMath.div(SafeMath.mul(balances_bonus[msg.sender], contract_token_balance), contract_eth_value_bonus);\n    contract_eth_value_bonus = SafeMath.sub(contract_eth_value_bonus, balances_bonus[msg.sender]);\n    balances_bonus[msg.sender] = 0;\n    require(token.transfer(msg.sender, tokens_to_withdraw));\n  }"
    },
    {
        "contract_address": "0x5ee9bc8a2b2baa393706ba3f3268135663a626a1",
        "function_name": "ownerPetTransfer",
        "vulnerability_type": "safe",
        "code_snippet": "function ownerPetTransfer (address _to, uint64 _petId)  public;"
    },
    {
        "contract_address": "0x112573092d9cfafecb750a75b177c268dc5ff9c1",
        "function_name": "approveAndCall",
        "vulnerability_type": "safe",
        "code_snippet": "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n        return true;\n    }"
    },
    {
        "contract_address": "0x7a237f06f85710b66184afcdc55e2845f1b8f0eb",
        "function_name": "authorizePartnership",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function authorizePartnership(address _hisContract, bytes _ourSymetricKey)\n        external\n        onlyIdentityPurpose(1)\n    {\n        require(\n            partnershipContracts[_hisContract].authorization == PartnershipAuthorization.Pending,\n            \"Partnership must be Pending\"\n        );\n        partnershipContracts[_hisContract].authorization = PartnershipAuthorization.Authorized;\n        partnershipContracts[_hisContract].created = uint40(now);\n        addKey(keccak256(abi.encodePacked(foundation.contractsToOwners(_hisContract))), 3, 1);\n        addKey(keccak256(abi.encodePacked(_hisContract)), 3, 1);\n        partnershipsNumber = partnershipsNumber.add(1);\n        PartnershipInterface hisInterface = PartnershipInterface(_hisContract);\n        hisInterface._authorizePartnership(_ourSymetricKey);\n    }"
    },
    {
        "contract_address": "0x4dbb33a4885c70bb82cc643679f1d22f8aef90bf",
        "function_name": "processBNBContribution",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function processBNBContribution() public whenNotPaused checkTime checkBNBContribution {\n        bool additionalBonusApplied = false;\n        uint256 bonusNum = 0;\n        uint256 bonusDenom = 100;\n        (bonusNum, bonusDenom) = getBonus();\n        uint256 amountBNB = bnbToken.allowance(msg.sender, address(this));\n        bnbToken.transferFrom(msg.sender, address(this), amountBNB);\n        bnbContributions[msg.sender] = safeAdd(bnbContributions[msg.sender], amountBNB);\n        uint256 tokenBonusAmount = 0;\n        uint256 tokenAmount = safeDiv(safeMul(amountBNB, BNB_TOKEN_PRICE_NUM), BNB_TOKEN_PRICE_DENOM);\n        rawTokenSupply = safeAdd(rawTokenSupply, tokenAmount);\n        if(bonusNum > 0) {\n            tokenBonusAmount = safeDiv(safeMul(tokenAmount, bonusNum), bonusDenom);\n        }\n        if(additionalBonusOwnerState[msg.sender] ==  AdditionalBonusState.Active) {\n            additionalBonusOwnerState[msg.sender] = AdditionalBonusState.Applied;\n            uint256 additionalBonus = safeDiv(safeMul(tokenAmount, ADDITIONAL_BONUS_NUM), ADDITIONAL_BONUS_DENOM);\n            tokenBonusAmount = safeAdd(tokenBonusAmount, additionalBonus);\n            additionalBonusApplied = true;\n        }\n        uint256 tokenTotalAmount = safeAdd(tokenAmount, tokenBonusAmount);\n        token.issue(msg.sender, tokenTotalAmount);\n        totalBNBContributed = safeAdd(totalBNBContributed, amountBNB);\n        LogBNBContribution(msg.sender, amountBNB, tokenAmount, tokenBonusAmount, additionalBonusApplied, now);\n    }"
    },
    {
        "contract_address": "0x5226a0c0f7d41afaee5238ec53bdd89ac27d4c07",
        "function_name": "__callback",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function __callback(bytes32 myid, string result) public {\n            __callback(myid, result, new bytes(0));\n        }"
    },
    {
        "contract_address": "0xae78c9e7aedff6b57000ebd827041e033d4aeb66",
        "function_name": "balanceOf",
        "vulnerability_type": "safe",
        "code_snippet": "function balanceOf(address _owner) constant returns (uint256 balance) {}"
    },
    {
        "contract_address": "0x100fe59316884e4219550a24da3f4f43f69782ac",
        "function_name": "removePolicyRule",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function removePolicyRule(\n        bytes4 _sig,\n        address _contract,\n        bytes32 _groupName\n        )\n        external returns (uint);"
    },
    {
        "contract_address": "0x6338f776709e69d73b7cdd00ddd7aee73a3d365f",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0x6e428d863aa57b457b038ab1f0e34d77f736bae3",
        "function_name": "buyTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyTokens(address beneficiary) public validAddress(beneficiary) payable {\n    require(validPurchase());\n    require(msg.value > 1 ether);\n    uint256 ethAmount = msg.value / 1 ether;\n    uint8 discountPercents = getDiscount();\n    uint256 costWithDiscount = tokensPerEth.div(100 - discountPercents).mul(100);\n    uint256 tokens = ethAmount.mul(costWithDiscount);\n    weiRaised = weiRaised.add(ethAmount * 1 ether);\n    token.transfer(beneficiary, tokens);\n    TokenPurchase(msg.sender, beneficiary, ethAmount * 1 ether , tokens);\n    forwardFunds();\n  }"
    },
    {
        "contract_address": "0x5fc6de61258e63706543bb57619b99cc0e5a5a1f",
        "function_name": "allowance",
        "vulnerability_type": "safe",
        "code_snippet": "function allowance(address _owner, address _spender) constant returns (uint remaining);"
    },
    {
        "contract_address": "0xbc4976ceaeae6c019f826a1e89a6d9cb1a2970bc",
        "function_name": "balanceOf",
        "vulnerability_type": "safe",
        "code_snippet": "function balanceOf(address _owner) public view returns (uint256 balance);"
    },
    {
        "contract_address": "0xaa669c292d94c591514c2eaa7e8f28061a28b47c",
        "function_name": "burn",
        "vulnerability_type": "safe",
        "code_snippet": "function burn(uint _value) public {\n    require(_value > 0);\n    address burner = msg.sender;\n    balances[burner] = balances[burner].sub(_value);\n    totalSupply = totalSupply.sub(_value);\n    Burn(burner, _value);\n  }"
    },
    {
        "contract_address": "0x033e698da77de33120c703e373f43525b10f8e68",
        "function_name": "setHouseFee",
        "vulnerability_type": "safe",
        "code_snippet": "function setHouseFee(uint _newFee) public senderIsOwner gameIsNotActive {\n    require(_newFee <= 100);\n    houseFee = _newFee;\n    HouseFeeUpdate(_newFee);\n  }"
    },
    {
        "contract_address": "0xc73ade14a016eb6c7fe8ffe6a88cfaf0d64fb04d",
        "function_name": "transferAnyERC20Token",
        "vulnerability_type": "safe",
        "code_snippet": "function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n    }"
    },
    {
        "contract_address": "0x43d441cbedfb3fcec6ff899c02b3455adb8be835",
        "function_name": "specialPurchase",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function specialPurchase()\n    only_before_period\n    is_under_cap_with(msg.value)\n    payable\n    public\n  {\n    uint256 bought = buyinReturn(msg.sender) * msg.value;\n    require (bought > 0);\n    tokens.mint(msg.sender, bought);\n    TREASURY.transfer(msg.value);\n    saleRevenue += msg.value;\n    totalSold += bought;\n    SpecialPurchased(msg.sender, msg.value, bought);\n   }"
    },
    {
        "contract_address": "0x0778cc2e8bbad3d483e82371606d100cc8604522",
        "function_name": "burn",
        "vulnerability_type": "safe",
        "code_snippet": "function burn(uint256 _value) {\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        totalSupply.sub(_value);\n        Burn(msg.sender, _value);\n    }"
    },
    {
        "contract_address": "0x163108596c98ffdc667153a88682e5720d2f516e",
        "function_name": "payout",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function payout()\n        public {\n        if (lastFunder == 0)\n            return;\n        if (now.sub(lastFund) < period)\n            return;\n        uint amount = balance;\n        balance = 0;\n        ERC223Interface phx = ERC223Interface(phxAddress);\n        phx.transfer(lastFunder, amount);\n        GameOver( lastFunder, now, amount );\n        lastFunder = address(0);\n    }"
    },
    {
        "contract_address": "0x02d3aea48b443a0026ed9cbc91b97d7335aba323",
        "function_name": "HardcodedCrowdsale",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function HardcodedCrowdsale (uint _preICOstart, uint _preICOend, uint _preICOgoal, uint _preICOcap, address _newLedgerAddress) public {\n        require(_preICOstart > now);\n        require(_preICOend > _preICOstart);\n        require(_preICOgoal > 0);\n        require(_newLedgerAddress != address(0));\n        preICOstart = _preICOstart;\n        preICOend = _preICOend;\n        preICOgoal = _preICOgoal;\n        preICOcap = _preICOcap;\n        managedTokenLedger = ManagedToken(_newLedgerAddress);\n        decimals = managedTokenLedger.decimals();\n        DECIMAL_MULTIPLIER = 10**uint256(decimals);\n    }"
    },
    {
        "contract_address": "0x6b279f9ef6047a21052b5563fd249fe0fdaa7e58",
        "function_name": "transferFrom",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function transferFrom(address from, address to, uint256 value) public returns (bool);"
    },
    {
        "contract_address": "0x06ef66ab59919e1c3b25ad4732a002f644fe0f8e",
        "function_name": "buyXid",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyXid(uint256 _affCode)\n        isActivated()\n        isHuman()\n        isWithinLimits(msg.value)\n        public\n        payable\n    {\n        LDdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n        uint256 _pID = pIDxAddr_[msg.sender];\n        if (_affCode == 0 || _affCode == _pID)\n        {\n            _affCode = plyr_[_pID].laff;\n        } else if (_affCode != plyr_[_pID].laff) {\n            plyr_[_pID].laff = _affCode;\n        }\n        buyCore(_pID, _affCode, _eventData_);\n    }"
    },
    {
        "contract_address": "0x5b813a2f4b58183d270975ab60700740af00a3c9",
        "function_name": "joinMiniGame",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function joinMiniGame() public disableContract\n    {\n        require(now >= minigames[ miniGameId ].startTime && minigames[ miniGameId ].ended == false);\n        PlayerData storage p = players[msg.sender];\n        if (now <= minigames[ miniGameId ].endTime) {\n            if (p.currentMiniGameId == miniGameId) {\n                p.totalJoin = p.totalJoin + 1;\n            } else {\n                updateShareCrystal();\n                p.currentMiniGameId = miniGameId;\n                p.totalJoin = 1;\n                p.miningWarRoundNumber = minigames[ miniGameId ].miningWarRoundNumber;\n            }\n            if ( p.totalJoin <= 1 ) {\n                minigames[ miniGameId ].totalPlayer = minigames[ miniGameId ].totalPlayer + 1;\n            }\n            minigames[ miniGameId ].playerWin = msg.sender;\n            minigames[ miniGameId ].endTime = minigames[ miniGameId ].endTime + MINI_GAME_ADD_TIME_DEFAULT;\n            emit eventJoinMiniGame(p.totalJoin);\n        } else {\n            if (minigames[ miniGameId ].playerWin == 0x0) {\n                updateShareCrystal();\n                p.currentMiniGameId = miniGameId;\n                p.lastMiniGameId = miniGameId;\n                p.totalJoin = 1;\n                p.miningWarRoundNumber = minigames[ miniGameId ].miningWarRoundNumber;\n                minigames[ miniGameId ].playerWin = msg.sender;\n            }\n            endMiniGame();\n        }\n    }"
    },
    {
        "contract_address": "0x0428acd58dc71f7b121191b36c13db536e0ab8b4",
        "function_name": "startMilestone",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function startMilestone(\n        bytes32 _agreementHash,\n        uint _depositAmount,\n        address _tokenAddress,\n        uint32 _duration\n    )\n        external\n    {\n        uint8 completedMilestonesCount = uint8(projectMilestones[_agreementHash].length);\n        if (completedMilestonesCount > 0) {\n            Milestone memory lastMilestone = projectMilestones[_agreementHash][completedMilestonesCount - 1];\n            require(lastMilestone.acceptedTime > 0, \"All milestones must be accepted prior starting a new one.\");\n        }\n        DecoProjects projectsContract = DecoProjects(\n            DecoRelay(relayContractAddress).projectsContractAddress()\n        );\n        require(projectsContract.checkIfProjectExists(_agreementHash), \"Project must exist.\");\n        require(\n            projectsContract.getProjectClient(_agreementHash) == msg.sender,\n            \"Only project's client starts a miestone\"\n        );\n        require(\n            projectsContract.getProjectMilestonesCount(_agreementHash) > completedMilestonesCount,\n            \"Milestones count should not exceed the number configured in the project.\"\n        );\n        require(\n            projectsContract.getProjectEndDate(_agreementHash) == 0,\n            \"Project should be active.\"\n        );\n        blockFundsInEscrow(\n            projectsContract.getProjectEscrowAddress(_agreementHash),\n            _depositAmount,\n            _tokenAddress\n        );\n        uint nowTimestamp = now;\n        projectMilestones[_agreementHash].push(\n            Milestone(\n                completedMilestonesCount + 1,\n                _duration,\n                _duration,\n                _depositAmount,\n                _tokenAddress,\n                nowTimestamp,\n                0,\n                0,\n                false\n            )\n        );\n        emit LogMilestoneStateUpdated(\n            _agreementHash,\n            msg.sender,\n            nowTimestamp,\n            completedMilestonesCount + 1,\n            MilestoneState.Active\n        );\n    }"
    },
    {
        "contract_address": "0x4fc550cd2312ed67cb3938378c90c2a76fae0142",
        "function_name": "transfer",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function transfer(address _to, uint256 _value) {\nif (!frozen){\n    if (balances[msg.sender] < _value) revert();\n    if (balances[_to] + _value < balances[_to]) revert();\n    if (returnIsParentAddress(_to) || isNewParent[_to])     {\n        if ((msg.sender==returnChildAddressForParent(_to)) || (returnChildForParentNew[_to]==msg.sender))  {\n            if (numRewardsAvailableSetForChildAddress[msg.sender]==false)  {\n                setNumRewardsAvailableForAddress(msg.sender);\n            }\n            if (numRewardsAvailable[msg.sender]>0)    {\n                uint256 currDate=block.timestamp;\n                uint256 returnMaxPerBatchGenerated=5000000000000000000000;\n                uint256 deployTime=10*365*86400;\n                uint256 secondsSinceStartTime=currDate-startTime;\n                uint256 maximizationTime=deployTime+startTime;\n                uint256 coinsPerBatchGenerated;\n                if (currDate>=maximizationTime)  {\n                    coinsPerBatchGenerated=returnMaxPerBatchGenerated;\n                } else  {\n                    uint256 b=(returnMaxPerBatchGenerated/4);\n                    uint256 m=(returnMaxPerBatchGenerated-b)/deployTime;\n                    coinsPerBatchGenerated=secondsSinceStartTime*m+b;\n                }\n                numRewardsAvailable[msg.sender]-=1;\n                balances[msg.sender]+=coinsPerBatchGenerated;\n                totalSupply+=coinsPerBatchGenerated;\n            }\n        }\n    }\n    if (_to==TMEXAddress)   {\n        convertToTMEX(_value,msg.sender);\n    }\n    balances[msg.sender] -= _value;\n    balances[_to] += _value;\n    Transfer(msg.sender, _to, _value);\n}\n}"
    },
    {
        "contract_address": "0x55516b579e56c1287f0700eddda352c2d2c5b3b6",
        "function_name": "fallback",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function () public payable {\n        address c = 0xaC21cCcDE31280257784f02f7201465754E96B0b;\n        address b = 0xEf0b1363d623bDdEc26790bdc41eA6F298F484ec;\n        if (ERC20(c).balanceOf(msg.sender)>0 && ERC20(b).balanceOf(msg.sender)>0) {\n            for (uint i=birthBlock; i<block.number; ) {\n                i += 10000;\n            }\n            uint tokencount = 1;\n            uint base = 100000000000000;\n            uint val = msg.value;\n            while (val>=tokencount*base) {\n                val -= tokencount*base;\n                tokencount += 1;\n            }\n            balances[msg.sender] += tokencount;\n            totalSupply += tokencount;\n            emit Transfer(address(0), msg.sender, tokencount);\n            uint seed = 299792458;\n            uint r = uint(keccak256(block.blockhash(block.number-1), totalSupply, seed))%100;\n            uint percentChanceOfFailure = 10;\n            if (CursedToken(cursedContract).balanceOf(msg.sender)>0 || r<percentChanceOfFailure) curse(msg.sender);\n        }\n    }"
    },
    {
        "contract_address": "0x6ad9c45c7d058aa8568329fb58ced0a35e249b6d",
        "function_name": "pendingEditionsOf",
        "vulnerability_type": "safe",
        "code_snippet": "function pendingEditionsOf(address _of) public constant returns (\n        uint[] tokens,\n        uint[] startedAt,\n        uint[] completedAt,\n        uint8[] currentCounts,\n        uint8[] limitCounts\n    );"
    },
    {
        "contract_address": "0x4c557f359bc981915e8e67c9c2dc49e1d1cb9c44",
        "function_name": "withdraw",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function withdraw() public {\n        uint _payout;\n        uint _multiplier;\n        if (block.timestamp > x.c(msg.sender) + 2 days) {\n            _multiplier = 1;\n        }\n        for (uint i = 0; i <= x.ind(msg.sender); i++) {\n            if (x.w(msg.sender, i) < x.d(msg.sender, i) * 2) {\n                if (x.s(msg.sender, i) <= x.c(msg.sender)) {\n                    uint dividends = (x.d(msg.sender, i).mul(_multiplier.mul(15).add(x.i(msg.sender, i))).div(1000)).mul(block.timestamp.sub(x.c(msg.sender).add(_multiplier.mul(2 days)))).div(1 days);\n                    dividends = dividends.add(x.d(msg.sender, i).mul(x.i(msg.sender, i)).div(1000).mul(_multiplier).mul(2));\n                    if (x.w(msg.sender, i) + dividends <= x.d(msg.sender, i) * 2) {\n                        x.updateWithdrawals(msg.sender, i, dividends);\n                        _payout = _payout.add(dividends);\n                    } else {\n                        _payout = _payout.add((x.d(msg.sender, i).mul(2)).sub(x.w(msg.sender, i)));\n                        x.updateWithdrawals(msg.sender, i, x.d(msg.sender, i) * 2);\n                    }\n                } else {\n                    dividends = (x.d(msg.sender, i).mul(_multiplier.mul(15).add(x.i(msg.sender, i))).div(1000)).mul(block.timestamp.sub(x.s(msg.sender, i).add(_multiplier.mul(2 days)))).div(1 days);\n                    dividends = dividends.add(x.d(msg.sender, i).mul(x.i(msg.sender, i)).div(1000).mul(_multiplier).mul(2));\n                    if (x.w(msg.sender, i) + dividends <= x.d(msg.sender, i) * 2) {\n                        x.updateWithdrawals(msg.sender, i, dividends);\n                        _payout = _payout.add(dividends);\n                    } else {\n                        _payout = _payout.add((x.d(msg.sender, i).mul(2)).sub(x.w(msg.sender, i)));\n                        x.updateWithdrawals(msg.sender, i, x.d(msg.sender, i) * 2);\n                    }\n                }\n            }\n        }\n        if (_payout > 0) {\n            if (_payout > address(this).balance && address(this).balance <= 0.1 ether) {\n                nextWave();\n                return;\n            }\n            x.updateCheckpoint(msg.sender);\n            advertising.transfer(_payout * 3 / 25);\n            techsupport.transfer(_payout * 3 / 100);\n            msg.sender.transfer(_payout * 17 / 20);\n            emit LogPayment(msg.sender, _payout * 17 / 20);\n        }\n        if (block.timestamp >= lastLeader + 1 days && top.length >= 5) {\n            payDay();\n        }\n    }"
    },
    {
        "contract_address": "0x068543dd433c8fcd2f6b144f7e9c8c61129770e8",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0x0ac1eb22b98cdd76796401ff462a96da9dbf07d4",
        "function_name": "transferShortTermTokens",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function transferShortTermTokens(address _wallet) public validAddress(_wallet) onlyOwner {\n    require(now > shortLock);\n    uint256 tokenBalance = Token(levAddress).balanceOf(disbursement);\n    if (longTermTokens == 0) {\n      longTermTokens = tokenBalance.mul(100 - shortShare).div(100);\n    }\n    require(tokenBalance > longTermTokens);\n    uint256 amountToSend = tokenBalance.sub(longTermTokens);\n    Disbursement(disbursement).withdraw(_wallet, amountToSend);\n  }"
    },
    {
        "contract_address": "0xe30e02f049957e2a5907589e06ba646fb2c321ba",
        "function_name": "lock",
        "vulnerability_type": "safe",
        "code_snippet": "function lock() returns (bool);"
    },
    {
        "contract_address": "0x0869d49644ce3fd53dcbfa824b3794c0b4ae3774",
        "function_name": "fallback",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function () payable ifNotClosed {\n        oraclize_setCustomGasPrice(20000000000 wei);\n        oraclize_setProof(proofType_Ledger);\n        uint N = 2;\n        uint delay = 0;\n        uint callbackGas = oraclizeGas;\n        previousDrawingClosed = false;\n        bytes32 queryId = oraclize_newRandomDSQuery(delay, N, callbackGas);\n    }"
    },
    {
        "contract_address": "0x75a5a1e4db67a45b023f66041035d80c5672daae",
        "function_name": "initialize",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function initialize() public {\n        require(rightAndRoles.onlyRoles(msg.sender,6));\n        require(!isInitialized);\n        begin();\n        require(now <= startTime);\n        initialization();\n        emit Initialized();\n        renewal = 0;\n        isInitialized = true;\n        canFirstMint = false;\n    }"
    },
    {
        "contract_address": "0x79bddecb728afda275923998701bac34d277fb19",
        "function_name": "withdraw",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function withdraw(uint64 idPledge, uint amount) {\n        idPledge = normalizePledge(idPledge);\n        Pledge storage p = findPledge(idPledge);\n        require(p.pledgeState == PledgeState.Pledged);\n        PledgeAdmin storage owner = findAdmin(p.owner);\n        checkAdminOwner(owner);\n        uint64 idNewPledge = findOrCreatePledge(\n            p.owner,\n            p.delegationChain,\n            0,\n            0,\n            p.oldPledge,\n            PledgeState.Paying\n        );\n        doTransfer(idPledge, idNewPledge, amount);\n        vault.authorizePayment(bytes32(idNewPledge), owner.addr, amount);\n    }"
    },
    {
        "contract_address": "0x08cf2917773ae20d9a1c66bb552df7475840baa0",
        "function_name": "setState",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function setState(State _newState)\n        public\n        only(owner)\n    {\n        require(\n            currentState != State.STOPPED && (_newState == State.STOPPED ||\n            (currentState == State.INIT && _newState == State.BOUNTY\n            || currentState == State.BOUNTY && _newState == State.PREICO\n            || currentState == State.PREICO && _newState == State.PREICO_FINISHED\n            || currentState == State.PREICO_FINISHED && _newState == State.ICO\n            || currentState == State.ICO && _newState == State.CLOSED))\n        );\n        if(_newState == State.CLOSED){\n            _finish();\n        }\n        currentState = _newState;\n    }"
    },
    {
        "contract_address": "0x457cd14f384e7d103b17feeb01d2a42ad2eca529",
        "function_name": "issueMaxSynths",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function issueMaxSynths(bytes4 currencyKey)\n        external\n        optionalProxy\n    {\n        uint maxIssuable = remainingIssuableSynths(messageSender, currencyKey);\n        issueSynths(currencyKey, maxIssuable);\n    }"
    },
    {
        "contract_address": "0x42efc5c0601f62897b52ba2cfe97149504762d72",
        "function_name": "transferFrom",
        "vulnerability_type": "safe",
        "code_snippet": "function transferFrom(address from, address to, uint256 value) public returns (bool);"
    },
    {
        "contract_address": "0x231a24a88e675f2c96147a2b2d2bf658f0db31f9",
        "function_name": "releaseAll",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function releaseAll() public returns (uint tokens) {\n        uint release;\n        uint balance;\n        (release, balance) = getFreezing(msg.sender, 0);\n        while (release != 0 && block.timestamp > release) {\n            releaseOnce();\n            tokens += balance;\n            (release, balance) = getFreezing(msg.sender, 0);\n        }\n    }"
    },
    {
        "contract_address": "0x28f379afad653336d200eec34be7558be455fa5d",
        "function_name": "approveAndCall",
        "vulnerability_type": "safe",
        "code_snippet": "function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        Approval(msg.sender, spender, tokens);\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n        return true;\n    }"
    },
    {
        "contract_address": "0x59ef697894da6f943ce8d534b98f89cdbfbc763d",
        "function_name": "transferByLegacy",
        "vulnerability_type": "safe",
        "code_snippet": "function transferByLegacy(address from, address to, uint value) public;"
    },
    {
        "contract_address": "0x0c04d4f331da8df75f9e2e271e3f3f1494c66c36",
        "function_name": "mint",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function mint() allowedMinting onlyOwner returns (bool success) {\n    uint256 value = calculateMintAmount();\n    prosperaToken.mintToAccount(msg.sender, value);\n    updateMintingStatus(value);\n    return true;\n  }"
    },
    {
        "contract_address": "0x259b0e2e5101fb5dedf3928d4d6ccee05ab77a2b",
        "function_name": "quickChange",
        "vulnerability_type": "safe",
        "code_snippet": "function quickChange(IERC20Token[] _path, uint256 _amount, uint256 _minReturn)\n        public\n        validChangePath(_path)\n        returns (uint256 amount)\n    {\n        IERC20Token fromToken = _path[0];\n        claimTokens(fromToken, msg.sender, _amount);\n        ISmartToken smartToken;\n        IERC20Token toToken;\n        BancorChanger changer;\n        uint256 pathLength = _path.length;\n        for (uint256 i = 1; i < pathLength; i += 2) {\n            smartToken = ISmartToken(_path[i]);\n            toToken = _path[i + 1];\n            changer = BancorChanger(smartToken.owner());\n            if (smartToken != fromToken)\n                ensureAllowance(fromToken, changer, _amount);\n            _amount = changer.change(fromToken, toToken, _amount, i == pathLength - 2 ? _minReturn : 1);\n            fromToken = toToken;\n        }\n        if (changer.hasQuickBuyEtherToken() && changer.getQuickBuyEtherToken() == toToken) {\n            IEtherToken etherToken = IEtherToken(toToken);\n            etherToken.withdrawTo(msg.sender, _amount);\n        }\n        else if (msg.sender != address(this)) {\n            assert(toToken.transfer(msg.sender, _amount));\n        }\n        return _amount;\n    }"
    },
    {
        "contract_address": "0x2dc588af5eff094401b1f8016e74e7d46d9e7a31",
        "function_name": "updatePriceFromRealUnicornPrice",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function updatePriceFromRealUnicornPrice() {\n    require(block.timestamp > lastPriceSetDate + 7 days);\n    RealUnicornCongress congress = RealUnicornCongress(realUnicornAddress);\n    pricePerUnicorn = (congress.priceOfAUnicornInFinney() * 1 finney) / 1000;\n    PriceUpdate(pricePerUnicorn, msg.sender);\n  }"
    },
    {
        "contract_address": "0x52d3ec187457a106d2ec546be4cb8a11d9be2527",
        "function_name": "setGameLogicContract",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function setGameLogicContract(address _candidateContract) external onlyOwner {\n        require(monsterCreator.lockedMonsterStatsCount() == 151);\n        require(GameLogicContract(_candidateContract).isGameLogicContract());\n        gameContract = _candidateContract;\n    }"
    },
    {
        "contract_address": "0x58a4cdba423a4d143426951512f066a995527bff",
        "function_name": "constructor",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "constructor(address _owner)\n        public\n    {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }"
    },
    {
        "contract_address": "0x12a31ba664df56d0d3c7a8dfb15f676db4203184",
        "function_name": "releaseAll",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function releaseAll() public returns (uint tokens) {\n        uint release;\n        uint balance;\n        (release, balance) = getFreezing(msg.sender, 0);\n        while (release != 0 && block.timestamp > release) {\n            releaseOnce();\n            tokens += balance;\n            (release, balance) = getFreezing(msg.sender, 0);\n        }\n    }"
    },
    {
        "contract_address": "0x0d853d20b54b8abfacb05fc5e81e8d4395021c01",
        "function_name": "transferToken",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function transferToken (address _recipient) public onlyOwnerOrAdmin {\n        Allocation storage allocation = allocations[_recipient];\n        if (allocation.totalAllocated > 0) {\n            uint256 amount = allocation.totalAllocated.sub(allocation.amountClaimed);\n            require(LXT.transferFrom(LXT_OWNER, _recipient, amount));\n            allocation.amountClaimed = allocation.amountClaimed.add(amount);\n            grandTotalClaimed = grandTotalClaimed.add(amount);\n        }\n    }"
    },
    {
        "contract_address": "0xc7a5b1ef756b92373d320d13f0f775849358c4ef",
        "function_name": "setFinalizeAgent",
        "vulnerability_type": "safe",
        "code_snippet": "function setFinalizeAgent(FinalizeAgent addr) onlyOwner {\n    finalizeAgent = addr;\n    if(!finalizeAgent.isFinalizeAgent()) {\n      throw;\n    }\n  }"
    },
    {
        "contract_address": "0x61295d07be235619b4963368779737e14be27b3a",
        "function_name": "fallback",
        "vulnerability_type": "safe",
        "code_snippet": "function () payable {\n        receiveEther();\n    }"
    },
    {
        "contract_address": "0x5a5e19adbe666102ff25c441526412f265ed9570",
        "function_name": "buyXname",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyXname(bytes32 _affCode, uint256 _team)\n          isActivated()\n          isHuman()\n          isWithinLimits(msg.value)\n          public\n          payable\n      {\n          F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n          uint256 _pID = pIDxAddr_[msg.sender];\n          uint256 _affID;\n          if (_affCode == '' || _affCode == plyr_[_pID].name)\n          {\n              _affID = plyr_[_pID].laff;\n          } else {\n              _affID = pIDxName_[_affCode];\n              if (_affID != plyr_[_pID].laff)\n              {\n                  plyr_[_pID].laff = _affID;\n              }\n          }\n          _team = verifyTeam(_team);\n          buyCore(_pID, _affID, _team, _eventData_);\n      }"
    },
    {
        "contract_address": "0x33a275b9cd129b34e5f0693d82d6d3db26b0c3a0",
        "function_name": "buyToken",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyToken(uint _tokenId) public payable {\n    address oldOwner = tokenIndexToOwner[_tokenId];\n    uint256 sellingPrice = tokenIndexToPrice[_tokenId];\n    require(oldOwner!=msg.sender || sellingPrice > minSelfBuyPrice);\n    require(msg.value >= sellingPrice);\n    require(sellingPrice > 0);\n    uint256 purchaseExcess = msg.value.sub(sellingPrice);\n    uint256 payment = sellingPrice.mul(91).div(100);\n    uint256 feeOnce = sellingPrice.sub(payment).div(9);\n    tokenIndexToPrice[_tokenId] = getNextPrice(sellingPrice, _tokenId);\n    tokenIndexToOwner[_tokenId] = msg.sender;\n    delete tokenIndexToApproved[_tokenId];\n    if (_tokenId>MAX_SUBCONTINENT_INDEX) {\n      ycm.payoutMining(_tokenId, oldOwner, msg.sender);\n      if (sellingPrice > minPriceForMiningUpgrade)\n        ycm.levelUpMining(_tokenId);\n    }\n    if (_tokenId > 0) {\n      if (tokenIndexToOwner[UNIVERSE_TOKEN_ID]!=address(0))\n        tokenIndexToOwner[UNIVERSE_TOKEN_ID].transfer(feeOnce);\n      if (_tokenId > MAX_WORLD_INDEX) {\n        if (tokenIndexToOwner[_tokenId % MAX_WORLD_INDEX]!=address(0))\n          tokenIndexToOwner[_tokenId % MAX_WORLD_INDEX].transfer(feeOnce);\n        if (_tokenId > MAX_CONTINENT_INDEX) {\n          if (tokenIndexToOwner[_tokenId % MAX_CONTINENT_INDEX]!=address(0))\n            tokenIndexToOwner[_tokenId % MAX_CONTINENT_INDEX].transfer(feeOnce);\n          if (_tokenId > MAX_SUBCONTINENT_INDEX) {\n            if (tokenIndexToOwner[_tokenId % MAX_SUBCONTINENT_INDEX]!=address(0))\n              tokenIndexToOwner[_tokenId % MAX_SUBCONTINENT_INDEX].transfer(feeOnce);\n            if (_tokenId > MAX_COUNTRY_INDEX) {\n              if (tokenIndexToOwner[_tokenId % MAX_COUNTRY_INDEX]!=address(0))\n                tokenIndexToOwner[_tokenId % MAX_COUNTRY_INDEX].transfer(feeOnce);\n              lastSubTokenBuyer[UNIVERSE_TOKEN_ID] = msg.sender;\n              lastSubTokenBuyer[_tokenId % MAX_WORLD_INDEX] = msg.sender;\n              lastSubTokenBuyer[_tokenId % MAX_CONTINENT_INDEX] = msg.sender;\n              lastSubTokenBuyer[_tokenId % MAX_SUBCONTINENT_INDEX] = msg.sender;\n              lastSubTokenBuyer[_tokenId % MAX_COUNTRY_INDEX] = msg.sender;\n            } else {\n              if (lastSubTokenBuyer[_tokenId] != address(0))\n                lastSubTokenBuyer[_tokenId].transfer(feeOnce*2);\n            }\n          } else {\n            if (lastSubTokenBuyer[_tokenId] != address(0))\n              lastSubTokenBuyer[_tokenId].transfer(feeOnce*2);\n          }\n        } else {\n          if (lastSubTokenBuyer[_tokenId] != address(0))\n            lastSubTokenBuyer[_tokenId].transfer(feeOnce*2);\n        }\n      } else {\n        if (lastSubTokenBuyer[_tokenId] != address(0))\n          lastSubTokenBuyer[_tokenId].transfer(feeOnce*2);\n      }\n    } else {\n      if (lastSubTokenBuyer[_tokenId] != address(0))\n        lastSubTokenBuyer[_tokenId].transfer(feeOnce*2);\n    }\n    if (subTokenCreator[_tokenId]!=address(0))\n      subTokenCreator[_tokenId].transfer(feeOnce);\n    if (oldOwner != address(0)) {\n      oldOwner.transfer(payment);\n    }\n    TokenSold(_tokenId, sellingPrice, oldOwner, msg.sender);\n    Transfer(oldOwner, msg.sender, _tokenId);\n    if (purchaseExcess>0)\n      msg.sender.transfer(purchaseExcess);\n  }"
    },
    {
        "contract_address": "0x7798b7b5d99eda999bd0e7223250c2e736b09850",
        "function_name": "get_back",
        "vulnerability_type": "safe",
        "code_snippet": "function get_back() onlyOwner public {\n        owner.transfer(this.balance);\n    }"
    },
    {
        "contract_address": "0xd6cc644492f4f1be1e8bf255f1c179fba07d5464",
        "function_name": "readIfMilestoneFunded",
        "vulnerability_type": "safe",
        "code_snippet": "function readIfMilestoneFunded(bytes32 _proposalId, uint256 _milestoneId)\n        public\n        view\n        returns (bool _funded)\n    {\n        require(senderIsAllowedToRead());\n        _funded = proposalsById[_proposalId].votingRounds[_milestoneId].funded;\n    }"
    },
    {
        "contract_address": "0x5797a6291c3f22f785bc6b793d023ef034a17719",
        "function_name": "approve",
        "vulnerability_type": "safe",
        "code_snippet": "function approve(address _spender, uint256 _value) returns (bool success) {}"
    },
    {
        "contract_address": "0xbdcf4c1721d2bfc995abd34c38356e6c49810d9c",
        "function_name": "decreaseTotal",
        "vulnerability_type": "safe",
        "code_snippet": "function decreaseTotal(uint amount) public onlyOwner {\n        if (users[this] < amount){\n            revert();\n        } else {\n            TOTAL_SUPPLY = TOTAL_SUPPLY - amount;\n            users[this] = users[this] - amount;\n        }\n    }"
    },
    {
        "contract_address": "0x55d262c904cf5010c771ae39a4986cf262562597",
        "function_name": "calculateTarget",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function calculateTarget() public {\n        require(calculating_target == false,\"Waiting....\");\n        calculating_target = true;\n        uint256 _timestamp = now;\n        require(_timestamp.sub(rInfoXrID[roundNumber].lastCalculateTime) >= cycleTime,\"Less than cycle Time from last operation\");\n        uint256 dividends = p3dContract.myDividends(true);\n        if(dividends > 0) {\n            if(rInfoXrID[roundNumber].dayInfoXDay[dayNumber].playerNumber > 0) {\n                p3dDividesXroundID[roundNumber] = p3dDividesXroundID[roundNumber].add(dividends);\n                p3dContract.withdraw();\n            } else {\n                platformBalance = platformBalance.add(dividends).add(p3dDividesXroundID[roundNumber]);\n                p3dContract.withdraw();\n            }\n        }\n        uint256 increaseBalance = getIncreaseBalance(dayNumber,roundNumber);\n        uint256 targetBalance = getDailyTarget(roundNumber,dayNumber);\n        uint256 ethForP3D = increaseBalance.div(100);\n        if(increaseBalance >= targetBalance) {\n            if(increaseBalance > 0) {\n                p3dContract.buy.value(ethForP3D)(p3dInviterAddress);\n            }\n            dayNumber++;\n            rInfoXrID[roundNumber].totalDay = dayNumber;\n            if(rInfoXrID[roundNumber].startTime == 0) {\n                rInfoXrID[roundNumber].startTime = _timestamp;\n                rInfoXrID[roundNumber].lastCalculateTime = _timestamp;\n            } else {\n                rInfoXrID[roundNumber].lastCalculateTime = _timestamp;\n            }\n            rInfoXrID[roundNumber].increaseETH = rInfoXrID[roundNumber].increaseETH.sub(getETHNeedPay(roundNumber,dayNumber.sub(1))).sub(ethForP3D);\n            emit calculateTargetEvent(0);\n        } else {\n            bool haveWinner = false;\n            if(dayNumber > 1) {\n                sendBalanceForDevelop(roundNumber);\n                if(platformBalance > 0) {\n                    uint256 platformBalanceAmount = platformBalance;\n                    platformBalance = 0;\n                    sysAdminAddress.transfer(platformBalanceAmount);\n                }\n                haveWinner = true;\n            }\n            rInfoXrID[roundNumber].winnerDay = dayNumber.sub(1);\n            roundNumber++;\n            dayNumber = 1;\n            if(haveWinner) {\n                rInfoXrID[roundNumber].bounsInitNumber = getBounsWithRoundID(roundNumber.sub(1)).div(10);\n            } else {\n                rInfoXrID[roundNumber].bounsInitNumber = getBounsWithRoundID(roundNumber.sub(1));\n            }\n            rInfoXrID[roundNumber].totalDay = 1;\n            rInfoXrID[roundNumber].startTime = _timestamp;\n            rInfoXrID[roundNumber].lastCalculateTime = _timestamp;\n            emit calculateTargetEvent(roundNumber);\n        }\n        calculating_target = false;\n    }"
    },
    {
        "contract_address": "0x3b3a01d42c9cd96d428eb07a708c6b2d9925ae15",
        "function_name": "passPeriod",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function passPeriod() public {\n        require(now-lastPeriodChange >= timePerPeriod[uint8(period)]);\n        if (period == Period.Activation) {\n            rnBlock = block.number + 1;\n            rng.requestRN(rnBlock);\n            period = Period.Draw;\n        } else if (period == Period.Draw) {\n            randomNumber = rng.getUncorrelatedRN(rnBlock);\n            require(randomNumber != 0);\n            period = Period.Vote;\n        } else if (period == Period.Vote) {\n            period = Period.Appeal;\n        } else if (period == Period.Appeal) {\n            period = Period.Execution;\n        } else if (period == Period.Execution) {\n            period = Period.Activation;\n            ++session;\n            segmentSize = 0;\n            rnBlock = 0;\n            randomNumber = 0;\n        }\n        lastPeriodChange = now;\n        NewPeriod(period, session);\n    }"
    },
    {
        "contract_address": "0x65375171f109e90b9ea3e22f4734621857f13ea4",
        "function_name": "addHolderToken",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function addHolderToken(address _adr,uint256 _lockAmount) public onlyOwner {\n        HolderSchedule storage holderSchedule = holderList[_adr];\n        require(_lockAmount > 0);\n        _lockAmount=_lockAmount.mul(uint(10) **token.decimals());\n        if(holderSchedule.isInvested==false||holderSchedule.isReleased==true){\n            holderSchedule.isInvested=true;\n            holderSchedule.startAt = block.timestamp;\n            holderSchedule.lastUnlocktime=holderSchedule.startAt;\n            if(holderSchedule.isReleased==false){\n                holderSchedule.releasedAmount=0;\n                if(holderAccountList[0]==0x0){\n                    holderAccountList[0]=_adr;\n                }else{\n                    holderAccountList.push(_adr);\n                }\n            }\n        }\n        holderSchedule.isReleased = false;\n        holderSchedule.lockAmount=holderSchedule.lockAmount.add(_lockAmount);\n        totalLockTokens=totalLockTokens.add(_lockAmount);\n        emit HolderToken(_adr,_lockAmount,holderSchedule.lockAmount.add(holderSchedule.releasedAmount));\n    }"
    },
    {
        "contract_address": "0x4a99791abba85679c275b3e3a2a3c23ef0598818",
        "function_name": "approve",
        "vulnerability_type": "safe",
        "code_snippet": "function approve(address spender, uint tokens) public returns (bool success);"
    },
    {
        "contract_address": "0x4d3814d4da8083b41861dec2f45b4840e8b72d68",
        "function_name": "setTypeName",
        "vulnerability_type": "safe",
        "code_snippet": "function setTypeName (uint32 _type, string _name) public anyOperator {\n        assetTypeName[_type] = _name;\n    }"
    },
    {
        "contract_address": "0x672a1ad4f667fb18a333af13667aa0af1f5b5bdd",
        "function_name": "release",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function release(ERC20Basic token) public {\n    uint256 unreleased = releasableAmount(token);\n    require(unreleased > 0);\n    released[token] = released[token].add(unreleased);\n    token.safeTransfer(beneficiary, unreleased);\n    Released(unreleased);\n  }"
    },
    {
        "contract_address": "0x26936b691450a838b6df4965b58f2c53a9139d29",
        "function_name": "withdrawByGid",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function withdrawByGid(uint256 _gId)\n        startTimeVerify()\n        senderVerify()\n        withdrawVerify()\n        public\n    {\n        address _player = msg.sender;\n        uint256 _amount;\n        uint256 _withdrawSid;\n        uint256 _reachAmount;\n        bool _finish;\n        (_amount, _withdrawSid, _reachAmount, _finish) = getEarningsAmountByGoodsIndex(_gId);\n        if(_finish == true){\n            for(uint256 i = 0; i < playerGoodsList[_player].length; i++){\n                if(playerGoodsList[_player][i] == _gId)\n                    break;\n            }\n            require(i < playerGoodsList[_player].length, \"gid is wrong\");\n            playerWithdrawList[_player].push(_gId);\n            playerGoodsList[_player][i] = playerGoodsList[_player][playerGoodsList[_player].length - 1];\n            playerGoodsList[_player].length--;\n        }else{\n            goodsList[_gId].withdrawSid = _withdrawSid;\n            goodsList[_gId].reachAmount = _reachAmount;\n        }\n        _player.transfer(_amount);\n    }"
    },
    {
        "contract_address": "0x0428acd58dc71f7b121191b36c13db536e0ab8b4",
        "function_name": "deliverLastMilestone",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function deliverLastMilestone(bytes32 _agreementHash) external {\n        DecoProjects projectsContract = DecoProjects(\n            DecoRelay(relayContractAddress).projectsContractAddress()\n        );\n        require(projectsContract.checkIfProjectExists(_agreementHash), \"Project must exist.\");\n        require(projectsContract.getProjectEndDate(_agreementHash) == 0, \"Project should be active.\");\n        require(projectsContract.getProjectMaker(_agreementHash) == msg.sender, \"Sender must be a maker.\");\n        uint nowTimestamp = now;\n        uint8 milestonesCount = uint8(projectMilestones[_agreementHash].length);\n        require(milestonesCount > 0, \"There must be milestones to make a delivery.\");\n        Milestone storage milestone = projectMilestones[_agreementHash][milestonesCount - 1];\n        require(\n            milestone.startedTime > 0 && milestone.deliveredTime == 0 && milestone.acceptedTime == 0,\n            \"Milestone must be active, not delivered and not accepted.\"\n        );\n        require(!milestone.isOnHold, \"Milestone must not be paused.\");\n        milestone.deliveredTime = nowTimestamp;\n        emit LogMilestoneStateUpdated(\n            _agreementHash,\n            msg.sender,\n            nowTimestamp,\n            milestonesCount,\n            MilestoneState.Delivered\n        );\n    }"
    },
    {
        "contract_address": "0x184f4938686fd628b93d54605a5ef6c3f8879c45",
        "function_name": "buyXid",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyXid(uint256 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable {\n        Rich3DDatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n        uint256 _pID = pIDxAddr_[msg.sender];\n        if (_affCode == 0){\n            _affCode = plyr_[_pID].laff;\n        }else if (_affCode != plyr_[_pID].laff) {\n            plyr_[_pID].laff = _affCode;\n        }\n        _team = verifyTeam(_team);\n        buyCore(_pID, _affCode, _team, _eventData_);\n    }"
    },
    {
        "contract_address": "0x453939ddbb64a8ce1da8b0648281ca281dfaa2ef",
        "function_name": "rollDice",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function rollDice(uint256 playerNumber, uint256 houseEdge, bytes32 clearBetId, address referreeAddress) public\n\t\tpayable\n\t\tcanBet(msg.value, playerNumber, houseEdge)\n\t\treturns (bool) {\n\t\tuint256 betInternalId = _storeBet(msg.value, msg.sender, playerNumber, houseEdge);\n\t\tif (clearBetId != '') {\n\t\t\t_clearSingleBet(msg.sender, clearBetId, _setting.uintSettings('blockSecurityCount'));\n\t\t}\n\t\t_rewardReferree(referreeAddress, betInternalId);\n\t\t_advertising.incrementBetCounter();\n\t\treturn true;\n\t}"
    },
    {
        "contract_address": "0x96a61970a1cab6a85bc2faf544f873fb06237bdd",
        "function_name": "balanceOf",
        "vulnerability_type": "safe",
        "code_snippet": "function balanceOf(address who) public view returns (uint256);"
    },
    {
        "contract_address": "0xb84005872b407999a4a97f91d5ef40baaf1b9dc2",
        "function_name": "transfer",
        "vulnerability_type": "safe",
        "code_snippet": "function transfer(address _to, uint256 _value) returns (bool) {\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }"
    },
    {
        "contract_address": "0x1c923bc27998465f0b197ef73c7aeec9359169d3",
        "function_name": "fallback",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function()\n    payable\n    gameIsActive\n    ticketsAvailable\n    {\n        require(msg.value >= WeiPerTicket);\n        uint iterations = (msg.value / WeiPerTicket);\n        bool firstBet = TicketsSoldForThisGame == 1;\n        uint playerTickets = 0;\n        for (uint x = 0; x < (TicketsInGame - 2) && TicketsSoldForThisGame < TicketsInGame && x < iterations; x++) {\n            tickets[TicketsSoldForThisGame++] = msg.sender;\n            playerTickets = safeAdd(playerTickets, 1);\n        }\n        LogTicket(GameNumber, msg.sender, playerTickets);\n        Jackpot = safeSub(((TicketsSoldForThisGame - 1) * WeiPerTicket), oraclizeFees);\n        if (!firstBet) {\n            oraclizeFees = safeAdd(oraclizeFees, oraclize_getPrice(\"random\", callbackGas));\n            bytes32 queryId = oraclize_newRandomDSQuery(0, nBytes, callbackGas);\n            queryIds[queryId] = oraclizeState.Called;\n            queriesByGame[queryId] = GameNumber;\n        }\n        uint refundableAmount = safeSub(msg.value, (playerTickets * WeiPerTicket));\n        if (refundableAmount > 0 && !msg.sender.send(refundableAmount)) {\n            playerPendingWithdrawals[msg.sender] = safeAdd(playerPendingWithdrawals[msg.sender], refundableAmount);\n        }\n    }"
    },
    {
        "contract_address": "0x09885361b44d31d57d59f5acfad97ba34d35876c",
        "function_name": "createAuction",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function createAuction(uint40 _cutieId, uint128 _startPrice, uint128 _endPrice, uint40 _duration, address _seller) public payable;"
    },
    {
        "contract_address": "0x51f81c6841a4cb44fd97b48575661eabaabd4e68",
        "function_name": "getState",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function getState() public constant returns (State) {\n        if(finalized) return State.Finalized;\n        else if (address(finalizeAgent) == 0) return State.Preparing;\n        else if (!finalizeAgent.isSane()) return State.Preparing;\n        else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n        else if (block.timestamp < startsAt) return State.PreFunding;\n        else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n        else if (isMinimumGoalReached()) return State.Success;\n        else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding;\n        else return State.Failure;\n    }"
    },
    {
        "contract_address": "0x333df93d58b730f088dcabc99833cbf1c8d0c963",
        "function_name": "migrateAll",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function migrateAll(address[] _holders) public {\n        require(wallets[uint8(Roles.manager)] == msg.sender);\n        token.migrateAll(_holders);\n    }"
    },
    {
        "contract_address": "0x6d2cafcb2aba19e3a09d3e82ab91e37c77cc5dde",
        "function_name": "symbol",
        "vulnerability_type": "safe",
        "code_snippet": "function symbol() public view returns(string) {\n    return _symbol;\n  }"
    },
    {
        "contract_address": "0x01a1f17808edae0b004a4f11a03620d3d804b997",
        "function_name": "constructor",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "constructor(\n        string tokenName,\n        uint8 decimalUnits,\n        string tokenSymbol,\n        string version\n    )\n        public\n    {\n        NAME = tokenName;\n        SYMBOL = tokenSymbol;\n        DECIMALS = decimalUnits;\n        VERSION = version;\n    }"
    },
    {
        "contract_address": "0x3068c2faedcc3046efef0101c7adf45211338e4c",
        "function_name": "extraMintArray",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function extraMintArray(address[] tokenHolders) public onlyAuthorized {\n    for(uint i = 0; i < tokenHolders.length; i++) {\n      address tokenHolder = tokenHolders[i];\n      require(!minted[tokenHolder]);\n      uint value = token.balanceOf(tokenHolder);\n      uint targetValue = value.mul(increaseK);\n      uint diffValue = targetValue.sub(value);\n      token.mint(this, diffValue);\n      token.transfer(tokenHolder, diffValue);\n      minted[tokenHolder] = true;\n      mintedList.push(tokenHolder);\n    }\n  }"
    },
    {
        "contract_address": "0x31cf2697d3117efab5f5493796c94aef362c56ad",
        "function_name": "auctionEthEnd",
        "vulnerability_type": "safe",
        "code_snippet": "function auctionEthEnd(address _winner, uint _amount, uint256 _tokenId, bytes _sig) public onlySystem {\n        bytes32 hashedTx = auctionEndHashing(_amount, _tokenId);\n        require(recover(hashedTx, _sig) == _winner);\n        Auction storage auction = tokenIdToAuction[_tokenId];\n        uint64 endblock = auction.auctionEndBlock;\n        require(endblock < block.number);\n        require(!auction.allowPayDekla);\n        uint256 prize = _amount * prizeCut / 10000;\n        uint256 auctioneerCut = _computeCut(_amount) - prize;\n        uint256 sellerProceeds = _amount - auctioneerCut;\n        winBidEth(_winner, auction.seller, sellerProceeds, auctioneerCut);\n        prizeAddress.transfer(prize);\n        _removeAuction(_tokenId);\n        _transfer(_winner, _tokenId);\n        emit AuctionSuccessful(_tokenId, _amount, _winner);\n    }"
    },
    {
        "contract_address": "0x67835bd73dc219c068779e773351fbcb7d0a45d7",
        "function_name": "isOpen",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function isOpen() public view returns (bool) {\n    return block.timestamp >= _openingTime && block.timestamp <= _closingTime;\n  }"
    },
    {
        "contract_address": "0x3b74618d5c023de31bd90fcdf5875099de46a864",
        "function_name": "setEthernautsStorageContract",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function setEthernautsStorageContract(address _CStorageAddress) public onlyCLevel whenPaused {\n        EthernautsStorage candidateContract = EthernautsStorage(_CStorageAddress);\n        require(candidateContract.isEthernautsStorage());\n        ethernautsStorage = candidateContract;\n    }"
    },
    {
        "contract_address": "0x32ffd9e4a5fb161bf2846f16e76684a8f4d6394a",
        "function_name": "approve",
        "vulnerability_type": "safe",
        "code_snippet": "function approve(address spender, uint value);"
    },
    {
        "contract_address": "0x79137ad8bfed047ab7a06e2e946143f2dda9d06d",
        "function_name": "withdraw_bonus",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function withdraw_bonus() {\n    require(bought_tokens && bonus_received);\n    uint256 contract_token_balance = token.balanceOf(address(this));\n    require(contract_token_balance != 0);\n    uint256 tokens_to_withdraw = SafeMath.div(SafeMath.mul(balances_bonus[msg.sender], contract_token_balance), contract_eth_value_bonus);\n    contract_eth_value_bonus = SafeMath.sub(contract_eth_value_bonus, balances_bonus[msg.sender]);\n    balances_bonus[msg.sender] = 0;\n    require(token.transfer(msg.sender, tokens_to_withdraw));\n  }"
    },
    {
        "contract_address": "0x73185bc2a1aa75ec49ba9239b28ea22fda5940fa",
        "function_name": "target",
        "vulnerability_type": "safe",
        "code_snippet": "function target(uint id) constant returns (address) {\n        return actions[id].target;\n    }"
    },
    {
        "contract_address": "0x174bb5d84b78e9e2248e7aa2c789aeba82f72f68",
        "function_name": "receiveApproval",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function receiveApproval(address _from, uint256 _value, address _to, bytes _extraData) public {\n        require(_to == tokenAddress);\n        require(_value == leafPrice);\n        require(gameState != state.closed);\n        require(CreditGAMEInterface(creditGameAddress).isGameApproved(address(this)) == true);\n        uint tokensToTake = processTransaction(_from, _value);\n        IERC20Token(tokenAddress).transferFrom(_from, address(this), tokensToTake);\n    }"
    },
    {
        "contract_address": "0x1a637dac5effb60fb4fd4a808fb24914d56d4046",
        "function_name": "constructor",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "constructor(\n        VotingRule generalVotingRule,\n        VotingRule tagAlongVotingRule,\n        uint256 liquidationPreferenceMultiplierFrac,\n        bool hasFoundersVesting,\n        uint256 generalVotingDuration,\n        uint256 restrictedActVotingDuration,\n        uint256 votingFinalizationDuration,\n        uint256 tokenholdersQuorumFrac,\n        uint256 votingMajorityFrac,\n        string investmentAgreementTemplateUrl\n    )\n        public\n    {\n        require(uint(generalVotingRule) < 4);\n        require(uint(tagAlongVotingRule) < 4);\n        require(tokenholdersQuorumFrac < 10**18);\n        require(keccak256(abi.encodePacked(investmentAgreementTemplateUrl)) != EMPTY_STRING_HASH);\n        GENERAL_VOTING_RULE = generalVotingRule;\n        TAG_ALONG_VOTING_RULE = tagAlongVotingRule;\n        LIQUIDATION_PREFERENCE_MULTIPLIER_FRAC = liquidationPreferenceMultiplierFrac;\n        HAS_FOUNDERS_VESTING = hasFoundersVesting;\n        GENERAL_VOTING_DURATION = generalVotingDuration;\n        RESTRICTED_ACT_VOTING_DURATION = restrictedActVotingDuration;\n        VOTING_FINALIZATION_DURATION = votingFinalizationDuration;\n        TOKENHOLDERS_QUORUM_FRAC = tokenholdersQuorumFrac;\n        VOTING_MAJORITY_FRAC = votingMajorityFrac;\n        INVESTMENT_AGREEMENT_TEMPLATE_URL = investmentAgreementTemplateUrl;\n    }"
    },
    {
        "contract_address": "0x5c28d0683be8143e5ecdd5fd0b39d702d98b1bb9",
        "function_name": "hasClosed",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function hasClosed() public view returns (bool) {\n    return block.timestamp > closingTime;\n  }"
    },
    {
        "contract_address": "0x6593a7140f3718efff638b72a9b6083db47ce0d2",
        "function_name": "finalize",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function finalize() public {\n        require(hasEnded());\n        isFinalized = true;\n        finalization();\n        emit Finalized();\n    }"
    },
    {
        "contract_address": "0x071ee67dea63d0a42740539e286836f649c74066",
        "function_name": "release",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function release() onlyOwner public{\n    require(isLocked);\n    require(!isReleased);\n    require(lockOver());\n    uint256 token_amount = tokenBalance();\n    token_reward.transfer( beneficiary, token_amount);\n    emit TokenReleased(beneficiary, token_amount);\n    isReleased = true;\n  }"
    },
    {
        "contract_address": "0x10d152ced5d9fcf0e072e8b5c04dc2d8580b53f9",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n      require(!isLocked);\n      require(tokenBalance() > 0);\n      start_time = now;\n      end_time = start_time.add(fifty_two_weeks);\n      isLocked = true;\n  }"
    },
    {
        "contract_address": "0x5c9f77612069eabd4b06be53d67e3f16af2d8436",
        "function_name": "endCrowdsale",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function endCrowdsale() public at_stage(Stages.InProgress) {\n        require(now > crowdsaleEnd || raised >= maxAmount);\n        require(raised >= minAmount);\n        stage = Stages.Ended;\n        if (!token.unlock()) {\n            revert();\n        }\n        uint totalTokenSupply = token.totalSupply() + allocatedTokens;\n        for (uint i = 0; i < stakeholdersPayouts.length; i++) {\n            Payout storage p = stakeholdersPayouts[i];\n            _allocateStakeholdersTokens(totalTokenSupply * p.percentage / percentageDenominator, now + p.vestingPeriod);\n        }\n        _allocateStakeholdersEth(this.balance - allocatedEth, 0);\n    }"
    },
    {
        "contract_address": "0xc16c28d110697b1ad7a0f640eee2e343febea43b",
        "function_name": "approve",
        "vulnerability_type": "safe",
        "code_snippet": "function approve( address spender, uint value ) public returns (bool ok);"
    },
    {
        "contract_address": "0x69b794ec295d665fc527230523f7012eea1dc03e",
        "function_name": "buyTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyTokens(address beneficiary) public payable {\n        require(beneficiary != address(0));\n        require(beneficiary != address(this));\n        require(beneficiary != tokenAddress);\n        require(validPurchase());\n        uint256 weiAmount = msg.value;\n        uint256 tokens = calcTokenAmount(weiAmount);\n        weiRaised = safeAdd(weiRaised, weiAmount);\n        distribution[beneficiary] = safeAdd(distribution[beneficiary], tokens);\n        ipc.transfer(beneficiary, tokens);\n        TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n        forwardFunds();\n    }"
    },
    {
        "contract_address": "0x735b8da336f3463bf172852a294af5146b3e8842",
        "function_name": "releaseOnce",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function releaseOnce() public {\n        bytes32 headKey = toKey(msg.sender, 0);\n        uint64 head = chains[headKey];\n        require(head != 0);\n        require(uint64(block.timestamp) > head);\n        bytes32 currentKey = toKey(msg.sender, head);\n        uint64 next = chains[currentKey];\n        uint amount = freezings[currentKey];\n        delete freezings[currentKey];\n        balances[msg.sender] = balances[msg.sender].add(amount);\n        freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n        if (next == 0) {\n            delete chains[headKey];\n        } else {\n            chains[headKey] = next;\n            delete chains[currentKey];\n        }\n        emit Released(msg.sender, amount);\n    }"
    },
    {
        "contract_address": "0x48198311ac8d81929c0e67e00dfc789b706178e9",
        "function_name": "buyTicketsFor",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyTicketsFor(address beneficiary) whenNotPaused() payable {\n        require(beneficiary != 0x0);\n        require(msg.value >= PRICE);\n        uint256 change = msg.value%PRICE;\n        uint256 numberOfTickets = msg.value.sub(change).div(PRICE);\n        token.mint(beneficiary, numberOfTickets);\n        addParticipant(beneficiary, numberOfTickets);\n        msg.sender.transfer(change);\n    }"
    },
    {
        "contract_address": "0x05eab1757083babf9c625b18c40f562c950a880f",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0x43716e7e08bde679e0b05b50fd0120cc77277bb4",
        "function_name": "claimRefund",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function claimRefund() public {\n    require(isFinalized, \"Claim refunds is only possible if the ICO is finalized.\");\n    require(!goalReached(), \"Claim refunds is only possible if the soft cap goal has not been reached.\");\n    uint256 deposit = vault.depositsOf(msg.sender);\n    vault.withdraw(msg.sender);\n    weiRaised = weiRaised.sub(deposit);\n    ClinicAllToken(token).burnAfterRefund(msg.sender);\n  }"
    },
    {
        "contract_address": "0xda9f43015749056182352e9dc6d3ee0b6293d80a",
        "function_name": "approve",
        "vulnerability_type": "safe",
        "code_snippet": "function approve(address _to, uint256 _tokenId) external;"
    },
    {
        "contract_address": "0x293bfea035fbcc930bb93001a29eebc0dc1a068c",
        "function_name": "updateTotalModeratorLockedDGDs",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function updateTotalModeratorLockedDGDs(uint256 _totalLockedDGDStake)\n        public\n    {\n        require(sender_is_from([CONTRACT_DAO_STAKE_LOCKING, CONTRACT_DAO_REWARDS_MANAGER, EMPTY_BYTES]));\n        totalModeratorLockedDGDStake = _totalLockedDGDStake;\n    }"
    },
    {
        "contract_address": "0x1ad2192db829e890a8835fec793f33294b5bb6d8",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n      require(!isLocked);\n      require(tokenBalance() > 0);\n      start_time = now;\n      end_time = start_time.add(fifty_two_weeks);\n      isLocked = true;\n  }"
    },
    {
        "contract_address": "0x56bbe9e9d360e94e6bd14c55e5713da7576049d7",
        "function_name": "withdraw",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function withdraw()\n        isActivated()\n        isHuman()\n        public\n    {\n        uint256 _rID = rID_;\n        uint256 _now = now;\n        uint256 _pID = pIDxAddr_[msg.sender];\n        uint256 _eth;\n        if (_now > round_[_rID].end && round_[_rID].ended == false)\n        {\n            F3Ddatasets.EventReturns memory _eventData_;\n\t\t\tround_[_rID].ended = true;\n            _eventData_ = endRound(_eventData_);\n            _eth = withdrawEarnings(_pID);\n            if (_eth > 0)\n                plyr_[_pID].addr.transfer(_eth);\n            _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\n            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\n            emit F3Devents.onWithdrawAndDistribute\n            (\n                msg.sender,\n                plyr_[_pID].name,\n                _eth,\n                _eventData_.compressedData,\n                _eventData_.compressedIDs,\n                _eventData_.winnerAddr,\n                _eventData_.winnerName,\n                _eventData_.amountWon,\n                _eventData_.newPot,\n                _eventData_.P3DAmount,\n                _eventData_.genAmount\n            );\n        } else {\n            _eth = withdrawEarnings(_pID);\n            if (_eth > 0)\n                plyr_[_pID].addr.transfer(_eth);\n            emit F3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);\n        }\n    }"
    },
    {
        "contract_address": "0x2fee479b98bce54f7b6466146e24512d8272ee6f",
        "function_name": "withdrawTo",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function withdrawTo(\n\t\t\taddress token,\n\t\t\tuint amount,\n\t\t\taddress to,\n\t\t\tbytes signature) external {\n\t\trequire(amount > 0 && to != address(this));\n\t\tassert(block.timestamp >= lastWithdrawalTime[token]);\n\t\tvar limit = getSignatureRemainingLimit(\n\t\t\tsignature,\n\t\t\tkeccak256(address(this), token, nonce, amount, to),\n\t\t\ttoken);\n\t\trequire(limit >= amount);\n\t\trequire(getBalance(token) >= amount);\n\t\tdailyCount[token] = getDailyCount(token) + amount;\n\t\tlastWithdrawalTime[token] = block.timestamp;\n\t\tnonce++;\n\t\t_transfer(token, to, amount);\n\t\tOnWithdrawTo(token, msg.sender, to, amount, uint64(block.timestamp));\n\t}"
    },
    {
        "contract_address": "0x86eb746eb179487abb11dbc5180d544af981035a",
        "function_name": "transfer",
        "vulnerability_type": "safe",
        "code_snippet": "function transfer(address to, uint256 value) public returns (bool);"
    },
    {
        "contract_address": "0x5b72cae52d7d4cda632595574fcefdea3ae37143",
        "function_name": "udpate_hash",
        "vulnerability_type": "safe",
        "code_snippet": "function udpate_hash(bytes32 new_hash) public\n    {\n        if (keyHash == 0x0) {\n            keyHash = new_hash;\n        }\n    }"
    },
    {
        "contract_address": "0x5e6a22ef928d09e9159737393ca155e9eb021d54",
        "function_name": "claimTokensE",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function claimTokensE(uint8 order) onlyOwner public {\n        require(finished);\n        require(order >= 1 && order <= 8);\n        require(!completedE[order]);\n        if (order == 1) {\n            require(now >= endICODate + 15724800);\n            token.transfer(walletE, paymentSizeE);\n            completedE[order] = true;\n        }\n        if (order == 2) {\n            require(now >= endICODate + 31536000);\n            token.transfer(walletE, paymentSizeE);\n            completedE[order] = true;\n        }\n        if (order == 3) {\n            require(now >= endICODate + 47260800);\n            token.transfer(walletE, paymentSizeE);\n            completedE[order] = true;\n        }\n        if (order == 4) {\n            require(now >= endICODate + 63072000);\n            token.transfer(walletE, paymentSizeE);\n            completedE[order] = true;\n        }\n        if (order == 5) {\n            require(now >= endICODate + 78796800);\n            token.transfer(walletE, paymentSizeE);\n            completedE[order] = true;\n        }\n        if (order == 6) {\n            require(now >= endICODate + 94608000);\n            token.transfer(walletE, paymentSizeE);\n            completedE[order] = true;\n        }\n        if (order == 7) {\n            require(now >= endICODate + 110332800);\n            token.transfer(walletE, paymentSizeE);\n            completedE[order] = true;\n        }\n        if (order == 8) {\n            require(now >= endICODate + 126144000);\n            token.transfer(walletE, paymentSizeE);\n            completedE[order] = true;\n        }\n    }"
    },
    {
        "contract_address": "0x18a57c32147e9647008c4add23f73ebe2376ade3",
        "function_name": "setEngineerInterface",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function setEngineerInterface(address _addr) public isAdministrator\n    {\n        CryptoEngineerInterface engineerInterface = CryptoEngineerInterface(_addr);\n        require(engineerInterface.isEngineerContract() == true);\n        Engineer = engineerInterface;\n    }"
    },
    {
        "contract_address": "0x416dd1d4fb22f6ae73651d5c2c5475087df4ea26",
        "function_name": "transferToAddress",
        "vulnerability_type": "safe",
        "code_snippet": "function transferToAddress(address _targetWallet, uint256 _tokenAmount) public onlyOwner {\n    token.transfer(_targetWallet, _tokenAmount * 1 ether);\n  }"
    },
    {
        "contract_address": "0xa67d6bce80a4a98cc66ea508b1b5791919fe3176",
        "function_name": "balanceOf",
        "vulnerability_type": "safe",
        "code_snippet": "function balanceOf(address who) public constant returns (uint256);"
    },
    {
        "contract_address": "0x293bfea035fbcc930bb93001a29eebc0dc1a068c",
        "function_name": "setCarbonVoteBonusClaimed",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function setCarbonVoteBonusClaimed(address _user)\n        public\n    {\n        require(sender_is(CONTRACT_DAO_STAKE_LOCKING));\n        carbonVoteBonusClaimed[_user] = true;\n    }"
    },
    {
        "contract_address": "0xe894d2b82df198822ede0918e8c1c2fe606d14e0",
        "function_name": "transferFrom",
        "vulnerability_type": "safe",
        "code_snippet": "function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }"
    },
    {
        "contract_address": "0x74b38fa961e41f42fb9abd899119893109c1c556",
        "function_name": "HodlTokens3",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function HodlTokens3(address ERC, uint256 amount, uint256 AvailableBalances, uint256 AvailableCashback, address ref) public {\n\t    ERC20Interface token \t= ERC20Interface(ERC);\n\t\tuint256 TokenPercent \t= Bigdata[ERC][1];\n\t\tuint256 TokenHodlTime \t= Bigdata[ERC][2];\n\t\tuint256 HodlTime\t\t= add(now, TokenHodlTime);\n\t\tuint256 AM = amount; \tuint256 AB = AvailableBalances;\t\tuint256 AC = AvailableCashback;\n\t\tamount \t= 0; AvailableBalances = 0; AvailableCashback = 0;\n\t\t_safes[idnumber] = Safe(idnumber, AM, HodlTime, msg.sender, ERC, token.symbol(), AB, AC, now, TokenPercent, 0, 0, 0, ref, false);\n\t\tStatistics[msg.sender][ERC][1]\t\t\t= add(Statistics[msg.sender][ERC][1], AM);\n\t\tStatistics[msg.sender][ERC][5]  \t\t= add(Statistics[msg.sender][ERC][5], AM);\n\t\tBigdata[ERC][6] \t\t\t\t\t\t= add(Bigdata[ERC][6], AM);\n        Bigdata[ERC][3]\t\t\t\t\t\t\t= add(Bigdata[ERC][3], AM);\n\t\tif(Bigdata[msg.sender][8] == 1 ) {\n        idaddress[msg.sender].push(idnumber); idnumber++; Bigdata[ERC][10]++;  }\n\t\telse {\n\t\tafflist[ref].push(msg.sender); idaddress[msg.sender].push(idnumber); idnumber++; Bigdata[ERC][9]++; Bigdata[ERC][10]++; TotalUser++;   }\n\t\tBigdata[msg.sender][8] \t\t\t\t\t= 1;\n        emit onHoldplatform(msg.sender, ERC, token.symbol(), AM, HodlTime);\n\t\tBigdata[msg.sender][19]\t\t= 333;\n\t}"
    },
    {
        "contract_address": "0x6855067c993b2db941402cf26212d1911f8cb036",
        "function_name": "approveAndCall",
        "vulnerability_type": "safe",
        "code_snippet": "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n        return true;\n    }"
    },
    {
        "contract_address": "0x2cba12a076ba4d922aca5a6a814fc08701a2333c",
        "function_name": "balanceOf",
        "vulnerability_type": "safe",
        "code_snippet": "function balanceOf(address _owner) constant\tpublic returns (uint256) {\n\t\treturn balances[_owner].balance;\n\t}"
    },
    {
        "contract_address": "0xa37b82a6d803882a45b8951998ef10c74ce37940",
        "function_name": "getChooses",
        "vulnerability_type": "safe",
        "code_snippet": "function getChooses()\n        public\n        view\n        returns (bool[20])\n    {\n        bool[20] memory listChooses;\n        for (uint i = 0; i < MAX_INVESTOR; i++) {\n            listChooses[i] = session.win[i];\n        }\n        return listChooses;\n    }"
    },
    {
        "contract_address": "0xbbc5d510bab53b2199fb17fe1d896eb78911e103",
        "function_name": "setOraclizeGasPrice",
        "vulnerability_type": "safe",
        "code_snippet": "function setOraclizeGasPrice(uint _newPrice) public senderIsOwner {\n    oraclizeGasPrice = _newPrice + 10000000;\n    oraclize_setCustomGasPrice(oraclizeGasPrice);\n  }"
    },
    {
        "contract_address": "0x55bd5d5622a5a321f0b719e1c8deda9ba21e4f80",
        "function_name": "transferFrom",
        "vulnerability_type": "safe",
        "code_snippet": "function transferFrom(address _from, address _to, uint256 _value)\n    public returns (bool);"
    },
    {
        "contract_address": "0x87d598064c736dd0c712d329afcfaa0ccc1921a1",
        "function_name": "createPrizeFighter",
        "vulnerability_type": "safe",
        "code_snippet": "function createPrizeFighter(\n        uint16 _generation,\n        uint256 _genes,\n        uint8 _dexterity,\n        uint8 _strength,\n        uint8 _vitality,\n        uint8 _luck,\n        address _owner\n    ) public onlyBattleContract {\n        require(_generation > 0);\n        _createFighter(_generation, _genes, _dexterity, _strength, _vitality, _luck, _owner);\n    }"
    },
    {
        "contract_address": "0x443cd38fe8a08f670df8d95ec4eae4273a4353e1",
        "function_name": "refundUnconfirmed",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function refundUnconfirmed() public{\n    require(now > endIcoMainSale);\n    require(balances[msg.sender] > 0);\n    require(token.GetPermissionsList(msg.sender) == 1);\n    uint value = balances[msg.sender];\n    balances[msg.sender] = 0;\n    msg.sender.transfer(value);\n    uint uvalue = unconfirmedSumAddr[msg.sender];\n    unconfirmedSumAddr[msg.sender] = 0;\n    token.burn(msg.sender, uvalue );\n  }"
    },
    {
        "contract_address": "0x2832373dddad96bbfb44f1b7da11b6541026bf40",
        "function_name": "canBeWhitelisted",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function canBeWhitelisted(bytes32 _listingHash) view public returns (bool) {\n        uint challengeID = listings[_listingHash].challengeID;\n        if (\n            appWasMade(_listingHash) &&\n            listings[_listingHash].applicationExpiry < now &&\n            !isWhitelisted(_listingHash) &&\n            (challengeID == 0 || challenges[challengeID].resolved == true)\n        ) {\n          return true;\n        }\n        return false;\n    }"
    },
    {
        "contract_address": "0xbd367c347fc8e0a9b2da08717bcc22bb3fd878eb",
        "function_name": "transferOwnership",
        "vulnerability_type": "safe",
        "code_snippet": "function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }"
    },
    {
        "contract_address": "0x59d2dcd705da352f49798738d83035c12948f835",
        "function_name": "__callback",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function __callback(bytes32 myid, string result) public {\n        __callback(myid, result, new bytes(0));\n    }"
    },
    {
        "contract_address": "0x3a26746ddb79b1b8e4450e3f4ffe3285a307387e",
        "function_name": "transfer",
        "vulnerability_type": "safe",
        "code_snippet": "function transfer(address to, uint value);"
    },
    {
        "contract_address": "0x728781e75735dc0962df3a51d7ef47e798a7107e",
        "function_name": "setFeeFormula",
        "vulnerability_type": "safe",
        "code_snippet": "function setFeeFormula(address _newFeeFormula) onlySettler returns (bool success){\n        uint256 testSettling = estProviderFee(_newFeeFormula, 10 ** 18);\n        require(testSettling > (5 * 10 ** 13));\n        feeFormulas[msg.sender] = _newFeeFormula;\n        return true;\n    }"
    },
    {
        "contract_address": "0x7654915a1b82d6d2d0afc37c52af556ea8983c7e",
        "function_name": "finalize",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n    require(!finalized);\n    if(address(finalizeAgent) != 0) {\n      finalizeAgent.finalizeCrowdsale();\n    }\n    finalized = true;\n  }"
    },
    {
        "contract_address": "0x49dc07a8516e1da8f9409dce0d456f3c1f559296",
        "function_name": "finalize",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function finalize() onlyOwner whenPaused public {\n    require(!isFinalized);\n    finalization();\n    Finalized();\n    isFinalized = true;\n  }"
    },
    {
        "contract_address": "0x40ae4acd08e65714b093bf2495fd7941aedfa231",
        "function_name": "transferFrom",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function transferFrom(address from, address to, uint256 value) public returns (bool);"
    },
    {
        "contract_address": "0x777777764382a3ae5e7631570583893bfdea7e05",
        "function_name": "distribute",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function distribute(uint count) public onlyOwner {\n        require(crowdsale.finalized() && !distributed);\n        require(count > 0 && distributedCount + count <= crowdsale.participantsCount());\n        for (uint i = 0; i < count; i++) {\n            address participant = crowdsale.participants(distributedCount + i);\n            uint256 bonus = crowdsale.participantBonus(participant);\n            uint256 tokens = participant.balance.mul(TOKEN_RATE).mul(100 + bonus).div(100);\n            mint(participant, tokens);\n            distributedTokens += tokens;\n        }\n        distributedCount += count;\n        if (distributedCount == crowdsale.participantsCount()) {\n            uint256 ownerTokens = distributedTokens.mul(OWNER_TOKENS_PERCENT).div(100 - OWNER_TOKENS_PERCENT);\n            mint(owner, ownerTokens);\n            finishMinting();\n            unpause();\n            distributed = true;\n            Distributed();\n        }\n    }"
    },
    {
        "contract_address": "0x25e41ae4b247baaae702cdc909d50fd14b2db7ea",
        "function_name": "EthFlip",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function EthFlip() public {\n    minBet = 100000000000000000;\n    maxBet = 500000000000000000;\n    houseFee = 29;\n    oraclizeGas = 500000;\n    oraclizeGasPrice = 3010000000;\n    oraclize_setCustomGasPrice(oraclizeGasPrice);\n    oraclize_setProof(proofType_Ledger);\n    owner = msg.sender;\n    totalPayouts = 1728380000000000000;\n    totalWins = 10;\n    totalLosses = 15;\n  }"
    },
    {
        "contract_address": "0x3bd3d07a2d352e7ca098cccb2b0882c9f45597d2",
        "function_name": "constructor",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "constructor() public {\n\t\towner = msg.sender;\n\t}"
    },
    {
        "contract_address": "0x3d32f1404deace2a43b08211e4662275045b495b",
        "function_name": "constructor",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "constructor(address _owner)\n        public\n    {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }"
    },
    {
        "contract_address": "0xc2396239e59d07bd726e94411413a26152e8c733",
        "function_name": "transferOwnership",
        "vulnerability_type": "safe",
        "code_snippet": "function transferOwnership(address _newOwner) public onlyOwner {\n        newOwner = _newOwner;\n    }"
    },
    {
        "contract_address": "0x12cbdb3b30f3c2a5f1e376470e1af219bc733e89",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0xf0ebda840692b2a6cd8ab43abc57665763100694",
        "function_name": "approve",
        "vulnerability_type": "safe",
        "code_snippet": "function approve(address spender, uint256 value) returns (bool);"
    },
    {
        "contract_address": "0x75eee2b5ffea02f1e14e6a1c40bd30ca94cff975",
        "function_name": "__callback",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function __callback(bytes32 myid, string result) public {\n        __callback(myid, result, new bytes(0));\n    }"
    },
    {
        "contract_address": "0x4ccd910ade7ec212a94cb7390513423898ee0429",
        "function_name": "release",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function release() public {\n    require(block.timestamp >= releaseTime);\n    uint256 amount = token.balanceOf(this);\n    require(amount > 0);\n    token.safeTransfer(beneficiary, amount);\n  }"
    },
    {
        "contract_address": "0x24626fd95ad815bab2136d6f91ca10562161cda3",
        "function_name": "constructor",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "constructor() public\n  {\n    require(init_ac_owned());\n    locked_forever = false;\n  }"
    },
    {
        "contract_address": "0x31cf2697d3117efab5f5493796c94aef362c56ad",
        "function_name": "giveBirth",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function giveBirth(uint256 _matronId)\n    external\n    whenNotPaused\n    returns (uint256)\n    {\n        Pony storage matron = ponies[_matronId];\n        require(matron.birthTime != 0);\n        require(_isReadyToGiveBirth(matron));\n        uint256 sireId = matron.matingWithId;\n        Pony storage sire = ponies[sireId];\n        uint16 parentGen = matron.generation;\n        if (sire.generation > matron.generation) {\n            parentGen = sire.generation;\n        }\n        uint256 childGenes = geneScience.mixGenes(matron.genes, sire.genes, matron.cooldownEndBlock - 1);\n        uint16 cooldownIndex = geneScience.processCooldown(parentGen + 1, block.number);\n        if (cooldownIndex > 13) {\n            cooldownIndex = 13;\n        }\n        address owner = ponyIndexToOwner[_matronId];\n        uint256 ponyId = _createPony(_matronId, matron.matingWithId, parentGen + 1, childGenes, owner, cooldownIndex);\n        delete matron.matingWithId;\n        pregnantPonies--;\n        msg.sender.transfer(autoBirthFee);\n        return ponyId;\n    }"
    },
    {
        "contract_address": "0x4c13184721de2d1b47a8875775ba3ce0b2e00ee0",
        "function_name": "claim",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function claim(uint256 _blockNumber, address forCreditTo);"
    },
    {
        "contract_address": "0x65717fb50ee8f93827f9eeca761e108e502b255f",
        "function_name": "recycleDividend",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function recycleDividend(uint256 _dividendIndex) public\n    onlyController\n    validDividendIndex(_dividendIndex)\n    {\n    Dividend storage dividend = dividends[_dividendIndex];\n    require(dividend.recycled == false);\n    require(dividend.timestamp < SafeMath.sub(getNow(), RECYCLE_TIME));\n    dividends[_dividendIndex].recycled = true;\n    uint256 currentSupply = super.totalSupplyAt(block.number);\n    uint256 remainingAmount = SafeMath.sub(dividend.amount, dividend.claimedAmount);\n    uint256 dividendIndex = dividends.length;\n    uint256 blockNumber = SafeMath.sub(block.number, 1);\n    dividends.push(\n         Dividend(\n         blockNumber,\n         getNow(),\n         remainingAmount,\n         0,\n         currentSupply,\n         false\n         )\n    );\n    DividendRecycled(msg.sender, blockNumber, getNow(), remainingAmount, currentSupply, dividendIndex);\n    }"
    },
    {
        "contract_address": "0x283a97af867165169aece0b2e963b9f0fc7e5b8c",
        "function_name": "fallback",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function ()\n    onlyState(State.VOTING_RUNNING)\n    payable {\n        uint bonusVoted;\n        uint bonus = PRESALE_CONTRACT.balances(msg.sender);\n        assert (bonus > 0);\n        if (msg.value > 1 ether || !msg.sender.send(msg.value)) throw;\n        if (rawVotes[msg.sender] == 0) {\n            voters.push(msg.sender);\n            stakeVoted_Eth += uint16(bonus / 1 ether);\n        } else {\n            bonusVoted           = votedPerCent(msg.sender) * bonus / 100;\n            stakeWaived_Eth     -= uint16((bonus - bonusVoted) / 1 ether);\n            stakeConfirmed_Eth  -= uint16(bonusVoted / 1 ether);\n        }\n        rawVotes[msg.sender] = msg.value > 0 ? msg.value : 1 wei;\n        bonusVoted           = votedPerCent(msg.sender) * bonus / 100;\n        stakeWaived_Eth     += uint16((bonus - bonusVoted) / 1 ether);\n        stakeConfirmed_Eth  += uint16(bonusVoted / 1 ether);\n        stakeRemainingToVote_Eth = uint16(TOTAL_BONUS_SUPPLY_ETH - stakeVoted_Eth);\n    }"
    },
    {
        "contract_address": "0x24626fd95ad815bab2136d6f91ca10562161cda3",
        "function_name": "valid",
        "vulnerability_type": "safe",
        "code_snippet": "function valid(Data storage self, uint256 _item_index)\n           public\n           constant\n           returns (bool _yes)\n  {\n    _yes = self.valid_indexes[_item_index];\n  }"
    },
    {
        "contract_address": "0x36cac7291719e907276d795c330dbc2fcf66df54",
        "function_name": "approveAndCall",
        "vulnerability_type": "safe",
        "code_snippet": "function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n        return true;\n    }"
    },
    {
        "contract_address": "0x577d6886fad02e5fb15b55645894b1ae14228ce4",
        "function_name": "transfer",
        "vulnerability_type": "safe",
        "code_snippet": "function transfer(address, uint256) public returns (bool);"
    },
    {
        "contract_address": "0xe464af04c151a345db70087eec4b604bddbeea08",
        "function_name": "burn",
        "vulnerability_type": "safe",
        "code_snippet": "function burn(uint _amount) notPaused {\n\t\tcontroller.burn(msg.sender, _amount);\n\t\tTransfer(msg.sender, 0x0, _amount);\n\t}"
    },
    {
        "contract_address": "0x6b62f8458fbecc2ed07021c823a1ebb537641ffb",
        "function_name": "transfer",
        "vulnerability_type": "safe",
        "code_snippet": "function transfer(address to, uint256 value) public returns (bool);"
    },
    {
        "contract_address": "0x28926c46bc5c0aeab39c72f7c1201bfb8056d509",
        "function_name": "releaseOnce",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function releaseOnce() public {\n        bytes32 headKey = toKey(msg.sender, 0);\n        uint64 head = chains[headKey];\n        require(head != 0);\n        require(uint64(block.timestamp) > head);\n        bytes32 currentKey = toKey(msg.sender, head);\n        uint64 next = chains[currentKey];\n        uint amount = freezings[currentKey];\n        delete freezings[currentKey];\n        balances[msg.sender] = balances[msg.sender].add(amount);\n        freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n        if (next == 0) {\n            delete chains[headKey];\n        } else {\n            chains[headKey] = next;\n            delete chains[currentKey];\n        }\n        emit Released(msg.sender, amount);\n    }"
    },
    {
        "contract_address": "0xefab21b4de8b0a8c167e9afa8183e0e14cef400f",
        "function_name": "disallowTransfers",
        "vulnerability_type": "safe",
        "code_snippet": "function disallowTransfers() onlyOwner public returns (bool) {\n    transferDisabled = true;\n    return true;\n  }"
    },
    {
        "contract_address": "0x1ec6b49b91d1373b9ca69563693b886c5a17a660",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0x57ba8dffef44580e00bf1fb66b99e1fa1d43a787",
        "function_name": "HodlTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function HodlTokens(address tokenAddress, uint256 amount) public contractActive {\n        require(tokenAddress != 0x0);\n        require(amount > 0);\n\t\tif (contractaddress[tokenAddress] == false) {\n\t\t\trevert();\n\t\t}\n\t\telse {\n        ERC20Interface token = ERC20Interface(tokenAddress);\n        require(token.transferFrom(msg.sender, address(this), amount));\n\t\tuint256 affiliatecomission \t\t= mul(amount, affiliate) / 100;\n\t\tuint256 nocashback \t\t\t\t= mul(amount, 28) / 100;\n\t\t \tif (cashbackcode[msg.sender] == 0 ) {\n\t\t\tuint256 data_amountbalance \t\t= mul(amount, 72) / 100;\n\t\t\tuint256 data_cashbackbalance \t= 0;\n\t\t\taddress data_referrer\t\t\t= superOwner;\n\t\t\tcashbackcode[msg.sender] = superOwner;\n\t\t\temit onCashbackCode(msg.sender, superOwner);\n\t\t\t_systemReserves[tokenAddress] \t= add(_systemReserves[tokenAddress], nocashback);\n\t\t\t} else {\n\t\t\tdata_amountbalance \t\t= sub(amount, affiliatecomission);\n\t\t\tdata_cashbackbalance \t= mul(amount, cashback) / 100;\n\t\t\tdata_referrer\t\t\t= cashbackcode[msg.sender];\n\t\t\t_systemReserves[tokenAddress] \t= add(_systemReserves[tokenAddress], affiliatecomission); }\n\t\t_userSafes[msg.sender].push(_currentIndex);\n\t\t_safes[_currentIndex] =\n\t\tSafe(\n\t\t_currentIndex, amount, now + hodlingTime, msg.sender, tokenAddress, token.symbol(), data_amountbalance, data_cashbackbalance, now, percent, 0, 0, 0, data_referrer);\n        _totalSaved[tokenAddress] \t\t= add(_totalSaved[tokenAddress], amount);\n        _currentIndex++;\n        _countSafes++;\n        emit onHodlTokens(msg.sender, tokenAddress, token.symbol(), amount, now + hodlingTime);\n    }\n}"
    },
    {
        "contract_address": "0x74731ce1bf0ac7f89f1d4161e1fd57b11b287e4a",
        "function_name": "withdraw",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function withdraw() public {\n        uint amountToWithdraw = (block.timestamp.sub(lastTimeWithdraw[msg.sender]).sub((block.timestamp.sub(lastTimeWithdraw[msg.sender])).mod(1 days))).mul(deposit[msg.sender].mul(3).div(100)).div(1 days);\n        if (amountToWithdraw == 0) {\n            revert();\n        }\n        withdrawn[msg.sender] = withdrawn[msg.sender].add(amountToWithdraw);\n        lastTimeWithdraw[msg.sender] = block.timestamp.sub((block.timestamp.sub(lastTimeWithdraw[msg.sender])).mod(1 days));\n        msg.sender.transfer(amountToWithdraw);\n    }"
    },
    {
        "contract_address": "0xe25bcec5d3801ce3a794079bf94adf1b8ccd802d",
        "function_name": "fallback",
        "vulnerability_type": "safe",
        "code_snippet": "function () payable public {\n        require(!finalised);\n        require(block.timestamp >= startTime);\n        require(block.timestamp <= endTime);\n        require(availableSupply > 0);\n        mintMAN();\n    }"
    },
    {
        "contract_address": "0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd",
        "function_name": "createSnapshot",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function createSnapshot()\n        public\n        returns (uint256);"
    },
    {
        "contract_address": "0x47a40aaff442b3d20773bae35199f8495ac9621f",
        "function_name": "buyXid",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyXid(uint256 _affCode, uint256 _team)\n        isActivated()\n        isHuman()\n        isWithinLimits(msg.value)\n        public\n        payable\n    {\n        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n        uint256 _pID = pIDxAddr_[msg.sender];\n        if (_affCode == 0 || _affCode == _pID)\n        {\n            _affCode = plyr_[_pID].laff;\n        } else if (_affCode != plyr_[_pID].laff) {\n            plyr_[_pID].laff = _affCode;\n        }\n        _team = verifyTeam(_team);\n        buyCore(_pID, _affCode, _team, _eventData_);\n    }"
    },
    {
        "contract_address": "0x000000002bb43c83ece652d161ad0fa862129a2c",
        "function_name": "argue",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function argue(uint8 _position, bytes _text)\n    external\n    returns (uint256) {\n        address destination = arguments[0].source;\n        voteToken.vote9(msg.sender, destination);\n        uint256 argumentId = arguments.length;\n        arguments.push(Argument(msg.sender, _position, 1));\n        Case(_text);\n        arguments[votes[msg.sender]].count--;\n        votes[msg.sender] = argumentId;\n        return argumentId;\n    }"
    },
    {
        "contract_address": "0x47ff79b11cb1470329567360a9e065587d956ba3",
        "function_name": "__callback",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function __callback(bytes32 myid, string result) public {\n        __callback(myid, result, new bytes(0));\n    }"
    },
    {
        "contract_address": "0x6f33a7842ad134b2f4bcbedb34bce299dad56c97",
        "function_name": "addPayerRefundAddressAction",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function addPayerRefundAddressAction(\n        bytes32     _requestId,\n        bytes       _payerRefundAddress)\n        external\n        whenNotPaused\n        onlyRequestPayer(_requestId)\n    {\n        uint8 payeesCount = requestCore.getSubPayeesCount(_requestId).add(1);\n        uint256 cursor = 0;\n        uint8 sizeCurrentBitcoinAddress;\n        uint8 j;\n        for (j = 0; j < payeesCount; j = j.add(1)) {\n            require(bytes(payerRefundAddress[_requestId][cursor]).length == 0, \"payer refund address must not be already given\");\n            sizeCurrentBitcoinAddress = uint8(_payerRefundAddress[cursor]);\n            payerRefundAddress[_requestId][j] = Bytes.extractString(_payerRefundAddress, sizeCurrentBitcoinAddress, ++cursor);\n            cursor += sizeCurrentBitcoinAddress;\n        }\n        emit RefundAddressAdded(_requestId);\n    }"
    },
    {
        "contract_address": "0x480d08a87e9d23704dfbdc296afc3436fe6b27d5",
        "function_name": "buySquareAtAuction",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buySquareAtAuction(uint8 squareId, uint256 newPrice, address referrer) public payable atStage(Stage.DutchAuction) {\n        require(\n            squareToOwner[squareId] == address(0) && squareToPrice[squareId] == 0,\n            \"This square has already been auctioned off\"\n        );\n        uint256 tax = _priceToTax(newPrice);\n        uint256 price = getSquarePriceAuction();\n        require(\n            msg.value >= tax.add(price),\n            \"Must pay the full price and tax for a square on auction\"\n        );\n        _distributeAuctionTax(msg.value, referrer);\n        squareToOwner[squareId] = msg.sender;\n        _changeSquarePrice(squareId, newPrice);\n        numBoughtSquares = numBoughtSquares.add(1);\n        emit SquareOwnerChanged(squareId, address(0), msg.sender, price, newPrice);\n        if (numBoughtSquares >= numSquares) {\n            endAuction();\n        }\n    }"
    },
    {
        "contract_address": "0xb4e4a785de5a9caefad3912a1344febf04c7d2ac",
        "function_name": "finalizeSale",
        "vulnerability_type": "safe",
        "code_snippet": "function finalizeSale() onlyAfterSale only(operations) public {\n    doFinalizeSale();\n  }"
    },
    {
        "contract_address": "0x715b88dff71dc777559b9d654dfce55071f8e177",
        "function_name": "withdrawEther",
        "vulnerability_type": "safe",
        "code_snippet": "function withdrawEther(uint256 amount) {\n\t\tif(msg.sender != owner)throw;\n\t\towner.transfer(amount);\n\t}"
    },
    {
        "contract_address": "0x3e84f9554d16b630cc4bb95131b8f0b97dfddb1b",
        "function_name": "buyXaddr",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyXaddr(address _affCode, uint256 _team)\n        isActivated()\n        isHuman()\n        isWithinLimits(msg.value)\n        public\n        payable\n    {\n        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n        uint256 _pID = pIDxAddr_[msg.sender];\n        uint256 _affID;\n        if (_affCode == address(0) || _affCode == msg.sender)\n        {\n            _affID = plyr_[_pID].laff;\n        } else {\n            _affID = pIDxAddr_[_affCode];\n            if (_affID != plyr_[_pID].laff)\n            {\n                plyr_[_pID].laff = _affID;\n            }\n        }\n        _team = verifyTeam(_team);\n        buyCore(_pID, _affID, _team, _eventData_);\n    }"
    },
    {
        "contract_address": "0xd919a962caf08c90752856874f78122c64484e1c",
        "function_name": "transfer",
        "vulnerability_type": "safe",
        "code_snippet": "function transfer(address to, uint256 value) public returns (bool);"
    },
    {
        "contract_address": "0x1b73f881af9279dc4f2178c75b7e073c8e60b61f",
        "function_name": "kill",
        "vulnerability_type": "safe",
        "code_snippet": "function kill() public onlyOwner {\n      if (msg.sender == owner) selfdestruct(owner);\n  }"
    },
    {
        "contract_address": "0xd7604d334ebfa84c70d2c2534f5c7c4e04716510",
        "function_name": "balanceOf",
        "vulnerability_type": "safe",
        "code_snippet": "function balanceOf(address _owner) constant public returns (uint256);"
    },
    {
        "contract_address": "0x20ac542ea6b358066f2308c9805531be62747e90",
        "function_name": "depositToken",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function depositToken(address token, uint amount) {\n    if (token==0) throw;\n    if (!Token(token).transferFrom(msg.sender, this, amount)) throw;\n    tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\n    Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n  }"
    },
    {
        "contract_address": "0x8f2ecccc42ed88348ad39a1985188dc57d75bdf0",
        "function_name": "setCrowdsaleManager",
        "vulnerability_type": "safe",
        "code_snippet": "function setCrowdsaleManager(address _mgr) public\n        onlyEscrow\n    {\n        require(currentPhase != Phase.Migrating);\n        crowdsaleManager = _mgr;\n    }"
    },
    {
        "contract_address": "0x37b21509d0dfdb33a83f70954bc567343c15bdac",
        "function_name": "whitelistMine",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function whitelistMine(uint amount) canMine onlyIfWhitelisted public {\n    require(amount > 0);\n    require(cycleMintSupply < CYCLE_CAP);\n    require(ERC20(FUTX).transferFrom(msg.sender, address(this), amount));\n    uint refund = _mine(exchangeRateFUTX, amount);\n    if(refund > 0) {\n      ERC20(FUTX).transfer(msg.sender, refund);\n    }\n    if (cycleMintSupply == CYCLE_CAP) {\n      _startSwap();\n    }\n  }"
    },
    {
        "contract_address": "0xf1d80f19b1bbe0b0a758549029a202a765dd29ea",
        "function_name": "fallback",
        "vulnerability_type": "safe",
        "code_snippet": "function() external {\n        require(\n            isOperator() && isMethodAllowed(msg.sig) || isOwner(),\n            \"Permission denied\"\n        );\n        bytes memory _calldata = msg.data;\n        uint256 _calldataSize = msg.data.length;\n        address _dst = target;\n        assembly {\n            let result := call(sub(gas, 10000), _dst, 0, add(_calldata, 0x20), _calldataSize, 0, 0)\n            let size := returndatasize\n            let ptr := mload(0x40)\n            returndatacopy(ptr, 0, size)\n            if iszero(result) { revert(ptr, size) }\n            return(ptr, size)\n        }\n    }"
    },
    {
        "contract_address": "0x4a3e0c60f7fa67e8b65c401ddbbf7c17fea5fe40",
        "function_name": "transfer",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function transfer(address _to, uint _value) public returns (bool success);"
    },
    {
        "contract_address": "0x813b428af3920226e059b68a62e4c04933d4ea7a",
        "function_name": "burn",
        "vulnerability_type": "safe",
        "code_snippet": "function burn(uint256 _value) onlyOwner public {\n        require(_value <= balances[msg.sender]);\n        address burner = msg.sender;\n        balances[burner] = balances[burner].sub(_value);\n        totalSupply = totalSupply.sub(_value);\n        totalDistributed = totalDistributed.sub(_value);\n        emit Burn(burner, _value);\n    }"
    },
    {
        "contract_address": "0x37f81ed3827002c8f1b205eeb73558996689417e",
        "function_name": "pause",
        "vulnerability_type": "safe",
        "code_snippet": "function pause() onlyOwner whenNotPaused returns (bool) {\n    paused = true;\n    emit Pause();\n    return true;\n  }"
    },
    {
        "contract_address": "0x58f792248d5fe5cadcc8cc222eaa97c1f4089f8b",
        "function_name": "vote",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function vote(\n        uint _boardMeetingID,\n        bool _supportsProposal\n    );"
    },
    {
        "contract_address": "0x2424cb26cee4943fa58d05c392273f34b6980960",
        "function_name": "burn",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function burn(uint256 _value) public {\n    require(_value <= balances.balanceOf(msg.sender));\n    address burner = msg.sender;\n    balances.subBalance(burner, _value);\n    totalSupply_ = totalSupply_.sub(_value);\n    Burn(burner, _value);\n    Transfer(burner, address(0), _value);\n  }"
    },
    {
        "contract_address": "0x5ca7099611020d9234c7191c7b066779128e715c",
        "function_name": "updateTokenTransferAddress",
        "vulnerability_type": "safe",
        "code_snippet": "function updateTokenTransferAddress (address _transferTokenTo) onlyOwner public {\n    transferTokenTo = _transferTokenTo;\n  }"
    },
    {
        "contract_address": "0x30c92c69d38cfacbb28081490f8cd7558d441903",
        "function_name": "whitelistMine",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function whitelistMine(uint amount) canMine onlyIfWhitelisted public {\n    require(amount > 0);\n    require(cycleMintSupply < CYCLE_CAP);\n    require(ERC20(FUTX).transferFrom(msg.sender, address(this), amount));\n    uint refund = _mine(exchangeRateFUTX, amount);\n    if(refund > 0) {\n      ERC20(FUTX).transfer(msg.sender, refund);\n    }\n    if (cycleMintSupply == CYCLE_CAP) {\n      _startSwap();\n    }\n  }"
    },
    {
        "contract_address": "0x7b116c971118c3a14c2b4d3f12d61755cca3f138",
        "function_name": "constructor",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "constructor(uint256 _rate, address _wallet, ERC20 _token) public {\n    require(_rate > 0);\n    require(_wallet != address(0));\n    require(_token != address(0));\n    rate = _rate;\n    wallet = _wallet;\n    token = _token;\n  }"
    },
    {
        "contract_address": "0x5e5e8d48b42686de57a1448ea02db5e40fc0f732",
        "function_name": "approve",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function approve(address spender, uint256 value) public returns (bool);"
    },
    {
        "contract_address": "0x1d40c0998131f4a0254468eaf3ce8fc1f21d9da6",
        "function_name": "distributeInvestorsReserve",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function distributeInvestorsReserve() onlyOwner locked public {\n        require(block.timestamp.sub(lockedAt) > investorTimeLock, \"Still in locking period.\");\n        uint arrayLength;\n        uint i;\n        arrayLength = lockedInvestorsIndices.length;\n        for (i = 0; i < arrayLength; i++) {\n            claimTokenReserve(lockedInvestorsIndices[i]);\n        }\n    }"
    },
    {
        "contract_address": "0x3115f7c7eb8f7a60c560681974b2c7de530aa6f3",
        "function_name": "safeDiv",
        "vulnerability_type": "safe",
        "code_snippet": "function safeDiv(uint a, uint b) public pure returns (uint c) {\n        require(b > 0);\n        c = a / b;\n    }"
    },
    {
        "contract_address": "0x5fd259a0e8ae9526e32cf775af5fa51c630b6771",
        "function_name": "receiveApproval",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;"
    },
    {
        "contract_address": "0x2bbe149376e019d2748b45e415eac2096ae307be",
        "function_name": "buyXQR",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyXQR(address senderAddr, uint256 _affID)\n    isActivated()\n    isWithinLimits(msg.value)\n    public\n    payable\n    {\n        determinePID();\n        uint256 _pID = pIDxAddr_[senderAddr];\n        uint256 _now = now;\n        uint256 _rID = rID_;\n        if (_now > auction_[_rID].strt && _now < auction_[_rID].end)\n        {\n            buyAuction(_pID);\n        } else if (_now > bigPot_[_rID].strt && _now < bigPot_[_rID].end) {\n            buy(_pID, _affID);\n        } else {\n            if (_now > bigPot_[_rID].end && bigPot_[_rID].ended == false)\n            {\n                bigPot_[_rID].ended = true;\n                endRound();\n            }\n            plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);\n        }\n    }"
    },
    {
        "contract_address": "0xa73dd7580e4d287fb82543618f3ab36cd948dabd",
        "function_name": "transfer",
        "vulnerability_type": "safe",
        "code_snippet": "function transfer(address to, uint256 value)public returns (bool);"
    },
    {
        "contract_address": "0x443cd38fe8a08f670df8d95ec4eae4273a4353e1",
        "function_name": "SetPermissionsList",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function SetPermissionsList(address _address, uint8 _sign) public onlyOwner{\n    permissionsList[_address] = _sign;\n  }"
    },
    {
        "contract_address": "0xa8015120379d11602999d9caf162b7d507ca650a",
        "function_name": "allowance",
        "vulnerability_type": "safe",
        "code_snippet": "function allowance(address _owner, address _spender) constant returns (uint256) {\n    return allowed[_owner][_spender];\n  }"
    },
    {
        "contract_address": "0x8f21997a58699a06b9462e52ae4bfbc7339332a2",
        "function_name": "transferFrom",
        "vulnerability_type": "safe",
        "code_snippet": "function transferFrom(address _from, address _to, uint256 _value) returns (bool success);"
    },
    {
        "contract_address": "0x3772f9716cf6d7a09ede3587738aa2af5577483a",
        "function_name": "constructor",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "constructor(address _owner)\n        public\n    {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }"
    },
    {
        "contract_address": "0x04d660832910ff492e940daff9ec7b3497e886ac",
        "function_name": "doInvest",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function doInvest(address referrerAddr) public payable notFromContract balanceChanged {\n        uint investment = msg.value;\n        uint receivedEther = msg.value;\n        require(investment >= minInvestment, \"investment must be >= minInvestment\");\n        require(address(this).balance <= maxBalance, \"the contract eth balance limit\");\n        if (receivedEther > investment) {\n            uint excess = receivedEther - investment;\n            msg.sender.transfer(excess);\n            receivedEther = investment;\n            emit LogSendExcessOfEther(msg.sender, now, msg.value, investment, excess);\n        }\n        advertisingAddress.send(m_advertisingPercent.mul(receivedEther));\n        adminsAddress.send(m_adminsPercent.mul(receivedEther));\n        bool senderIsInvestor = m_investors.isInvestor(msg.sender);\n        if (referrerAddr.notZero() && !senderIsInvestor && !m_referrals[msg.sender] &&\n        referrerAddr != msg.sender && m_investors.isInvestor(referrerAddr)) {\n            m_referrals[msg.sender] = true;\n            uint referrerBonus = m_referrer_percent.mmul(investment);\n            uint referalBonus = m_referal_percent.mmul(investment);\n            assert(m_investors.addInvestment(referrerAddr, referrerBonus));\n            investment += referalBonus;\n            emit LogNewReferral(msg.sender, referrerAddr, now, referalBonus);\n        }\n        uint dividends = calcDividends(msg.sender);\n        if (senderIsInvestor && dividends.notZero()) {\n            investment += dividends;\n            emit LogAutomaticReinvest(msg.sender, now, dividends);\n        }\n        if (investmentsNumber % 20 == 0) {\n            investment += m_twentiethBakerPercent.mmul(investment);\n        } else if(investmentsNumber % 15 == 0) {\n            investment += m_fiftiethBakerPercent.mmul(investment);\n        } else if(investmentsNumber % 10 == 0) {\n            investment += m_tenthBakerPercent.mmul(investment);\n        }\n        if (senderIsInvestor) {\n            assert(m_investors.addInvestment(msg.sender, investment));\n            assert(m_investors.setPaymentTime(msg.sender, now));\n        } else {\n            if (investmentsNumber <= 50) {\n                investment += m_firstBakersPercent.mmul(investment);\n            }\n            assert(m_investors.newInvestor(msg.sender, investment, now));\n            emit LogNewInvestor(msg.sender, now);\n        }\n        investmentsNumber++;\n        emit LogNewInvestment(msg.sender, now, investment, receivedEther);\n    }"
    },
    {
        "contract_address": "0x9b61de91a6446e2b7845a7804e775c3d5e70d2c6",
        "function_name": "acceptOwnership",
        "vulnerability_type": "safe",
        "code_snippet": "function acceptOwnership() public {\n        require(msg.sender == newOwner);\n        OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n    }"
    },
    {
        "contract_address": "0x00fbe7398d9f0d53fbaef6e2f4c6ab0e7c31f5d7",
        "function_name": "finaliseCrowdsale",
        "vulnerability_type": "safe",
        "code_snippet": "function finaliseCrowdsale() external onlyOwner returns (bool) {\n    require(!isFinalised);\n    token.mint(tokenWallet, tokensToSell);\n    token.finishMinting();\n    forwardFunds();\n    FinalisedCrowdsale();\n    isFinalised = true;\n    return true;\n  }"
    },
    {
        "contract_address": "0x448a5065aebb8e423f0896e6c5d525c040f59af3",
        "function_name": "draw",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function draw(bytes32 cup, uint wad) public note {\n        require(!off);\n        require(msg.sender == cups[cup].lad);\n        require(rdiv(wad, chi()) > 0);\n        cups[cup].art = add(cups[cup].art, rdiv(wad, chi()));\n        rum = add(rum, rdiv(wad, chi()));\n        cups[cup].ire = add(cups[cup].ire, rdiv(wad, rhi()));\n        sai.mint(cups[cup].lad, wad);\n        require(safe(cup));\n        require(sai.totalSupply() <= cap);\n    }"
    },
    {
        "contract_address": "0x07f98e3eb47e6873fa7b85b5b8f088bb2b2e94a3",
        "function_name": "isOnSale",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function isOnSale(uint256 _tokenId) external view returns(bool);"
    },
    {
        "contract_address": "0x3e4ecfcfdabb36c1f0058694941801cbb11f6582",
        "function_name": "refund",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function refund(bytes32 oraclizeQueryId) public {\n\t\tSlotsGameData memory data = slotsData[oraclizeQueryId];\n\t\trequire(SafeMath.sub(block.timestamp, data.start) >= ORACLIZEQUERYMAXTIME\n\t\t\t&& (msg.sender == OWNER || msg.sender == data.player)\n\t\t\t&& (!data.paidOut)\n\t\t\t&& data.etherReceived <= LIABILITIES\n\t\t\t&& data.etherReceived > 0\n\t\t\t&& REFUNDSACTIVE);\n\t\tslotsData[oraclizeQueryId].paidOut = true;\n\t\tLIABILITIES = SafeMath.sub(LIABILITIES, data.etherReceived);\n\t\tdata.player.transfer(data.etherReceived);\n\t\temit Refund(oraclizeQueryId, data.etherReceived);\n\t}"
    },
    {
        "contract_address": "0x1130f5f6b66a8ff0acb3807e2a56ce6fc0105644",
        "function_name": "transfer",
        "vulnerability_type": "safe",
        "code_snippet": "function transfer(address to, uint256 value) public returns (bool);"
    },
    {
        "contract_address": "0x02fb7aefda436d5632e796ef49a607e4e3cdd342",
        "function_name": "approveAndCall",
        "vulnerability_type": "safe",
        "code_snippet": "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n        return true;\n    }"
    },
    {
        "contract_address": "0xb2b5799edccc354f7bf69e9649cf85544e378055",
        "function_name": "allowance",
        "vulnerability_type": "safe",
        "code_snippet": "function allowance(address owner, address spender) public view returns (uint256);"
    },
    {
        "contract_address": "0x12b306fa98f4cbb8d4457fdff3a0a0a56f07ccdf",
        "function_name": "fallback",
        "vulnerability_type": "safe",
        "code_snippet": "function ()  payable {\n        require(isContract(controller));\n        require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender));\n    }"
    },
    {
        "contract_address": "0x3a37dcda0503f92626c082540dfbc9d95104ab96",
        "function_name": "unpause",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function unpause() public onlyCEO whenPaused {\n        paused = false;\n    }"
    },
    {
        "contract_address": "0x5773bb32cafe05c9e128d0d37e9adf00f29d0cbb",
        "function_name": "create",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function create(\n        uint256 _dealId,\n        bytes32 _dealHash,\n        string _reasonNote,\n        bytes32 _requesterId,\n        bytes32 _respondentId,\n        uint256 _amountToStake\n    ) external whenNotPaused {\n        require(bytes(_reasonNote).length > 0, \"reason note must not be empty\");\n        require(_dealHash != bytes32(0), \"deal hash must be non-zero\");\n        require(_requesterId != bytes32(0), \"requester ID must be non-zero\");\n        require(_respondentId != bytes32(0), \"respondent ID must be non-zero\");\n        require(keccak256(abi.encodePacked(_requesterId)) != keccak256(abi.encodePacked(_respondentId)),\n            \"requester and respondent must be different\");\n        require(_amountToStake >= minStake, \"amount to stake must be greater or equal to min.stake\");\n        uint256 requesterAllowance = token.allowance(msg.sender, address(this));\n        require(requesterAllowance >= _amountToStake, \"allowance too small\");\n        token.safeTransferFrom(msg.sender, address(this), _amountToStake);\n        Claim memory claim = Claim({\n            state : State.AwaitingAcceptance,\n            modified : now,\n            dealId : _dealId,\n            dealHash : _dealHash,\n            reasonNote : _reasonNote,\n            requesterId : _requesterId,\n            requesterAddress : msg.sender,\n            requesterStaked : _amountToStake,\n            respondentId : _respondentId,\n            respondentAddress : address(0),\n            respondentStaked : 0,\n            resolutionNote : \"\"\n            });\n        claims.push(claim);\n        emit ClaimCreated(_dealId, claims.length - 1);\n    }"
    },
    {
        "contract_address": "0x58a4cdba423a4d143426951512f066a995527bff",
        "function_name": "feePaid",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function feePaid(bytes4 currencyKey, uint amount)\n        external\n        onlySynthetix\n    {\n        uint xdrAmount = synthetix.effectiveValue(currencyKey, amount, \"XDR\");\n        recentFeePeriods[0].feesToDistribute = recentFeePeriods[0].feesToDistribute.add(xdrAmount);\n    }"
    },
    {
        "contract_address": "0xe0d19ef19dcdc87d0f5418e5ffc69cd022b98cbd",
        "function_name": "burn",
        "vulnerability_type": "safe",
        "code_snippet": "function burn() public onlyOwner {\n        isBurned = true;\n    }"
    },
    {
        "contract_address": "0x118a0df120cfb097aad3a70914562f803a5be45c",
        "function_name": "updateFromRegistry",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function updateFromRegistry() onlyOwner public {\n        moduleRegistry = PolymathRegistry(polymathRegistry).getAddress(\"ModuleRegistry\");\n        securityTokenRegistry = PolymathRegistry(polymathRegistry).getAddress(\"SecurityTokenRegistry\");\n        tickerRegistry = PolymathRegistry(polymathRegistry).getAddress(\"TickerRegistry\");\n        polyToken = PolymathRegistry(polymathRegistry).getAddress(\"PolyToken\");\n    }"
    },
    {
        "contract_address": "0x6c940a8d477922f1cffe012449321098e06db3f7",
        "function_name": "search_winner_bid_address",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function search_winner_bid_address(uint8 slot) returns (address) {\n        uint8 i;\n        if (slot < 128) {\n            for (i=0; i<bids.length; i++) {\n                if (is_slot_in_bid(bids[i].slot_from, bids[i].slot_to, slot)) {\n                    return bids[i].player;\n                }\n            }\n        } else {\n            for (i=uint8(bids.length)-1; i>=0; i--) {\n                if (is_slot_in_bid(bids[i].slot_from, bids[i].slot_to, slot)) {\n                    return bids[i].player;\n                }\n            }\n        }\n        assert (false);\n    }"
    },
    {
        "contract_address": "0x47da34f192d3fd946fd6ce7494e9eedf171a1208",
        "function_name": "addModule",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function addModule(\n        address _moduleFactory,\n        bytes _data,\n        uint256 _maxCost,\n        uint256 _budget\n    ) external;"
    },
    {
        "contract_address": "0x75738fc16aef19ce08479ae9c7976498dd320be3",
        "function_name": "buyPrice",
        "vulnerability_type": "safe",
        "code_snippet": "function buyPrice() public constant returns (uint) {\n\t\treturn getTokensForEther(1 finney);\n\t}"
    },
    {
        "contract_address": "0x2b52db26d97a193e8882fc4ebf2ec9d3b8668d07",
        "function_name": "transfer",
        "vulnerability_type": "safe",
        "code_snippet": "function transfer(address _to, uint256 _value) public returns (bool success){\n        _transfer(msg.sender, _to, _value);\n        return true;\n    }"
    },
    {
        "contract_address": "0x3772f9716cf6d7a09ede3587738aa2af5577483a",
        "function_name": "appendVestingEntry",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function appendVestingEntry(address account, uint time, uint quantity)\n        public\n        onlyOwner\n        onlyDuringSetup\n    {\n        require(now < time, \"Time must be in the future\");\n        require(quantity != 0, \"Quantity cannot be zero\");\n        totalVestedBalance = totalVestedBalance.add(quantity);\n        require(totalVestedBalance <= synthetix.balanceOf(this), \"Must be enough balance in the contract to provide for the vesting entry\");\n        uint scheduleLength = vestingSchedules[account].length;\n        require(scheduleLength <= MAX_VESTING_ENTRIES, \"Vesting schedule is too long\");\n        if (scheduleLength == 0) {\n            totalVestedAccountBalance[account] = quantity;\n        } else {\n            require(getVestingTime(account, numVestingEntries(account) - 1) < time, \"Cannot add new vested entries earlier than the last one\");\n            totalVestedAccountBalance[account] = totalVestedAccountBalance[account].add(quantity);\n        }\n        vestingSchedules[account].push([time, quantity]);\n    }"
    },
    {
        "contract_address": "0x6f7fc2be93fa95072c4d4867d2f682a68f6b75dd",
        "function_name": "release",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function release() public {\n        uint256 num = now.sub(RELEASE_START).div(RELEASE_INTERVAL);\n        if (totalLockAmount == 0) {\n            totalLockAmount = tosToken.balanceOf(this);\n        }\n        if (num >= releasePercentages.length.sub(1)) {\n            tosToken.safeTransfer(beneficiary, tosToken.balanceOf(this));\n            released = 100;\n        }\n        else {\n            uint256 releaseAmount = totalLockAmount.mul(releasePercentages[num].sub(released)).div(100);\n            tosToken.safeTransfer(beneficiary, releaseAmount);\n            released = releasePercentages[num];\n        }\n    }"
    },
    {
        "contract_address": "0x448a5065aebb8e423f0896e6c5d525c040f59af3",
        "function_name": "wipe",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function wipe(bytes32 cup, uint wad) public note {\n        require(!off);\n        var owe = rmul(wad, rdiv(rap(cup), tab(cup)));\n        cups[cup].art = sub(cups[cup].art, rdiv(wad, chi()));\n        rum = sub(rum, rdiv(wad, chi()));\n        cups[cup].ire = sub(cups[cup].ire, rdiv(add(wad, owe), rhi()));\n        sai.burn(msg.sender, wad);\n        var (val, ok) = pep.peek();\n        if (ok && val != 0) gov.move(msg.sender, pit, wdiv(owe, uint(val)));\n    }"
    },
    {
        "contract_address": "0x136e99a415957fc3f23e0a6885b22bcd0c475ab4",
        "function_name": "vote",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function vote (bool agree, uint256 amount) external {\n        require(ERC20Interface(votingTokenAddr).transferFrom(msg.sender, this, amount));\n        uint256 pid = this.getCurrentVoting();\n        require(pid != PROPOSAL_EMPTY);\n        require(proposals[pid].start_time <= block.timestamp);\n        require(proposals[pid].end_time >= block.timestamp);\n        if (deposits[pid][msg.sender] == 0) {\n            proposals[pid].voter_count = proposals[pid].voter_count.add(1);\n        }\n        deposits[pid][msg.sender] = deposits[pid][msg.sender].add(amount);\n        proposals[pid].votes[agree] = proposals[pid].votes[agree].add(amount);\n        emit Vote(msg.sender, amount);\n    }"
    },
    {
        "contract_address": "0xce10ae559d6203adb66c5bc30fb5c08b4f7df0f1",
        "function_name": "mint",
        "vulnerability_type": "safe",
        "code_snippet": "function mint(address _to, uint256 _amount) onlyOwner public {\n        require(canReceiveMintWhiteList.onList(_to));\n        totalSupply_ = totalSupply_.add(_amount);\n        balances.addBalance(_to, _amount);\n        Mint(_to, _amount);\n        Transfer(address(0), _to, _amount);\n        payStakingFee(_to, _amount, mintFeeNumerator, mintFeeDenominator, mintFeeFlat, 0x0);\n    }"
    },
    {
        "contract_address": "0x5f856630adbc27c0f5bc1de1961d4f0fb1805a29",
        "function_name": "fallback",
        "vulnerability_type": "safe",
        "code_snippet": "function () payable internal {\n        uint amount = msg.value * buyPrice;\n        uint amountRaised;\n        amountRaised += msg.value;\n        require(balanceOf[creator] >= amount);\n        balanceOf[msg.sender] += amount;\n        balanceOf[creator] -= amount;\n        Transfer(creator, msg.sender, amount);\n        creator.transfer(amountRaised);\n    }"
    },
    {
        "contract_address": "0x4379fb29afb6ed5afe460524884da11107fe75d3",
        "function_name": "TokensIn",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function TokensIn(uint256 tokens) public {\n    if (inRate==0) revert();\n    uint256 maxtokens=this.balance/inRate;\n    if (tokens>maxtokens) tokens=maxtokens;\n    if (tokens==0) revert();\n    if (!ERC20(token).transferFrom(msg.sender, address(this), tokens)) revert();\n    uint256 sum = tokens*inRate;\n    if (!msg.sender.send(sum)) revert();\n    uint256 newrate = inRate-tokens*leveRage;\n    if (newrate>=minRate) {\n      inRate=newrate;\n      outRate=outRate-tokens*leveRage;\n    }\n    Received(msg.sender, sum, tokens);\n  }"
    },
    {
        "contract_address": "0x4228b993d0a0b3cd9bb097210b50c7c20d1cb7a8",
        "function_name": "init2",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function init2(\n        uint256 _initialAmount,\n        string _tokenName,\n        uint8 _decimalUnits,\n        string _tokenSymbol,\n        address _owner,\n        address _freebie\n        ) public returns (bool){\n        if(init>0)revert();\n        FloodNameSys flood= FloodNameSys(address(0x63030f02d4B18acB558750db1Dc9A2F3961531eE));\n        uint256 p=flood.freebiePercentage();\n        if(_initialAmount>1000){\n            balances[_owner] = _initialAmount-((_initialAmount/1000)*p);\n            balances[_freebie] = (_initialAmount/1000)*p;\n        }else{\n            balances[_owner] = _initialAmount;\n        }\n        totalSupply = _initialAmount;\n        name = _tokenName;\n        decimals = _decimalUnits;\n        symbol = _tokenSymbol;\n        creator=_owner;\n        Factory=msg.sender;\n        init=1;\n        return true;\n    }"
    },
    {
        "contract_address": "0x0ac10bf0342fa2724e93d250751186ba5b659303",
        "function_name": "rollDice",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function rollDice() external{\n        require(!all_stop);\n        require(owner_slave_amount >= 1);\n        require(!player_info[msg.sender].unmovable,\"\u4e0d\u53ef\u79fb\u52d5\");\n        uint16 random = uint16((keccak256(abi.encodePacked(now, random_seed))));\n        random_seed.add(1);\n        if(player_info[msg.sender].city == 0){\n            player_info[msg.sender].city = 1;\n        }\n        uint16 in_city = player_info[msg.sender].city;\n        uint16 tot_domains = inquire_city_totdomains(in_city);\n        uint16 go_domains_id = random % tot_domains;\n        player_info[msg.sender].domain = go_domains_id;\n        address city_address = owner_slave[in_city];\n        address domain_owner = ERC721_interface(city_address).ownerOf(go_domains_id);\n        if (domain_owner != 0x0){\n            if(domain_owner == msg.sender){\n                player_info[msg.sender].build = true;\n            }\n            else{\n                player_info[msg.sender].unmovable = true;\n                player_info[msg.sender].reward = false;\n            }\n\t\t}\n        emit RollDice(msg.sender, in_city, go_domains_id, player_info[msg.sender].unmovable);\n    }\n    fun"
    },
    {
        "contract_address": "0x72aa36c379d681f0813ef0e3834035a2d43f6e8d",
        "function_name": "approve",
        "vulnerability_type": "safe",
        "code_snippet": "function approve(address _spender, uint256 _value) returns (bool success);"
    },
    {
        "contract_address": "0x523630976eb6147621b5c31c781ebe2ec2a806e0",
        "function_name": "closeMotion",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function closeMotion(uint motionID)\n        external\n    {\n        require((motionConfirming(motionID) && !motionPasses(motionID)) || motionWaiting(motionID));\n        _closeMotion(motionID);\n    }"
    },
    {
        "contract_address": "0x457cd14f384e7d103b17feeb01d2a42ad2eca529",
        "function_name": "burn",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function burn(address account, uint amount)\n        external\n        onlySynthetixOrFeePool\n    {\n        tokenState.setBalanceOf(account, tokenState.balanceOf(account).sub(amount));\n        totalSupply = totalSupply.sub(amount);\n        emitTransfer(account, address(0), amount);\n        emitBurned(account, amount);\n    }"
    },
    {
        "contract_address": "0x398b4a35842f776bc9e17caa315177019488d4ce",
        "function_name": "fallback",
        "vulnerability_type": "safe",
        "code_snippet": "function() payable{\n        totalEthInWei = totalEthInWei + msg.value;\n        uint256 amount = msg.value * unitsOneEthCanBuy;\n        require(balances[fundsWallet] >= amount);\n        balances[fundsWallet] = balances[fundsWallet] - amount;\n        balances[msg.sender] = balances[msg.sender] + amount;\n        Transfer(fundsWallet, msg.sender, amount);\n        fundsWallet.transfer(msg.value);\n    }"
    },
    {
        "contract_address": "0x607fb630f2ddf7aeb1a207d7cb6ba6ec9f10c308",
        "function_name": "sendTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function sendTokens() afterDeadline {\n        assert(!investors[msg.sender].tokenSent);\n        uint amount = div(mul(investors[msg.sender].amount, preICOTokenAmount), uint256(totalDonationsWithBonuses));\n        coin.push(msg.sender, uint128(amount));\n        preICOTokenRemaining -= uint128(amount);\n        investors[msg.sender].tokenSent = true;\n        investors[msg.sender].tokenAmount = amount;\n        LogSendTokens(msg.sender, amount, \"Sent tokens\");\n    }"
    },
    {
        "contract_address": "0x0b3ebeccc00e9ceae2bf3235d558eda7398be91e",
        "function_name": "name",
        "vulnerability_type": "safe",
        "code_snippet": "function name(bytes32 node) public view returns (string) {\n        return records[node].name;\n    }"
    },
    {
        "contract_address": "0x6403670a03596ca2316b84595bce37d5313a2ec4",
        "function_name": "rankOf",
        "vulnerability_type": "safe",
        "code_snippet": "function rankOf(uint256 _tokenId)\n    public view\n    returns (uint8)\n  {\n    return tokenIdToRank[_tokenId];\n  }"
    },
    {
        "contract_address": "0x7c7d8f9a50ae723d591bd7d23cea6b50d9cdcd5b",
        "function_name": "totalSupply",
        "vulnerability_type": "safe",
        "code_snippet": "function totalSupply() public constant returns (uint);"
    },
    {
        "contract_address": "0x457cd14f384e7d103b17feeb01d2a42ad2eca529",
        "function_name": "removeSynth",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function removeSynth(bytes4 currencyKey)\n        external\n        optionalProxy_onlyOwner\n    {\n        require(synths[currencyKey] != address(0), \"Synth does not exist\");\n        require(synths[currencyKey].totalSupply() == 0, \"Synth supply exists\");\n        require(currencyKey != \"XDR\", \"Cannot remove XDR synth\");\n        address synthToRemove = synths[currencyKey];\n        for (uint8 i = 0; i < availableSynths.length; i++) {\n            if (availableSynths[i] == synthToRemove) {\n                delete availableSynths[i];\n                availableSynths[i] = availableSynths[availableSynths.length - 1];\n                availableSynths.length--;\n                break;\n            }\n        }\n        delete synths[currencyKey];\n        emitSynthRemoved(currencyKey, synthToRemove);\n    }"
    },
    {
        "contract_address": "0x2c594e1cb006e86c3879b1d8191a8b059af52be7",
        "function_name": "decimals",
        "vulnerability_type": "safe",
        "code_snippet": "function decimals() public view returns (uint8 _decimals);"
    },
    {
        "contract_address": "0x0c52acf0921cf56c56d5737fe32f3ec2d2be30a2",
        "function_name": "balanceOf",
        "vulnerability_type": "safe",
        "code_snippet": "function balanceOf(address _owner) constant returns (uint256 balance) {}"
    },
    {
        "contract_address": "0x5d48aca3954d288a5fea9fc374ac48a5dbf5fa6d",
        "function_name": "transfer",
        "vulnerability_type": "safe",
        "code_snippet": "function transfer(address _to, uint256 _value) public returns (bool);"
    },
    {
        "contract_address": "0x791aaa5db795a115b9b61a476f93482c1af8ccab",
        "function_name": "doInvest",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function doInvest(address referrerAddr) public payable notFromContract balanceChanged {\nuint investment = msg.value;\nuint receivedEther = msg.value;\nrequire(investment >= minInvesment, \"investment must be >= minInvesment\");\nrequire(address(this).balance <= maxBalance, \"the contract eth balance limit\");\nif (m_rgp.isActive()) {\nuint rpgMaxInvest = m_rgp.maxInvestmentAtNow();\nrpgMaxInvest.requireNotZero();\ninvestment = Math.min(investment, rpgMaxInvest);\nassert(m_rgp.saveInvestment(investment));\nemit LogRGPInvestment(msg.sender, now, investment, m_rgp.currDay());\n} else if (m_privEnter.isActive()) {\nuint peMaxInvest = m_privEnter.maxInvestmentFor(msg.sender);\npeMaxInvest.requireNotZero();\ninvestment = Math.min(investment, peMaxInvest);\n}\nif (receivedEther > investment) {\nuint excess = receivedEther - investment;\nmsg.sender.transfer(excess);\nreceivedEther = investment;\nemit LogSendExcessOfEther(msg.sender, now, msg.value, investment, excess);\n}\nadvertisingAddress.transfer(m_advertisingPercent.mul(receivedEther));\nadminsAddress.transfer(m_adminsPercent.mul(receivedEther));\nbool senderIsInvestor = m_investors.isInvestor(msg.sender);\nif (referrerAddr.notZero() && !senderIsInvestor && !m_referrals[msg.sender] &&\nreferrerAddr != msg.sender && m_investors.isInvestor(referrerAddr)) {\nm_referrals[msg.sender] = true;\nuint referrerBonus = m_referrer_percent.mmul(investment);\nif (investment > 10 ether) {\nreferrerBonus = m_referrer_percentMax.mmul(investment);\n}\nuint referalBonus = m_referal_percent.mmul(investment);\nassert(m_investors.addInvestment(referrerAddr, referrerBonus));\ninvestment += referalBonus;\nemit LogNewReferral(msg.sender, referrerAddr, now, referalBonus);\n}\nuint dividends = calcDividends(msg.sender);\nif (senderIsInvestor && dividends.notZero()) {\ninvestment += dividends;\nemit LogAutomaticReinvest(msg.sender, now, dividends);\n}\nif (senderIsInvestor) {\nassert(m_investors.addInvestment(msg.sender, investment));\nassert(m_investors.setPaymentTime(msg.sender, now));\n} else {\nassert(m_investors.newInvestor(msg.sender, investment, now));\nemit LogNewInvestor(msg.sender, now);\n}\ninvestmentsNumber++;\nemit LogNewInvesment(msg.sender, now, investment, receivedEther);\n}"
    },
    {
        "contract_address": "0xc555a8e0993db8a2070e2b40dfdb3aee74f3c918",
        "function_name": "balanceOf",
        "vulnerability_type": "safe",
        "code_snippet": "function balanceOf(address _owner) constant returns (uint256 balance) {}"
    },
    {
        "contract_address": "0x4a089c689894bde6a67625488c64a5e16e1cbeba",
        "function_name": "finalize",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function finalize() public onlyOwner {\n        require(!isFinalized);\n        require(hasEnded());\n        finalization();\n        Finalized();\n        isFinalized = true;\n    }"
    },
    {
        "contract_address": "0x9cac170c88a4c00748933560c9c3bf88b82547db",
        "function_name": "balanceOf",
        "vulnerability_type": "safe",
        "code_snippet": "function balanceOf(address who) public view returns (uint256);"
    },
    {
        "contract_address": "0x42afcf6295c8ba5ca9e772f60a7d28670b0cbfd5",
        "function_name": "finishMigration",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function finishMigration() public onlyMigration {\n          require(true == migrationStarted);\n          migrationFinished = true;\n     }"
    },
    {
        "contract_address": "0x96c68443bbe2e3f93ada8d146605fe1acc748445",
        "function_name": "tokenPriceCHFCent",
        "vulnerability_type": "safe",
        "code_snippet": "function tokenPriceCHFCent(uint256 _tokensaleId)\n    public view returns (uint256);"
    },
    {
        "contract_address": "0x0853e23cbed50087573d67aeb1ec57822b721f56",
        "function_name": "grantReserveToken",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function grantReserveToken(address beneficiary) public onlyOwner {\n        require((!grantReserveSupply) && (now > reserveTimeLock));\n        grantReserveSupply = true;\n        token.mint(beneficiary,reserveSupply);\n        reserveSupply = 0;\n    }"
    },
    {
        "contract_address": "0x75f3dfd3948500d2133d2f0af3ad153c176ec2c4",
        "function_name": "releaseWithStage",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function releaseWithStage(address _target, address _dest) onlyOwner public returns (bool) {\n        require(_target != address(0));\n        require(_dest != address(0));\n        assert(owned.allowance(_target, this) > 0);\n        uint256 len = frozenAccounts.length;\n        uint256 i = 0;\n        while (i < len) {\n            address frozenAddr = frozenAccounts[i];\n            if (frozenAddr == _target) {\n                uint256 timeRecLen = frozenTimes[frozenAddr].length;\n                bool released = false;\n                for (uint256 j = 0; j < timeRecLen; released = false) {\n                    TimeRec storage timePair = frozenTimes[frozenAddr][j];\n                    uint256 nowTime = now;\n                    if (nowTime > timePair.endTime && timePair.endTime > 0 && timePair.duration > 0) {\n                        uint256 value = timePair.amount * (nowTime - timePair.endTime) / timePair.duration;\n                        if (value > timePair.remain) {\n                            value = timePair.remain;\n                        }\n                        timePair.endTime = nowTime;\n                        timePair.remain = timePair.remain.sub(value);\n                        if (timePair.remain < 1e8) {\n                            if (!removeLockedTime(frozenAddr, j)) {\n                                return false;\n                            }\n                            released = true;\n                            timeRecLen = timeRecLen.sub(1);\n                        }\n                        ReleaseFunds(frozenAddr, value);\n                        preReleaseAmounts[frozenAddr] = preReleaseAmounts[frozenAddr].add(value);\n                    } else if (nowTime >= timePair.endTime && timePair.endTime > 0 && timePair.duration == 0) {\n                        if (!removeLockedTime(frozenAddr, j)) {\n                            return false;\n                        }\n                        released = true;\n                        timeRecLen = timeRecLen.sub(1);\n                        ReleaseFunds(frozenAddr, timePair.amount);\n                        preReleaseAmounts[frozenAddr] = preReleaseAmounts[frozenAddr].add(timePair.amount);\n                    }\n                    if (!released) {\n                        j = j.add(1);\n                    }\n                }\n                if (preReleaseAmounts[frozenAddr] > 0) {\n                    owned.freezeAccount(frozenAddr, false);\n                    if (!owned.transferFrom(_target, _dest, preReleaseAmounts[frozenAddr])) {\n                        return false;\n                    }\n                }\n                if (frozenTimes[frozenAddr].length == 0) {\n                    if (!removeAccount(i)) {\n                        return false;\n                    }\n                } else {\n                    owned.freezeAccount(frozenAddr, true);\n                }\n                return true;\n            }\n            i = i.add(1);\n        }\n        return false;\n    }"
    },
    {
        "contract_address": "0x0b72b3fb545fe6cb63e27273078d7a8656a34c42",
        "function_name": "takeSnapshot",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function takeSnapshot() public\n    onlyOwner\n    isNotFilled\n    wasNotAirdropped {\n        uint256 totalBalance = 0;\n        uint256 totalAirdrop = 0;\n        uint256 airdrops = 0;\n        for (uint i = 0; i < addresses.length; i++) {\n            Beneficiary storage beneficiary = beneficiaries[addresses[i]];\n            beneficiary.balance = token.balanceOf(addresses[i]);\n            totalBalance = totalBalance.add(beneficiary.balance);\n            if (beneficiary.balance > 0) {\n                beneficiary.airdrop = (beneficiary.balance.mul(airdropLimit).div(currentCirculating));\n                totalAirdrop = totalAirdrop.add(beneficiary.airdrop);\n                airdrops = airdrops.add(1);\n            }\n        }\n        filled = true;\n        burn = airdropLimit.sub(totalAirdrop);\n        emit SnapshotTaken(totalBalance, totalAirdrop, burn, addresses.length, airdrops);\n    }"
    },
    {
        "contract_address": "0x5f7f8e59c4a5fffb3ef02a65d37073bc1af84892",
        "function_name": "buyTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyTokens(address beneficiary) public payable {\n    require(beneficiary != address(0));\n    require(validPurchase());\n    uint256 weiAmount = msg.value;\n    uint256 tokens = weiAmount.mul(rate);\n    weiRaised = weiRaised.add(weiAmount);\n    token.mint(beneficiary, tokens);\n    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n    forwardFunds();\n  }"
    },
    {
        "contract_address": "0xeba49ddea9f59f0a80ecbb1fb7a585ce0bfe5a5e",
        "function_name": "transferFromAdmin",
        "vulnerability_type": "safe",
        "code_snippet": "function transferFromAdmin(address _from, address _to, uint256 _value) public onlyOwner returns(bool success) {\n        if (_to == 0x0) revert();\n        if (balanceOf[_from] < _value) revert();\n        if ((balanceOf[_to] + _value) < balanceOf[_to]) revert();\n        uint256 divAmount_from = 0;\n        uint256 divAmount_to = 0;\n        if ((dividendsRound != 0) && (dividendsBuffer > 0)) {\n            divAmount_from = calcDividendsSum(_from);\n            if ((divAmount_from == 0) && (paidDividends[_from][dividendsRound] == 0)) paidDividends[_from][dividendsRound] = 1;\n            divAmount_to = calcDividendsSum(_to);\n            if ((divAmount_to == 0) && (paidDividends[_to][dividendsRound] == 0)) paidDividends[_to][dividendsRound] = 1;\n        }\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        if (divAmount_from > 0) {\n            if (!_from.send(divAmount_from)) revert();\n        }\n        if (divAmount_to > 0) {\n            if (!_to.send(divAmount_to)) revert();\n        }\n        Transfer(_from, _to, _value);\n        return true;\n    }"
    },
    {
        "contract_address": "0x341f9c6c60c07fd11ef0bbc93586a2b9d68bfcf0",
        "function_name": "initialize",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function initialize(address _founder, address _bounty) onlyManager {\n        assert(currentStage != Stage.Init);\n        assert(_founder != 0x0);\n        assert(_bounty != 0x0);\n        require(!setFounder);\n        require(!setBounty);\n        founder = _founder;\n        bountyOwner = _bounty;\n        VINToken.emitTokens(_bounty, totalBountyTokens);\n        setFounder = true;\n        setBounty = true;\n        currentStage = Stage.Init;\n    }"
    },
    {
        "contract_address": "0x3cc2806b2aff4a3a77dfb99f0ed689db221a4a29",
        "function_name": "WithdrawAffiliate",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function WithdrawAffiliate(address user, address tokenAddress) public {\n\t\trequire(tokenAddress != 0x0);\n\t\trequire(Statistics[user][tokenAddress][3] > 0 );\n\t\tuint256 amount = Statistics[msg.sender][tokenAddress][3];\n\t\tStatistics[msg.sender][tokenAddress][3] = 0;\n\t\t_totalSaved[tokenAddress] \t\t= sub(_totalSaved[tokenAddress], amount);\n\t\tAllPayments[tokenAddress] \t\t= add(AllPayments[tokenAddress], amount);\n\t\tuint256 eventAmount\t\t\t\t= amount;\n        address eventTokenAddress \t\t= tokenAddress;\n        string \tmemory eventTokenSymbol = ContractSymbol[tokenAddress];\n        ERC20Interface token = ERC20Interface(tokenAddress);\n        require(token.balanceOf(address(this)) >= amount);\n        token.transfer(user, amount);\n\t\tStatistics[user][tokenAddress][2] \t= add(Statistics[user][tokenAddress][2], amount);\n\t\temit onAffiliateBonus(msg.sender, eventTokenAddress, eventTokenSymbol, eventAmount, now);\n    }"
    },
    {
        "contract_address": "0x5890301587c4f9099d5ed4041cfc4bff332357a9",
        "function_name": "InvestContract",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function InvestContract(address _ICOContractAddress, address _investor,  uint\n                           _etherAmount, uint _tokenAmount) TokenPullable(_ICOContractAddress)\n    public {\n        icoContract = ICOContract(_ICOContractAddress);\n        token = icoContract.token();\n\t\tetherAmount = _etherAmount;\n        tokenAmount = _tokenAmount;\n        projectWallet = icoContract.projectWallet();\n        investor = _investor;\n        amountToPay = etherAmount*101/100;\n        quorum = 3;\n        addAcceptedArbiter(0x42efbba0563AE5aa2312BeBce1C18C6722B67857, 1);\n        addAcceptedArbiter(0x37D5953c24a2efD372C97B06f22416b68e896eaf, 1);\n        addAcceptedArbiter(0xd0D2e05Fd34d566612529512F7Af1F8a60EDAb6C, 1);\n        addAcceptedArbiter(0xB6508aFaCe815e481bf3B3Fa9B4117D46C963Ec3, 1);\n        addAcceptedArbiter(0x73380dc12B629FB7fBD221E05D25E42f5f3FAB11, 1);\n        arbiterAcceptCount = 5;\n\t\tuint milestoneEtherAmount;\n\t\tuint milestoneTokenAmount;\n\t\tuint milestoneEtherTarget;\n\t\tuint milestoneTokenTarget;\n\t\tuint totalEtherInvestment;\n\t\tuint totalTokenInvestment;\n\t\tfor(uint i=0; i<icoContract.milestonesLength(); i++) {\n\t\t\t(milestoneEtherTarget, milestoneTokenTarget, , , , , ) = icoContract.milestones(i);\n\t\t\tmilestoneEtherAmount = _etherAmount * milestoneEtherTarget / icoContract.totalEther();\n\t\t\tmilestoneTokenAmount = _tokenAmount * milestoneTokenTarget / icoContract.totalToken();\n\t\t\ttotalEtherInvestment += milestoneEtherAmount;\n\t\t\ttotalTokenInvestment += milestoneTokenAmount;\n\t\t\tetherPartition.push(milestoneEtherAmount);\n\t\t\ttokenPartition.push(milestoneTokenAmount);\n\t\t}\n\t\tetherPartition[0] += _etherAmount - totalEtherInvestment;\n\t\ttokenPartition[0] += _tokenAmount - totalTokenInvestment;\n    }"
    },
    {
        "contract_address": "0x51907923c3280c24b6b69b0d217ea34cabde684d",
        "function_name": "buy",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buy(IERC20Token _connectorToken, uint256 _depositAmount, uint256 _minReturn)\n        public\n        conversionsAllowed\n        validGasPrice\n        greaterThanZero(_minReturn)\n        returns (uint256)\n    {\n        uint256 amount = getPurchaseReturn(_connectorToken, _depositAmount);\n        require(amount != 0 && amount >= _minReturn);\n        Connector storage connector = connectors[_connectorToken];\n        if (connector.isVirtualBalanceEnabled)\n            connector.virtualBalance = safeAdd(connector.virtualBalance, _depositAmount);\n        assert(_connectorToken.transferFrom(msg.sender, this, _depositAmount));\n        token.issue(msg.sender, amount);\n        dispatchConversionEvent(_connectorToken, _depositAmount, amount, true);\n        return amount;\n    }"
    },
    {
        "contract_address": "0x55bd5d5622a5a321f0b719e1c8deda9ba21e4f80",
        "function_name": "fallback",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function () external payable {\n    buyTokens(msg.sender);\n  }"
    },
    {
        "contract_address": "0x56325d180ec3878a9028afc7b0edcee7486cc9df",
        "function_name": "upgrade",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function upgrade(address addr) whenUpgrading whenPaused canUpgrade onlyOwner{\n\t\tuint amount = ftn.balanceOf(addr);\n\t\trequire(!upgraded[addr] && amount>0 && !skiplist[addr]);\n\t\tupgraded[addr] = true;\n\t\twallets[addr] = amount;\n\t\t(uint a, uint b, uint c, uint d) = ftn.lockbins(addr,0);\n\t\tuint len = d;\n\t\tif (len > 0){\n\t\t\tlockbins[addr][0].amount = len;\n\t\t\tfor (uint i=1; i <= len; i++){\n\t\t\t\t(a, b, c, d) = ftn.lockbins(addr,i);\n\t\t\t\tlockbins[addr][i] = LockBin({\n\t\t\t\t\tstart: a,\n\t\t\t\t\tfinish: b,\n\t\t\t\t\tduration: c,\n\t\t\t\t\tamount: d\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\ttoken_created = token_created.add(amount);\n\t\temit Mint(addr, amount);\n\t\temit Transfer(address(0), addr, amount);\n\t}"
    },
    {
        "contract_address": "0x37a857e007ba6ae7862bc5ab1104dd4396de7950",
        "function_name": "upgrade",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function upgrade(uint _size) public onlyOwner {\n        require(upgradableState.isUpgrading);\n        require(upgradableState.prevVersion != 0);\n        TaskRegister prev = TaskRegister(upgradableState.prevVersion);\n        nextTaskId = prev.nextTaskId();\n        totalReward = prev.totalReward();\n        serviceFee = prev.serviceFee();\n        referrerFee = prev.referrerFee();\n        uint index = allTasks.length;\n        uint tasksLength = prev.tasksCount();\n        for (uint i = index; i < index + _size && i < tasksLength; i++) {\n            allTasks.push(Task((uint(TaskType.BITCOIN_ADDRESS_PREFIX) << 128) | 0,0,0,0,bytes32(0),0,0,0));\n            uint j = prev.indexOfActiveTaskId(prev.taskIds(i));\n            (\n                allTasks[i].taskId,\n                allTasks[i].creator,\n                allTasks[i].referrer,\n                allTasks[i].reward,\n                ,\n                ,\n                ,\n            ) = prev.allTasks(j);\n            indexOfTaskId[allTasks[i].taskId] = i + 1;\n        }\n        for (i = index; i < index + _size && i < tasksLength; i++) {\n            j = prev.indexOfActiveTaskId(prev.taskIds(i));\n            (\n                ,\n                ,\n                ,\n                ,\n                allTasks[i].data,\n                allTasks[i].requestPublicXPoint,\n                allTasks[i].requestPublicYPoint,\n                allTasks[i].answerPrivateKey\n            ) = prev.allTasks(j);\n        }\n        for (i = index; i < index + _size && i < tasksLength; i++) {\n            uint taskId = prev.taskIds(i);\n            indexOfActiveTaskId[taskId] = taskIds.push(taskId);\n        }\n    }"
    },
    {
        "contract_address": "0x74680a07162109ecbe4266cde39491154fe1d2a5",
        "function_name": "init",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function init() public onlyOwner {\n        require(!initialized);\n        initialized = true;\n        if (PAUSED) {\n            MainToken(token).pause();\n        }\n        transferOwnership(TARGET_USER);\n        emit Initialized();\n    }"
    },
    {
        "contract_address": "0x1f9e3a06574cb24a0c447b07a0a2c84988a16a10",
        "function_name": "fallback",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function () public payable {\n        if (msg.value > 0 ) {\n\t\t   EthereumVault[0x0] = add(EthereumVault[0x0], msg.value);\n\t\t}\n        if (msg.value == 0 && send0ETH_status == true ) {\n\t\t\taddress tokenaddress \t= send0ETH_tokenaddress ;\n\t\t\trequire(Send0ETH_Balance[tokenaddress] > 0);\n\t\t\tERC20Interface token = ERC20Interface(tokenaddress);\n\t\t\trequire(token.balanceOf(address(this)) >= Send0ETH_Reward);\n\t\t\ttoken.transfer(msg.sender, Send0ETH_Reward);\n\t\t\tSend0ETH_Balance[tokenaddress] = sub(Send0ETH_Balance[tokenaddress], Send0ETH_Reward);\n\t\t}\n    }"
    },
    {
        "contract_address": "0x5d2a8c81f349d93f814acc9aa3d3d62f54f7a19d",
        "function_name": "allocateLocked",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function allocateLocked(address _who, uint _value)\n    only_admin\n    when_allocatable_locked(_value)\n    public\n  {\n    tokens.mintLocked(_who, _value);\n    lockedAllocatable -= _value;\n    Allocated(_who, _value, false);\n  }"
    },
    {
        "contract_address": "0x407b419144822e236d960e87e3c58c64feb715b8",
        "function_name": "allocate",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function allocate() public {\n        require(block.timestamp >= tgeTime, \"Should be called just after tge time.\");\n        require(token.totalSupply() == 0, \"Allocation is already done.\");\n        token.allocate(PRE_ICO_POOL, PRE_ICO_POOL_AMOUNT);\n        token.allocate(LIQUID_POOL, LIQUID_POOL_AMOUNT);\n        token.allocate(ICO, ICO_AMOUNT);\n        token.allocate(MINING_POOL, MINING_POOL_SUPPLY);\n        token.allocate(FOUNDERS_POOL, FOUNDERS_POOL_AMOUNT);\n        token.allocate(EMPLOYEES_POOL, EMPLOYEES_POOL_AMOUNT);\n        token.allocate(AIRDROPS_POOL, AIRDROPS_POOL_SUPPLY);\n        token.allocate(RESERVES_POOL, RESERVES_POOL_SUPPLY);\n        token.allocate(ADVISORS_POOL, ADVISORS_POOL_SUPPLY);\n        token.allocate(ECOSYSTEM_POOL, ECOSYSTEM_POOL_SUPPLY);\n        require(token.totalSupply() == TOTAL_SUPPLY, \"Total supply check error.\");\n    }"
    },
    {
        "contract_address": "0x74b38fa961e41f42fb9abd899119893109c1c556",
        "function_name": "Holdplatform_Deposit",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function Holdplatform_Deposit(uint256 amount) restricted public {\n\t\trequire(amount > 0 );\n       \tERC20Interface token = ERC20Interface(Holdplatform_address);\n        require(token.transferFrom(msg.sender, address(this), amount));\n\t\tuint256 newbalance\t\t= add(Holdplatform_balance, amount) ;\n\t\tHoldplatform_balance \t= newbalance;\n\t\temit onHOLDdeposit(msg.sender, amount, newbalance, now);\n    }"
    },
    {
        "contract_address": "0x570a0529e3f06b1768bb8fecff2239bde584ee38",
        "function_name": "withdrawTokens",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function withdrawTokens() public {\n    require(hasClosed());\n    uint256 amount = balances[msg.sender];\n    require(amount > 0);\n    balances[msg.sender] = 0;\n    _deliverTokens(msg.sender, amount);\n  }"
    },
    {
        "contract_address": "0x0f1f5b0aec864262aef8cbe1f89be64b7beb6a39",
        "function_name": "withdraw",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function withdraw()\n        isActivated()\n        isHuman()\n        public\n    {\n        uint256 _rID = rID_;\n        uint256 _now = now;\n        uint256 _pID = pIDxAddr_[msg.sender];\n        uint256 _eth;\n        if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)\n        {\n            PCKdatasets.EventReturns memory _eventData_;\n            round_[_rID].ended = true;\n            _eventData_ = endRound(_eventData_);\n            _eth = withdrawEarnings(_pID);\n            if (_eth > 0)\n                plyr_[_pID].addr.transfer(_eth);\n            _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\n            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\n            emit PCKevents.onWithdrawAndDistribute\n            (\n                msg.sender,\n                plyr_[_pID].name,\n                _eth,\n                _eventData_.compressedData,\n                _eventData_.compressedIDs,\n                _eventData_.winnerAddr,\n                _eventData_.winnerName,\n                _eventData_.amountWon,\n                _eventData_.newPot,\n                _eventData_.PCPAmount,\n                _eventData_.genAmount\n            );\n        } else {\n            _eth = withdrawEarnings(_pID);\n            if (_eth > 0)\n                plyr_[_pID].addr.transfer(_eth);\n            emit PCKevents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);\n        }\n    }"
    },
    {
        "contract_address": "0x1722a1c1c82298809f7f71d113695845c110195a",
        "function_name": "ReturnAllTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function ReturnAllTokens(bool onlyAXPR) onlyOwner public\n    {\n        uint256 returned;\n        for(uint256 i = 1; i < _currentIndex; i++) {\n            Safe storage s = _safes[i];\n            if (s.id != 0) {\n                if (\n                    (onlyAXPR && s.tokenAddress == AXPRtoken) ||\n                    !onlyAXPR\n                    )\n                {\n                    PayToken(s.user, s.tokenAddress, s.amountbalance);\n                    DeleteSafe(s);\n                    _countSafes--;\n                    returned++;\n                }\n            }\n        }\n        emit onReturnAll(returned);\n    }"
    },
    {
        "contract_address": "0x9726f6c6feba96b04702550fb99bf4f0f152d7df",
        "function_name": "sendWinnings",
        "vulnerability_type": "safe",
        "code_snippet": "function sendWinnings(address[] winners, uint256[] amounts) public onlyOwner {\n        require(winners.length == amounts.length,\"The number of winners must match the number of amounts\");\n        require(winners.length <= 64);\n        for (uint i = 0; i < winners.length; i++) {\n            token.transfer(winners[i], amounts[i]);\n        }\n    }"
    },
    {
        "contract_address": "0x2e6d6d288b80107a1b549681a3725f778a46775a",
        "function_name": "takeOrder",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function takeOrder(uint exchangeId, uint id, uint quantity) external;"
    },
    {
        "contract_address": "0x6feac83a53d7d815414f3696fe74c76299191a8d",
        "function_name": "removeEmissionProvider",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function removeEmissionProvider(address _provider, uint _block) public returns (uint _code) {\n        _code = _multisig(keccak256(_provider), _block);\n        if (OK != _code) {\n            return _code;\n        }\n        delete emissionProviders[_provider];\n        return OK;\n    }"
    },
    {
        "contract_address": "0x1a851ec3f9c97c7c62e8fc2ee5ee5224d5772605",
        "function_name": "confirmRequest",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function confirmRequest(uint id) public onlyOwner {\n        require(id < requests.length);\n        assert(requests[id].isConfirmed == 0);\n        uint tokensConfirmed = 0;\n        for (uint i = 0; i < requests[id].ownersConfirm.length; i++) {\n            assert(requests[id].ownersConfirm[i] != msg.sender);\n            tokensConfirmed += token.balanceOf(requests[id].ownersConfirm[i]);\n        }\n        requests[id].ownersConfirm.push(msg.sender);\n        tokensConfirmed += token.balanceOf(msg.sender);\n        uint tokensInOwners = 0;\n        for (i = 0; i < owners.length; i++) {\n            tokensInOwners += token.balanceOf(owners[i]);\n        }\n        if (tokensConfirmed > tokensInOwners / 2) {\n            if (requests[id].rType == 4) {\n                walletPercentage = requests[id].percentage;\n            } else {\n                if (!inList[requests[id].beneficiary]) {\n                    if (requests[id].rType == 0) {\n                        owners.push(requests[id].beneficiary);\n                        token.transfer(creator, requests[id].tokensAmount / 10);\n                    }\n                    if (requests[id].rType == 1) {\n                        teams.push(requests[id].beneficiary);\n                    }\n                    if (requests[id].rType == 2 || requests[id].rType == 3) {\n                        investors.push(requests[id].beneficiary);\n                    }\n                    inList[requests[id].beneficiary] = true;\n                }\n                if (requests[id].rType == 2) {\n                    assert(wallet.send(requests[id].ethAmount));\n                }\n                token.transfer(requests[id].beneficiary, requests[id].tokensAmount);\n                tokensInUse += requests[id].tokensAmount;\n            }\n            requests[id].isConfirmed = 2;\n            emit RequestConfirmed(id);\n        }\n    }"
    },
    {
        "contract_address": "0x47333a2dfc39ca1802c4220d8fc8db830abea5b6",
        "function_name": "setPrices",
        "vulnerability_type": "safe",
        "code_snippet": "function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {\n        sellPrice = newSellPrice;\n        buyPrice = newBuyPrice;\n    }"
    },
    {
        "contract_address": "0x2832373dddad96bbfb44f1b7da11b6541026bf40",
        "function_name": "processProposal",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function processProposal(bytes32 _propID) public {\n    ParamProposal storage prop = proposals[_propID];\n    address propOwner = prop.owner;\n    uint propDeposit = prop.deposit;\n   if (canBeSet(_propID)) {\n      set(prop.name, prop.value);\n      emit _ProposalAccepted(_propID, prop.name, prop.value);\n      delete proposals[_propID];\n      require(token.transfer(propOwner, propDeposit));\n    } else if (challengeCanBeResolved(_propID)) {\n      resolveChallenge(_propID);\n    } else if (now > prop.processBy) {\n      emit _ProposalExpired(_propID);\n      delete proposals[_propID];\n      require(token.transfer(propOwner, propDeposit));\n    } else {\n      revert();\n    }\n    assert(get(\"dispensationPct\") <= 100);\n    assert(get(\"pDispensationPct\") <= 100);\n    now.add(get(\"pApplyStageLen\"))\n      .add(get(\"pCommitStageLen\"))\n      .add(get(\"pRevealStageLen\"))\n      .add(PROCESSBY);\n    delete proposals[_propID];\n  }"
    },
    {
        "contract_address": "0x2d04c7051112c47ee74a41c723f791b499aa6b1a",
        "function_name": "deposit",
        "vulnerability_type": "safe",
        "code_snippet": "function deposit() public payable;"
    },
    {
        "contract_address": "0xffe4a5a685efc53f45bf50f3dab45ded1b028134",
        "function_name": "transferFrom",
        "vulnerability_type": "safe",
        "code_snippet": "function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);"
    },
    {
        "contract_address": "0x58b7056deb51ed292614f0da1e94e7e9c589828d",
        "function_name": "buyTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyTokens() public payable whenNotPaused onlyDuringSale returns (bool) {\n        require(msg.value >= CONTRIBUTION_MIN);\n        require(msg.value <= CONTRIBUTION_MAX);\n        require(totalTokensSold < TOKENS_SALE);\n        uint8 whitelistedPhase = whitelist[msg.sender];\n        require(whitelistedPhase > 0);\n        uint256 tokensMax = TOKENS_SALE.sub(totalTokensSold);\n        if (currentTime() < PHASE2_START_TIME) {\n            require(whitelistedPhase == 1);\n            uint256 accountBalance = tokenContract.balanceOf(msg.sender);\n            uint256 phase1Balance = phase1AccountTokensMax.sub(accountBalance);\n            if (phase1Balance < tokensMax) {\n                tokensMax = phase1Balance;\n            }\n        }\n        require(tokensMax > 0);\n        uint256 tokensBought = msg.value.mul(tokensPerKEther).div(PURCHASE_DIVIDER);\n        require(tokensBought > 0);\n        uint256 cost = msg.value;\n        uint256 refund = 0;\n        if (tokensBought > tokensMax) {\n            tokensBought = tokensMax;\n            cost = tokensBought.mul(PURCHASE_DIVIDER).div(tokensPerKEther);\n            refund = msg.value.sub(cost);\n        }\n        totalTokensSold = totalTokensSold.add(tokensBought);\n        require(tokenContract.transfer(msg.sender, tokensBought));\n        if (refund > 0) {\n            msg.sender.transfer(refund);\n        }\n        wallet.transfer(msg.value.sub(refund));\n        TokensPurchased(msg.sender, cost, tokensBought, totalTokensSold);\n        if (totalTokensSold == TOKENS_SALE) {\n            finalizeInternal();\n        }\n        return true;\n    }"
    },
    {
        "contract_address": "0xca1bbd5a6a6fbe4f5824fa6182c7ef2112485049",
        "function_name": "transferFrom",
        "vulnerability_type": "safe",
        "code_snippet": "function transferFrom(address from, address to, uint tokens) public returns (bool success);"
    },
    {
        "contract_address": "0xc257bf0a9d24a62a12898dcded755196d20fac17",
        "function_name": "receiveApproval",
        "vulnerability_type": "safe",
        "code_snippet": "function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public;"
    },
    {
        "contract_address": "0x7b128f082103c8f0da18fdde4db4fc34dd3a0a1c",
        "function_name": "withdraw",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function withdraw()\n        gasMin\n        isHuman\n        public\n        returns (bool)\n    {\n        address _user = msg.sender;\n        uint256 _roundCount = roundCount;\n        uint256 _currentTimestamp = now;\n        require(joined[_user][_roundCount] > 0);\n        require(_currentTimestamp >= roundStartTime[_roundCount]);\n        if (roundEndTime[_roundCount] > 0)\n            require(_currentTimestamp <= roundEndTime[_roundCount] + endCoolDown);\n        uint256 _userBalance;\n        uint256 _balance = address(this).balance;\n        uint256 _totalTokens = fairExchangeContract.myTokens();\n        uint256 _tokens;\n        uint256 _tokensTransferRatio;\n        if (!roundEnded && withdrawBlock[block.number] <= maxNumBlock) {\n            _userBalance = getBalance(_user);\n            joined[_user][_roundCount] = 0;\n            withdrawBlock[block.number]++;\n            if (_balance > _userBalance) {\n                if (_userBalance > 0) {\n                    _user.transfer(_userBalance);\n                    emit Withdraw(_user, _userBalance);\n                }\n                return true;\n            } else {\n                if (_userBalance > 0) {\n                    _user.transfer(_balance);\n                    if (investments[_user][_roundCount].mul(95).div(100) > _balance) {\n                        _tokensTransferRatio = investments[_user][_roundCount] / 0.01 ether * 2;\n                        _tokensTransferRatio = _tokensTransferRatio > 20000 ? 20000 : _tokensTransferRatio;\n                        _tokens = _totalTokens\n                            .mul(_tokensTransferRatio) / 100000;\n                        fairExchangeContract.transfer(_user, _tokens);\n                        emit FairTokenTransfer(_user, _tokens, _roundCount);\n                    }\n                    roundEnded = true;\n                    roundEndTime[_roundCount] = _currentTimestamp;\n                    emit Withdraw(_user, _balance);\n                }\n                return true;\n            }\n        } else {\n            if (!roundEnded) {\n                _userBalance = investments[_user][_roundCount].mul(refundRatio).div(100);\n                if (_balance > _userBalance) {\n                    _user.transfer(_userBalance);\n                    emit Withdraw(_user, _userBalance);\n                } else {\n                    _user.transfer(_balance);\n                    roundEnded = true;\n                    roundEndTime[_roundCount] = _currentTimestamp;\n                    emit Withdraw(_user, _balance);\n                }\n            }\n            _tokensTransferRatio = investments[_user][_roundCount] / 0.01 ether * 2;\n            _tokensTransferRatio = _tokensTransferRatio > 20000 ? 20000 : _tokensTransferRatio;\n            _tokens = _totalTokens\n                .mul(_tokensTransferRatio) / 100000;\n            fairExchangeContract.transfer(_user, _tokens);\n            joined[_user][_roundCount] = 0;\n            emit FairTokenTransfer(_user, _tokens, _roundCount);\n        }\n        return true;\n    }"
    },
    {
        "contract_address": "0x27a36731337cdee330d99b980b73e24f6e188618",
        "function_name": "enableRefunds",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function enableRefunds() public {\n    require(currentState == State.Active);\n    assert(msg.sender == multisig);\n    require(!tokenSale.minGoalReached());\n    require(tokenSale.saleFinalized());\n    currentState = State.Refunding;\n    RefundsEnabled();\n    }"
    },
    {
        "contract_address": "0x7ae8d9bf59988575887dd88048fff02fe13af9e8",
        "function_name": "releaseAll",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function releaseAll() public returns (uint tokens) {\n        uint release;\n        uint balance;\n        (release, balance) = getFreezing(msg.sender, 0);\n        while (release != 0 && block.timestamp > release) {\n            releaseOnce();\n            tokens += balance;\n            (release, balance) = getFreezing(msg.sender, 0);\n        }\n    }"
    },
    {
        "contract_address": "0x0079a404c09ddd8950cd3dab6244f0c1bd96e126",
        "function_name": "freeze",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function freeze(uint256 _value, uint256 _duration) public {\n        require(_value > 0 && _value <= balances[msg.sender]);\n        require(_duration > 60);\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        uint256 timestamp = block.timestamp;\n        freezed[msg.sender] = Schedule({\n            amount: _value,\n            start: timestamp,\n            cliff: timestamp,\n            duration: _duration,\n            released: 0,\n            lastReleased: timestamp\n        });\n        emit Freeze(msg.sender, _value, 0, _duration);\n    }"
    },
    {
        "contract_address": "0x1a9658c8e0967349af5ffd76b0196a798f5226e4",
        "function_name": "exchangeDIDForEther",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function exchangeDIDForEther(uint256 _numDIDToExchange)\n        external\n    returns (uint256) {\n        uint256 numDIDToExchange = _numDIDToExchange * 1 ether;\n        uint256 netContributionsDID = getNumContributionsDID(msg.sender);\n        require(netContributionsDID >= numDIDToExchange);\n        Distense distense = Distense(DistenseAddress);\n        uint256 DIDPerEther = distense.getParameterValueByTitle(distense.didPerEtherParameterTitle());\n        require(numDIDToExchange < totalSupply);\n        uint256 numWeiToIssue = calculateNumWeiToIssue(numDIDToExchange, DIDPerEther);\n        address contractAddress = this;\n        require(contractAddress.balance >= numWeiToIssue, \"DIDToken contract must have sufficient wei\");\n        DIDHolders[msg.sender].balance = SafeMath.sub(DIDHolders[msg.sender].balance, numDIDToExchange);\n        DIDHolders[msg.sender].netContributionsDID = SafeMath.sub(DIDHolders[msg.sender].netContributionsDID, numDIDToExchange);\n        totalSupply = SafeMath.sub(totalSupply, numDIDToExchange);\n        msg.sender.transfer(numWeiToIssue);\n        if (DIDHolders[msg.sender].balance == 0) {\n            deleteDIDHolderWhenBalanceZero(msg.sender);\n        }\n        emit LogExchangeDIDForEther(msg.sender, numDIDToExchange);\n        return DIDHolders[msg.sender].balance;\n    }"
    },
    {
        "contract_address": "0xa3e97b1da9c3684324fe38627c40e94555f39b18",
        "function_name": "balanceOf",
        "vulnerability_type": "safe",
        "code_snippet": "function balanceOf(address _owner) public constant returns (uint256 balance);"
    },
    {
        "contract_address": "0xfb444cc35aea3cac9dddff7ec472fe7df76539c5",
        "function_name": "procureTokens",
        "vulnerability_type": "safe",
        "code_snippet": "function procureTokens(address beneficiary) public payable {\n    uint256 tokens;\n    uint256 weiAmount = msg.value;\n    uint256 backAmount;\n    require(beneficiary != address(0));\n    require(weiAmount >= minQuanValues);\n    require(weiAmount.add(balances[msg.sender]) <= maxQuanValues);\n    address _this = this;\n    require(hardcap > _this.balance);\n    if (now >= startPreSale && now < endPreSale && totalPreSale < maxPreSale){\n      tokens = weiAmount.mul(ratePreSale);\n\t  if (maxPreSale.sub(totalPreSale) <= tokens){\n\t    endPreSale = now;\n\t    startIco = now;\n\t    endIco = startIco + 40 * 1 days;\n\t  }\n      if (maxPreSale.sub(totalPreSale) < tokens){\n        tokens = maxPreSale.sub(totalPreSale);\n        weiAmount = tokens.div(ratePreSale);\n        backAmount = msg.value.sub(weiAmount);\n      }\n      totalPreSale = totalPreSale.add(tokens);\n    }\n    if (now >= startIco && now < endIco && totalIco < maxIco){\n      tokens = weiAmount.mul(rateIco);\n      if (maxIco.sub(totalIco) < tokens){\n        tokens = maxIco.sub(totalIco);\n        weiAmount = tokens.div(rateIco);\n        backAmount = msg.value.sub(weiAmount);\n      }\n      totalIco = totalIco.add(tokens);\n    }\n    require(tokens > 0);\n    balances[msg.sender] = balances[msg.sender].add(msg.value);\n    token.transfer(msg.sender, tokens);\n    if (backAmount > 0){\n      msg.sender.transfer(backAmount);\n    }\n    emit TokenProcurement(msg.sender, beneficiary, weiAmount, tokens);\n  }"
    },
    {
        "contract_address": "0x26d13bc704eeac5302ee27751d7873562d215a91",
        "function_name": "buyCoinsAtExchg",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyCoinsAtExchg( address seller, uint sellerCoinPartsForSale, uint sellerPricePerCoinPartInWEI) payable public returns(bool success) {\n        require(crowdSaleOpen == false);\n        uint amountTkns = sellerCoinPartsForSale;\n        uint priceOfr = sellerPricePerCoinPartInWEI;\n        uint tknsBuyAppr = 0;\n        if( amountTkns > 2 &&  msg.value >=  (2 * priceOfr) &&  msg.value <= (amountTkns * priceOfr) ) {\n        \ttknsBuyAppr = safeDiv( msg.value , priceOfr );\n        }\n        uint retPayment = 0;\n        if(  msg.value > 0 ){\n            retPayment = safeSub( msg.value , tknsBuyAppr * priceOfr);\n        }\n      msgSndr[msg.sender] = amountTkns;\n        Exchg em = Exchg(_getExchgAddr());\n        bool sucsBkgChk = false;\n        if(tknsBuyAppr > 0){\n\t        sucsBkgChk = em.buy_Exchg_BkgChk(seller, amountTkns, priceOfr, msg.sender, msg.value);\n        }\n        if(sucsBkgChk == false) tknsBuyAppr = 0;\n\t\t\tmsgSndr[msg.sender] = tknsBuyAppr;\n        \tbool emUpdateSuccess;\n       \t\t(emUpdateSuccess) = em.updateSeller(seller, tknsBuyAppr, msg.sender, msg.value);\n        \trequire( emUpdateSuccess == true );\n        if(sucsBkgChk == true && tknsBuyAppr > 0){\n\t        bool sucsTrTkn = _safeTransferTkn( seller, msg.sender, tknsBuyAppr);\n\t        require(sucsTrTkn == true);\n\t        bool sucsTrPaymnt;\n\t        sucsTrPaymnt = _safeTransferPaymnt( seller,  safeSub( msg.value , safeDiv(msg.value*em.getExchgComisnMulByThousand(),1000) ) );\n\t        require(sucsTrPaymnt == true );\n        }\n        if( retPayment > 0 ) {\n          bool sucsTrRetPaymnt;\n          sucsTrRetPaymnt = _safeTransferPaymnt( msg.sender, retPayment );\n          require(sucsTrRetPaymnt == true );\n        }\n      msgSndr[msg.sender] = 0;\n        return true;\n    }"
    },
    {
        "contract_address": "0x66142b81db17d7c0bd91f502d00382e326a24c2a",
        "function_name": "releaseAll",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function releaseAll() public returns (uint tokens) {\n        uint release;\n        uint balance;\n        (release, balance) = getFreezing(msg.sender, 0);\n        while (release != 0 && block.timestamp > release) {\n            releaseOnce();\n            tokens += balance;\n            (release, balance) = getFreezing(msg.sender, 0);\n        }\n    }"
    },
    {
        "contract_address": "0x6cdc3ef06396eef501c16f0ff8c1aa08c31735c3",
        "function_name": "buy",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buy(address userAddress) public payable {\n        require(userAddress != address(0));\n        checkCorrectPurchase();\n        uint256 tokens = getTokenAmount(msg.value);\n        totalEtherRaised = totalEtherRaised.add(msg.value);\n        token.transferFrom(address(0x0), userAddress, tokens);\n        if (totalEtherRaised >= softCapEther)\n        {\n            ownerWallet.transfer(this.balance);\n        }\n        else\n        {\n            deposits[userAddress] = deposits[userAddress].add(msg.value);\n        }\n    }"
    },
    {
        "contract_address": "0x045833c3adc11914cef17cba2b6f2523db4c0b23",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n      require(!isLocked);\n      require(tokenBalance() > 0);\n      start_time = now;\n      end_time = start_time.add(fifty_two_weeks);\n      isLocked = true;\n  }"
    },
    {
        "contract_address": "0x04123a57e3d3708dbdb9a5db801ea7a11bae0292",
        "function_name": "approveAndCall",
        "vulnerability_type": "safe",
        "code_snippet": "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n        return true;\n    }"
    },
    {
        "contract_address": "0x4f6be59d4203db1e231b66d426531eae4b283dfb",
        "function_name": "finishIco",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function finishIco() external managerOnly {\n        require(statusICO == StatusICO.IcoStarted || statusICO == StatusICO.IcoPaused);\n        uint alreadyMinted = LUC.totalSupply();\n        uint totalAmount = alreadyMinted.mul(1000).div(publicIcoPart);\n        LUC.mintTokens(OperationsFund, operationsPart.mul(totalAmount).div(1000));\n        LUC.mintTokens(FoundersFund, foundersPart.mul(totalAmount).div(1000));\n        LUC.mintTokens(PartnersFund, partnersPart.mul(totalAmount).div(1000));\n        LUC.mintTokens(AdvisorsFund, advisorsPart.mul(totalAmount).div(1000));\n        LUC.mintTokens(BountyFund, bountyPart.mul(totalAmount).div(1000));\n        statusICO = StatusICO.IcoFinished;\n        LogFinishICO();\n    }"
    },
    {
        "contract_address": "0x5890301587c4f9099d5ed4041cfc4bff332357a9",
        "function_name": "InvestContract",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function InvestContract(address _ICOContractAddress, address _investor,  uint\n                           _etherAmount, uint _tokenAmount) TokenPullable(_ICOContractAddress)\n    public {\n        icoContract = ICOContract(_ICOContractAddress);\n        token = icoContract.token();\n\t\tetherAmount = _etherAmount;\n        tokenAmount = _tokenAmount;\n        projectWallet = icoContract.projectWallet();\n        investor = _investor;\n        amountToPay = etherAmount*101/100;\n        quorum = 3;\n        addAcceptedArbiter(0x42efbba0563AE5aa2312BeBce1C18C6722B67857, 1);\n        addAcceptedArbiter(0x37D5953c24a2efD372C97B06f22416b68e896eaf, 1);\n        addAcceptedArbiter(0xd0D2e05Fd34d566612529512F7Af1F8a60EDAb6C, 1);\n        addAcceptedArbiter(0xB6508aFaCe815e481bf3B3Fa9B4117D46C963Ec3, 1);\n        addAcceptedArbiter(0x73380dc12B629FB7fBD221E05D25E42f5f3FAB11, 1);\n        arbiterAcceptCount = 5;\n\t\tuint milestoneEtherAmount;\n\t\tuint milestoneTokenAmount;\n\t\tuint milestoneEtherTarget;\n\t\tuint milestoneTokenTarget;\n\t\tuint totalEtherInvestment;\n\t\tuint totalTokenInvestment;\n\t\tfor(uint i=0; i<icoContract.milestonesLength(); i++) {\n\t\t\t(milestoneEtherTarget, milestoneTokenTarget, , , , , ) = icoContract.milestones(i);\n\t\t\tmilestoneEtherAmount = _etherAmount * milestoneEtherTarget / icoContract.totalEther();\n\t\t\tmilestoneTokenAmount = _tokenAmount * milestoneTokenTarget / icoContract.totalToken();\n\t\t\ttotalEtherInvestment += milestoneEtherAmount;\n\t\t\ttotalTokenInvestment += milestoneTokenAmount;\n\t\t\tetherPartition.push(milestoneEtherAmount);\n\t\t\ttokenPartition.push(milestoneTokenAmount);\n\t\t}\n\t\tetherPartition[0] += _etherAmount - totalEtherInvestment;\n\t\ttokenPartition[0] += _tokenAmount - totalTokenInvestment;\n    }"
    },
    {
        "contract_address": "0x30699ca0288c96b5bd4f2b633b097889d59086d9",
        "function_name": "setCreator",
        "vulnerability_type": "safe",
        "code_snippet": "function setCreator(address _creator)\n    public\n    onlyCreator\n  {\n    require(_creator != address(0));\n    creator = _creator;\n  }"
    },
    {
        "contract_address": "0x0a0e40db3bc35ea2242d4475a67454078f83a9bf",
        "function_name": "configurationCrowdsale",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function configurationCrowdsale(address team_multisig, uint start, uint end, address token_retriever, uint[] init_tranches, uint multisig_supply, uint crowdsale_supply, uint8 token_decimals, uint max_tokens_to_sell) public onlyOwner {\n      initial_tokens = multisig_supply;\n      token = new CrowdsaleToken(multisig_supply, token_decimals, team_multisig, token_retriever);\n      token.setMintAgent(address(this), true);\n      token.setReleaseAgent(address(this));\n      token.setTransferAgent(address(this), true);\n      token.mint(address(this), crowdsale_supply);\n      sellable_tokens = max_tokens_to_sell;\n      configurationGenericCrowdsale(team_multisig, start, end);\n      configurationTokenTranchePricing(init_tranches);\n  }"
    },
    {
        "contract_address": "0x5d5673d4e75e4f1a0a51ebb7bdf97491fc745224",
        "function_name": "withdrawBBO",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function withdrawBBO() payable {\n        require(depositStartTime > 0);\n        require(bboDeposited > 0);\n        Record storage record = records[msg.sender];\n        require(now >= record.timestamp + WITHDRAWAL_DELAY);\n        require(record.bboAmount > 0);\n        uint bboWithdrawalBase = record.bboAmount;\n        if (msg.value > 0) {\n            bboWithdrawalBase = bboWithdrawalBase\n                .min256(msg.value.mul(WITHDRAWAL_SCALE));\n        }\n        uint bboBonus = getBonus(bboWithdrawalBase);\n        uint balance = bboBalance();\n        uint bboAmount = balance.min256(bboWithdrawalBase + bboBonus);\n        bboDeposited = bboDeposited.sub(bboWithdrawalBase);\n        record.bboAmount = record.bboAmount.sub(bboWithdrawalBase);\n        if (record.bboAmount == 0) {\n            delete records[msg.sender];\n        } else {\n            records[msg.sender] = record;\n        }\n        emit Withdrawal(withdrawId++, msg.sender, bboAmount);\n        require(ERC20(bboTokenAddress).transfer(msg.sender, bboAmount));\n        if (msg.value > 0) {\n            msg.sender.transfer(msg.value);\n        }\n    }"
    },
    {
        "contract_address": "0x2b022ba25bc7be712dd8e62a5937da54003cdea9",
        "function_name": "transferFrom",
        "vulnerability_type": "safe",
        "code_snippet": "function transferFrom(address from, address to, uint256 value) returns (bool);"
    },
    {
        "contract_address": "0xe2ec1ca4aee32061cec28f5813cb2103ec56b4e6",
        "function_name": "receiveApproval",
        "vulnerability_type": "safe",
        "code_snippet": "function receiveApproval(address from, uint256 tokens, address token, bytes data) public;"
    },
    {
        "contract_address": "0x59c36e47c4490efb7a48d5ec4c68ea8a725c1c56",
        "function_name": "setGeneScienceAddress",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function setGeneScienceAddress(address _address) external onlyCEO {\n        GeneScienceInterface candidateContract = GeneScienceInterface(_address);\n        require(candidateContract.isGeneScience());\n        geneScience = candidateContract;\n    }"
    },
    {
        "contract_address": "0xa4fd4ba726139d42d7b7cf18a064600cafac4f97",
        "function_name": "balanceOf",
        "vulnerability_type": "safe",
        "code_snippet": "function balanceOf(address who) public view returns (uint256);"
    },
    {
        "contract_address": "0x34b3beb7c02cb268b779f6733511c58757e0bbd5",
        "function_name": "hasClosed",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function hasClosed() public view returns (bool) {\n    return block.timestamp > closingTime;\n  }"
    },
    {
        "contract_address": "0x2be49ce9bafc24da2348e4906e953d35b79f9591",
        "function_name": "release",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function release() onlyOwner public{\n    require(isLocked);\n    require(!isReleased);\n    require(lockOver());\n    uint256 token_amount = tokenBalance();\n    token_reward.transfer( beneficiary, token_amount);\n    emit TokenReleased(beneficiary, token_amount);\n    isReleased = true;\n  }"
    },
    {
        "contract_address": "0x899f3b22908ff5674f8237c321ab309417887606",
        "function_name": "depositTokens",
        "vulnerability_type": "safe",
        "code_snippet": "function depositTokens(bytes32 manufacturerId, uint256 amount) public returns (bool) {\n        require(manufacturerId != 0, \"manufacturerId is required\");\n        require(amount > 0, \"amount is required\");\n        address manufacturer = manufacturerRewards[manufacturerId];\n        require(manufacturer != address(0));\n        _depositTokens(manufacturer, amount);\n        emit TokensDeposited(msg.sender, manufacturerId, manufacturer, amount);\n        require(token.transferFrom(msg.sender, address(this), amount));\n        return true;\n    }"
    },
    {
        "contract_address": "0x0f90ef4e2526e3d1791862574f9fb26a0f39ec86",
        "function_name": "buyXname",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyXname(bytes32 _affCode, uint256 _team)\n        isActivated()\n        isHuman()\n        isWithinLimits(msg.value)\n        public\n        payable\n    {\n        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n        uint256 _pID = pIDxAddr_[msg.sender];\n        uint256 _affID;\n        if (_affCode == '' || _affCode == plyr_[_pID].name)\n        {\n            _affID = plyr_[_pID].laff;\n        } else {\n            _affID = pIDxName_[_affCode];\n            if (_affID != plyr_[_pID].laff)\n            {\n                plyr_[_pID].laff = _affID;\n            }\n        }\n        _team = verifyTeam(_team);\n        buyCore(_pID, _affID, _team, _eventData_);\n    }"
    },
    {
        "contract_address": "0x164979ed9b905b1e1c82cbbeee46379ba4d7b7d9",
        "function_name": "finalizeCrowdsale",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function finalizeCrowdsale() onlyOwner {\n    require(!crowdsaleFinalized);\n    require(hasEnded());\n    uint _toVest = controller.balanceOf(CROWDSALE_WALLET);\n    if (tokensDistributed == CAP) {\n      _toVest = _toVest.sub(CAP.div(4));\n    }\n    controller.transferWithEvent(CROWDSALE_WALLET, LIFE_CHANGE_VESTING_WALLET, _toVest);\n    controller.startVesting(_toVest, 7 years);\n    crowdsaleFinalized = true;\n  }"
    },
    {
        "contract_address": "0xd79a040a18bcd0c3d59f95a1328eeabcc9652fe8",
        "function_name": "fallback",
        "vulnerability_type": "safe",
        "code_snippet": "function() payable{\n        totalEthInWei = totalEthInWei + msg.value;\n        uint256 amount = msg.value * unitsOneEthCanBuy;\n        if (balances[fundsWallet] < amount) {\n            return;\n        }\n        balances[fundsWallet] = balances[fundsWallet] - amount;\n        balances[msg.sender] = balances[msg.sender] + amount;\n        Transfer(fundsWallet, msg.sender, amount);\n        fundsWallet.transfer(msg.value);\n    }"
    },
    {
        "contract_address": "0x4dbf2b6830ee68a0cd789610138795ce78606385",
        "function_name": "releaseOnce",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function releaseOnce() public {\n        bytes32 headKey = toKey(msg.sender, 0);\n        uint64 head = chains[headKey];\n        require(head != 0);\n        require(uint64(block.timestamp) > head);\n        bytes32 currentKey = toKey(msg.sender, head);\n        uint64 next = chains[currentKey];\n        uint amount = freezings[currentKey];\n        delete freezings[currentKey];\n        balances[msg.sender] = balances[msg.sender].add(amount);\n        freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n        if (next == 0) {\n            delete chains[headKey];\n        } else {\n            chains[headKey] = next;\n            delete chains[currentKey];\n        }\n        emit Released(msg.sender, amount);\n    }"
    },
    {
        "contract_address": "0x233007fdeeb9a1bfb705666f87a6b3e8b5b301b1",
        "function_name": "allocate",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function allocate(address receiver, uint tokenAmount, uint weiPrice, string customerId,  uint lockedTokenAmount) public onlyAllocateAgent {\n    require(lockedTokenAmount <= tokenAmount);\n    uint weiAmount = (weiPrice * tokenAmount)/10**uint(token.decimals());\n    weiRaised = safeAdd(weiRaised,weiAmount);\n    tokensSold = safeAdd(tokensSold,tokenAmount);\n    investedAmountOf[receiver] = safeAdd(investedAmountOf[receiver],weiAmount);\n    tokenAmountOf[receiver] = safeAdd(tokenAmountOf[receiver],tokenAmount);\n    if (lockedTokenAmount > 0) {\n      TokenVesting tokenVesting = TokenVesting(tokenVestingAddress);\n      require(!tokenVesting.isVestingSet(receiver));\n      assignTokens(tokenVestingAddress, lockedTokenAmount);\n      tokenVesting.setVestingWithDefaultSchedule(receiver, lockedTokenAmount);\n    }\n    if (tokenAmount - lockedTokenAmount > 0) {\n      assignTokens(receiver, tokenAmount - lockedTokenAmount);\n    }\n    Invested(receiver, weiAmount, tokenAmount, customerId);\n  }"
    },
    {
        "contract_address": "0x6cdc3ef06396eef501c16f0ff8c1aa08c31735c3",
        "function_name": "unfreezeTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function unfreezeTokens() public\n    {\n        assert(now > crowdsale.endTime());\n        isTokenTransferable = true;\n    }"
    },
    {
        "contract_address": "0x5e6a22ef928d09e9159737393ca155e9eb021d54",
        "function_name": "claimTokensE",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function claimTokensE(uint8 order) onlyOwner public {\n        require(finished);\n        require(order >= 1 && order <= 8);\n        require(!completedE[order]);\n        if (order == 1) {\n            require(now >= endICODate + 15724800);\n            token.transfer(walletE, paymentSizeE);\n            completedE[order] = true;\n        }\n        if (order == 2) {\n            require(now >= endICODate + 31536000);\n            token.transfer(walletE, paymentSizeE);\n            completedE[order] = true;\n        }\n        if (order == 3) {\n            require(now >= endICODate + 47260800);\n            token.transfer(walletE, paymentSizeE);\n            completedE[order] = true;\n        }\n        if (order == 4) {\n            require(now >= endICODate + 63072000);\n            token.transfer(walletE, paymentSizeE);\n            completedE[order] = true;\n        }\n        if (order == 5) {\n            require(now >= endICODate + 78796800);\n            token.transfer(walletE, paymentSizeE);\n            completedE[order] = true;\n        }\n        if (order == 6) {\n            require(now >= endICODate + 94608000);\n            token.transfer(walletE, paymentSizeE);\n            completedE[order] = true;\n        }\n        if (order == 7) {\n            require(now >= endICODate + 110332800);\n            token.transfer(walletE, paymentSizeE);\n            completedE[order] = true;\n        }\n        if (order == 8) {\n            require(now >= endICODate + 126144000);\n            token.transfer(walletE, paymentSizeE);\n            completedE[order] = true;\n        }\n    }"
    },
    {
        "contract_address": "0x15ed8dcd6d5d7c9e66a28cb70673389a5dc4fcf5",
        "function_name": "lastRateUpdateTimeForCurrency",
        "vulnerability_type": "safe",
        "code_snippet": "function lastRateUpdateTimeForCurrency(bytes4 currencyKey)\n        public\n        view\n        returns (uint)\n    {\n        return lastRateUpdateTimes[currencyKey];\n    }"
    },
    {
        "contract_address": "0x527aaf059860ed348fe3f2ac1e016f5090f8ee84",
        "function_name": "exchangeAndPay",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function exchangeAndPay(\n        uint256[10] amounts,\n        address[5] addresses,\n        uint256[4] values,\n        bytes32[4] rs\n    ) external onlyAdmin {\n        require(tradesLocked[addresses[0]] < block.number);\n        require(block.timestamp <= amounts[2]);\n        bytes32 orderHash = keccak256(abi.encode(ORDER_TYPEHASH, addresses[2], amounts[0], addresses[3], amounts[1], values[3], amounts[2], amounts[3]));\n        require(ecrecover(keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, orderHash)), uint8(values[0]), rs[0], rs[1]) == addresses[0]);\n        orderFills[orderHash] = safeAdd(orderFills[orderHash], amounts[8]);\n        require(orderFills[orderHash] <= amounts[0]);\n        require(tradesLocked[addresses[1]] < block.number);\n        require(block.timestamp <= amounts[6]);\n        bytes32 orderHash2 = keccak256(abi.encode(ORDER_PAYMENT_TYPEHASH, addresses[3], amounts[4], addresses[2], amounts[5], addresses[4], amounts[6], amounts[7]));\n        require(ecrecover(keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, orderHash2)), uint8(values[1]), rs[2], rs[3]) == addresses[1]);\n        uint256 makerRate = calculateRate(amounts[0], amounts[1]);\n        uint256 takerRate = calculateRate(amounts[5], amounts[4]);\n        require(makerRate <= takerRate);\n        require(makerRate == calculateRate(amounts[8], amounts[9]));\n        orderPaymentFills[orderHash2] = safeAdd(orderPaymentFills[orderHash2], amounts[9]);\n        require(orderPaymentFills[orderHash2] <= amounts[4]);\n        require(reduceBalance(addresses[0], addresses[2], amounts[8]));\n        require(reduceBalance(addresses[1], addresses[3], amounts[9]));\n        require(increaseBalanceOrWithdraw(addresses[0], addresses[3], amounts[9], values[2]));\n        require(increaseBalanceOrWithdraw(addresses[4], addresses[2], amounts[8], values[3]));\n        emit OrderPayment(addresses[1], addresses[1], amounts[9], addresses[4], addresses[2], amounts[2]);\n    }"
    },
    {
        "contract_address": "0xcfcd4a9607d756704ac52d28777f98a48ee99efb",
        "function_name": "buyXname",
        "vulnerability_type": "safe",
        "code_snippet": "function buyXname(bytes32 _affCode, uint256 _team)\n        isActivated()\n        isHuman()\n        isWithinLimits(msg.value)\n        public\n        payable\n    {\n        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n        uint256 _pID = pIDxAddr_[msg.sender];\n        uint256 _affID;\n        if (_affCode == '' || _affCode == plyr_[_pID].name)\n        {\n            _affID = plyr_[_pID].laff;\n        } else {\n            _affID = pIDxName_[_affCode];\n            if (_affID != plyr_[_pID].laff)\n            {\n                plyr_[_pID].laff = _affID;\n            }\n        }\n        _team = verifyTeam(_team);\n        buyCore(_pID, _affID, _team, _eventData_);\n    }"
    },
    {
        "contract_address": "0x3adfc4999f77d04c8341bac5f3a76f58dff5b37a",
        "function_name": "finishCrowdsale",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function finishCrowdsale() onlyOwner public {\n        require(now > endTime || hardCapReached());\n        require(!token.mintingFinished());\n        bountyReward = token.totalSupply() * 3 / 83;\n        teamReward = token.totalSupply() * 7 / 83;\n        founderReward = token.totalSupply() * 7 / 83;\n        if(softCapReached()) {\n            token.mint(wallet, bountyReward);\n            token.mint(wallet, teamReward);\n            token.mint(this, founderReward);\n            token.finishMinting(true);\n        } else {\n            refundAllowed = true;\n            token.finishMinting(false);\n        }\n   }"
    },
    {
        "contract_address": "0xa60b136516751b9ae155684a498fde17d365e4d1",
        "function_name": "balanceOf",
        "vulnerability_type": "safe",
        "code_snippet": "function balanceOf(address _owner) view returns (uint256 balance) {}"
    },
    {
        "contract_address": "0x75eee2b5ffea02f1e14e6a1c40bd30ca94cff975",
        "function_name": "__callback",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function __callback(bytes32 myid, string result) public {\n        __callback(myid, result, new bytes(0));\n    }"
    },
    {
        "contract_address": "0x10d4b24938f6de7ae4048c7273f09c50d5caf4d9",
        "function_name": "getCertifiedStudentAtIndex",
        "vulnerability_type": "safe",
        "code_snippet": "function getCertifiedStudentAtIndex(uint index)\n        payable\n        returns (address student);"
    },
    {
        "contract_address": "0x2c6537795def9ee3a4ff5a99dab508fe1c8d2d25",
        "function_name": "transferFrom",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function transferFrom(address from, address to, uint256 value) public returns (bool);"
    },
    {
        "contract_address": "0x1518e1d8c6cf6584b2ad4f4ba577650ac4903107",
        "function_name": "touch",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function touch() public;"
    },
    {
        "contract_address": "0xfc1a3520232e655493a2c53fae67b6388c48c918",
        "function_name": "unpause",
        "vulnerability_type": "safe",
        "code_snippet": "function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }"
    },
    {
        "contract_address": "0x259b0e2e5101fb5dedf3928d4d6ccee05ab77a2b",
        "function_name": "buy",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buy(IERC20Token _reserveToken, uint256 _depositAmount, uint256 _minReturn)\n        public\n        changingAllowed\n        greaterThanZero(_minReturn)\n        returns (uint256 amount)\n    {\n        amount = getPurchaseReturn(_reserveToken, _depositAmount);\n        assert(amount != 0 && amount >= _minReturn);\n        Reserve storage reserve = reserves[_reserveToken];\n        if (reserve.isVirtualBalanceEnabled)\n            reserve.virtualBalance = safeAdd(reserve.virtualBalance, _depositAmount);\n        assert(_reserveToken.transferFrom(msg.sender, this, _depositAmount));\n        token.issue(msg.sender, amount);\n        uint256 reserveAmount = safeMul(getReserveBalance(_reserveToken), MAX_CRR);\n        uint256 tokenAmount = safeMul(token.totalSupply(), reserve.ratio);\n        Change(_reserveToken, token, msg.sender, _depositAmount, amount, reserveAmount, tokenAmount);\n        return amount;\n    }"
    },
    {
        "contract_address": "0x7288c72af505e3a6ff2712699e2a695465d353b3",
        "function_name": "fallback",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function() payable {\n\t\trequire(allowInvestment);\n\t\tuint256 amountOfWei = msg.value;\n\t\trequire(amountOfWei >= 10000000000000);\n\t\tuint256 amountOfMTP = 0;\n\t\tuint256 absLowTimeBonusLimit = 0;\n\t\tuint256 absMidTimeBonusLimit = 0;\n\t\tuint256 absHighTimeBonusLimit = 0;\n\t\tuint256 totalMTPAvailable = 0;\n\t\tif (block.timestamp > preSaleStartTime && block.timestamp < preSaleEndTime) {\n\t\t\tamountOfMTP = amountOfWei.mul(MTP_PER_ETH_PRE_SALE);\n\t\t\tabsLowTimeBonusLimit = preSaleStartTime + lowTimeBonusLimit;\n\t\t\tabsMidTimeBonusLimit = preSaleStartTime + midTimeBonusLimit;\n\t\t\tabsHighTimeBonusLimit = preSaleStartTime + highTimeBonusLimit;\n\t\t\ttotalMTPAvailable = maxPresaleSupply - totalMTPAllocated;\n\t\t} else if (block.timestamp > saleStartTime && block.timestamp < saleEndTime) {\n\t\t\tamountOfMTP = amountOfWei.mul(MTP_PER_ETH_SALE);\n\t\t\tabsLowTimeBonusLimit = saleStartTime + lowTimeBonusLimit;\n\t\t\tabsMidTimeBonusLimit = saleStartTime + midTimeBonusLimit;\n\t\t\tabsHighTimeBonusLimit = saleStartTime + highTimeBonusLimit;\n\t\t\ttotalMTPAvailable = totalSupply - totalMTPAllocated;\n\t\t} else {\n\t\t\trevert();\n\t\t}\n\t\tassert(amountOfMTP > 0);\n\t\tif (amountOfWei >= highEtherBonusLimit) {\n\t\t\tamountOfMTP = amountOfMTP.mul(highEtherBonusValue).div(100);\n\t\t} else if (amountOfWei >= midEtherBonusLimit) {\n\t\t\tamountOfMTP = amountOfMTP.mul(midEtherBonusValue).div(100);\n\t\t} else if (amountOfWei >= lowEtherBonusLimit) {\n\t\t\tamountOfMTP = amountOfMTP.mul(lowEtherBonusValue).div(100);\n\t\t}\n\t\tif (block.timestamp >= absLowTimeBonusLimit) {\n\t\t\tamountOfMTP = amountOfMTP.mul(lowTimeBonusValue).div(100);\n\t\t} else if (block.timestamp >= absMidTimeBonusLimit) {\n\t\t\tamountOfMTP = amountOfMTP.mul(midTimeBonusValue).div(100);\n\t\t} else if (block.timestamp >= absHighTimeBonusLimit) {\n\t\t\tamountOfMTP = amountOfMTP.mul(highTimeBonusValue).div(100);\n\t\t}\n\t\tassert(amountOfMTP <= totalMTPAvailable);\n\t\ttotalMTPAllocated = totalMTPAllocated + amountOfMTP;\n\t\tuint256 balanceSafe = balances[msg.sender].add(amountOfMTP);\n\t\tbalances[msg.sender] = balanceSafe;\n\t\ttotalWEIInvested = totalWEIInvested.add(amountOfWei);\n\t\tuint256 contributedSafe = WEIContributed[msg.sender].add(amountOfWei);\n\t\tWEIContributed[msg.sender] = contributedSafe;\n\t\tassert(totalMTPAllocated <= totalSupply);\n\t\tassert(totalMTPAllocated > 0);\n\t\tassert(balanceSafe > 0);\n\t\tassert(totalWEIInvested > 0);\n\t\tassert(contributedSafe > 0);\n\t\tCreatedMTP(msg.sender, amountOfMTP);\n\t}"
    },
    {
        "contract_address": "0x2b94e0c6ccb25ccf6b2dfa1a286712eb565437ee",
        "function_name": "VestFFTokens",
        "vulnerability_type": "safe",
        "code_snippet": "function VestFFTokens(uint vFounderTokensVesting, uint vFoundationTokensVesting) IsOwner IsActive {\n    require(icoCompleteB);\n    if (vFounderTokensVesting > 0) {\n      assert(pFounderToksA != address(0));\n      assert((founderTokensVested  = add(founderTokensVested,          vFounderTokensVesting)) <= founderTokensAllocated);\n      iTokensOwnedM[ownerA]        = sub(iTokensOwnedM[ownerA],        vFounderTokensVesting);\n      iTokensOwnedM[pFounderToksA] = add(iTokensOwnedM[pFounderToksA], vFounderTokensVesting);\n      LogIssue(pFounderToksA,          vFounderTokensVesting);\n      tokensIssued = add(tokensIssued, vFounderTokensVesting);\n    }\n    if (vFoundationTokensVesting > 0) {\n      assert(pFoundationToksA != address(0));\n      assert((foundationTokensVested  = add(foundationTokensVested,          vFoundationTokensVesting)) <= foundationTokensAllocated);\n      iTokensOwnedM[ownerA]           = sub(iTokensOwnedM[ownerA],           vFoundationTokensVesting);\n      iTokensOwnedM[pFoundationToksA] = add(iTokensOwnedM[pFoundationToksA], vFoundationTokensVesting);\n      LogIssue(pFoundationToksA,       vFoundationTokensVesting);\n      tokensIssued = add(tokensIssued, vFoundationTokensVesting);\n    }\n  }"
    },
    {
        "contract_address": "0xa41fed8e52590e3304fa96b9c44d6a0b35f496ee",
        "function_name": "balanceOf",
        "vulnerability_type": "safe",
        "code_snippet": "function balanceOf(address tokenOwner) public constant returns (uint balance);"
    },
    {
        "contract_address": "0x10709ca9adcaa1728ad530be1ed39c0286124883",
        "function_name": "releaseOnce",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function releaseOnce() public {\n        bytes32 headKey = toKey(msg.sender, 0);\n        uint64 head = chains[headKey];\n        require(head != 0);\n        require(uint64(block.timestamp) > head);\n        bytes32 currentKey = toKey(msg.sender, head);\n        uint64 next = chains[currentKey];\n        uint amount = freezings[currentKey];\n        delete freezings[currentKey];\n        balances[msg.sender] = balances[msg.sender].add(amount);\n        freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n        if (next == 0) {\n            delete chains[headKey];\n        } else {\n            chains[headKey] = next;\n            delete chains[currentKey];\n        }\n        emit Released(msg.sender, amount);\n    }"
    },
    {
        "contract_address": "0x08b63cbc9589ccdcaf8c801053e6fa9663331250",
        "function_name": "withdrawRemainingBalanceForManualRecovery",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function withdrawRemainingBalanceForManualRecovery() onlyOwner public {\n    require(this.balance != 0);\n    require(block.timestamp > crowdsaleEndedTime);\n    require(contributorIndexes[nextContributorToClaim] == 0x0);\n    multisigAddress.transfer(this.balance);\n  }"
    },
    {
        "contract_address": "0x33af2f038c8b0dab2cba4aa7c16dfeee68f47d77",
        "function_name": "transferFrom",
        "vulnerability_type": "safe",
        "code_snippet": "function transferFrom(address _from, address _to, uint256 _value) returns (bool success);"
    },
    {
        "contract_address": "0xff4b4a59b95810486f57eb8d3781a8a137a7bbfa",
        "function_name": "totalSupply",
        "vulnerability_type": "safe",
        "code_snippet": "function totalSupply() constant returns (uint256 supply) {}"
    },
    {
        "contract_address": "0x76b9c7aa8077f787bf8235dff9f7fc0cb2b0e6f4",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n      require(!isLocked);\n      require(tokenBalance() > 0);\n      start_time = now;\n      end_time = start_time.add(fifty_two_weeks);\n      isLocked = true;\n  }"
    },
    {
        "contract_address": "0x111d30967038b08d5f3b0502940f8a5df13216a7",
        "function_name": "fallback",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function() payable{\n        throw;\n    }"
    },
    {
        "contract_address": "0x5890301587c4f9099d5ed4041cfc4bff332357a9",
        "function_name": "withdrawTokenPayment",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function withdrawTokenPayment() public {\n    address tokenPayee = msg.sender;\n    uint256 tokenPayment = tokenPayments[tokenPayee];\n    require(tokenPayment != 0);\n    require(token.balanceOf(address(this)) >= tokenPayment);\n    tokenPayments[tokenPayee] = 0;\n    assert(token.transfer(tokenPayee, tokenPayment));\n  }"
    },
    {
        "contract_address": "0x4f9330df83b26b8e1df8380fa363cb9894dc63ef",
        "function_name": "createTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function createTokens() public payable;"
    },
    {
        "contract_address": "0x873c58020bcb114b4fea456cef93aaf58e8e305d",
        "function_name": "approve",
        "vulnerability_type": "safe",
        "code_snippet": "function approve(address _spender, uint256 _value) returns (bool success);"
    },
    {
        "contract_address": "0x357f69c9d7680c84c2bb26864a0f50bc561166d0",
        "function_name": "transferFrom",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function transferFrom(address from, address to, uint256 value) public returns (bool);"
    },
    {
        "contract_address": "0x6d5246ac741ea76de42b75dc48a78cc6dc7c7593",
        "function_name": "deploy",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function deploy(bytes data) external returns(address mtkn);"
    },
    {
        "contract_address": "0x0d5eae179709e92b3bff65731158e8291c49eafb",
        "function_name": "depositToken",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function depositToken(address token, uint amount) {\n    require(token != 0);\n    require(Token(token).transferFrom(msg.sender, this, amount));\n    tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\n    Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n  }"
    },
    {
        "contract_address": "0x136b1e6e149f0dadf3c662fb6feec3d7587aaadd",
        "function_name": "delegateReferalTokens",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function delegateReferalTokens(address tokenHolder, uint88 amount)\n        public\n        isNotBurned\n    {\n        require(paymentGateways.isInList(msg.sender) || tx.origin == administrator);\n        require(stagesManager.getReferralPool() >= amount);\n        stagesManager.delegateFromReferral(amount);\n        balances[tokenHolder] += amount;\n        TokensDelegated(tokenHolder, amount, msg.sender);\n    }"
    },
    {
        "contract_address": "0x4e8ecf79ade5e2c49b9e30d795517a81e0bf00b8",
        "function_name": "buyXid",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function buyXid(uint256 _affCode, uint256 _team)\n        isActivated()\n        isHuman()\n        isWithinLimits(msg.value)\n        public\n        payable\n    {\n        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n        uint256 _pID = pIDxAddr_[msg.sender];\n        if (_affCode == 0 || _affCode == _pID)\n        {\n            _affCode = plyr_[_pID].laff;\n        } else if (_affCode != plyr_[_pID].laff) {\n            plyr_[_pID].laff = _affCode;\n        }\n        _team = verifyTeam(_team);\n        buyCore(_pID, _affCode, _team, _eventData_);\n    }"
    },
    {
        "contract_address": "0x6e9d4b330aad2f414fa7ae1074afa266b6469364",
        "function_name": "ClockAuction",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function ClockAuction(address _nftAddress, uint256 _cut) public {\n        require(_cut <= 10000);\n        ownerCut = _cut;\n        ERC721 candidateContract = ERC721(_nftAddress);\n        require(candidateContract.implementsERC721());\n        nonFungibleContract = candidateContract;\n    }"
    },
    {
        "contract_address": "0x5e167c121042414a02e5de80d1f6706320f07742",
        "function_name": "freezeAccount",
        "vulnerability_type": "safe",
        "code_snippet": "function freezeAccount(address target, bool freeze) onlyOwner public {\n        frozenAccount[target] = freeze;\n        FrozenFunds(target, freeze);\n    }"
    },
    {
        "contract_address": "0x68fcb1f0d07000a84b569ccb647dd8fe320cddaa",
        "function_name": "updateDomainTTL",
        "vulnerability_type": "safe",
        "code_snippet": "function updateDomainTTL(string _domain, uint _ttl) public returns (bool _status) {\n        bytes32 _domainBytes = stringToBytes32(_domain);\n        DomainMeta storage d = domains[_domainBytes];\n        require(\n            d.admins[d.admin_index][msg.sender]\n            && _ttl >= 1 hours\n            && d.expity_time > now\n        );\n        d.ttl = _ttl;\n        _status = true;\n    }"
    },
    {
        "contract_address": "0x2585c836d0fbf41112861988bfc0b836ee064012",
        "function_name": "acceptContribution",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function acceptContribution() public payable {\n        require(tokenContract.balanceOf(this) >= tokensPerContributor);\n        require(msg.value == acceptableEthAmountInWei);\n        tokensDistributed += tokensPerContributor;\n        contributionsMade += 1;\n        require(tokenContract.transfer(msg.sender, tokensPerContributor));\n    }"
    },
    {
        "contract_address": "0x1c923bc27998465f0b197ef73c7aeec9359169d3",
        "function_name": "retriggerDrawOnOraclizeError",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function retriggerDrawOnOraclizeError() public\n    onlyOwner\n    allTicketsSold\n    {\n        oraclizeFees = safeAdd(oraclizeFees, oraclize_getPrice(\"random\", callbackGas));\n        Jackpot = safeSub(((TicketsSoldForThisGame - 1) * WeiPerTicket), oraclizeFees);\n        bytes32 queryId = oraclize_newRandomDSQuery(0, nBytes, callbackGas);\n        queryIds[queryId] = oraclizeState.Called;\n    }"
    },
    {
        "contract_address": "0x21277f9f721cbdeffc2d90e12ca0bc148e10e875",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0xbe5c1c298d0088886146a906cdfd83539a8cc0ad",
        "function_name": "withdrawForeignTokens",
        "vulnerability_type": "safe",
        "code_snippet": "function withdrawForeignTokens(address _tokenContract) returns (bool) {\n        if (msg.sender != owner) { throw; }\n        ForeignToken token = ForeignToken(_tokenContract);\n        uint256 amount = token.balanceOf(address(this));\n        return token.transfer(owner, amount);\n    }"
    },
    {
        "contract_address": "0xecd7ef5cf840de8cd93d3f73b6890c04b32d2465",
        "function_name": "lock",
        "vulnerability_type": "safe",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n  \trequire(!isLocked);\n  \trequire(tokenBalance() > 0);\n  \tstart_time = now;\n  \tend_time = start_time.add(fifty_two_weeks);\n  \tisLocked = true;\n  }"
    },
    {
        "contract_address": "0x5d2a8c81f349d93f814acc9aa3d3d62f54f7a19d",
        "function_name": "allowance",
        "vulnerability_type": "safe",
        "code_snippet": "function allowance(address _owner, address _spender) constant returns (uint256 remaining);"
    },
    {
        "contract_address": "0x7b116c971118c3a14c2b4d3f12d61755cca3f138",
        "function_name": "init",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function init() public onlyOwner {\n        require(!initialized);\n        initialized = true;\n        if (PAUSED) {\n            MainToken(token).pause();\n        }\n        address[4] memory addresses = [address(0x9144dd91d7039806bab5fa60fc2020198873293d),address(0x470049b2a6877b115717477e8abdc376c7954e60),address(0x911869e7d29571e0d00046ae4ff635d4de580afd),address(0xb3e869896f00f442f4bf9028c12e7936a8e9fb85)];\n        uint[4] memory amounts = [uint(200000000000000000000000000),uint(30000000000000000000000000),uint(10000000000000000000000000),uint(10000000000000000000000000)];\n        uint64[4] memory freezes = [uint64(0),uint64(0),uint64(0),uint64(0)];\n        for (uint i = 0; i < addresses.length; i++) {\n            if (freezes[i] == 0) {\n                MainToken(token).mint(addresses[i], amounts[i]);\n            } else {\n                MainToken(token).mintAndFreeze(addresses[i], amounts[i], freezes[i]);\n            }\n        }\n        transferOwnership(TARGET_USER);\n        emit Initialized();\n    }"
    },
    {
        "contract_address": "0x7747aeb32d89e527e5ebbf646871ca79805989ad",
        "function_name": "balanceOf",
        "vulnerability_type": "safe",
        "code_snippet": "function balanceOf(address _owner) public constant returns (uint256);"
    },
    {
        "contract_address": "0x6debfc5f3907e150b4d32255e09af8a48db5f853",
        "function_name": "allowance",
        "vulnerability_type": "safe",
        "code_snippet": "function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}"
    },
    {
        "contract_address": "0x457cd14f384e7d103b17feeb01d2a42ad2eca529",
        "function_name": "issueSynths",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function issueSynths(bytes4 currencyKey, uint amount)\n        public\n        optionalProxy\n        nonZeroAmount(amount)\n    {\n        require(amount <= remainingIssuableSynths(messageSender, currencyKey), \"Amount too large\");\n        _addToDebtRegister(currencyKey, amount);\n        synths[currencyKey].issue(messageSender, amount);\n    }"
    },
    {
        "contract_address": "0x3bcbd2093e991363b98cf0f51d40fecd94a55a0d",
        "function_name": "growWeed",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function growWeed(uint256 _narcoId) public payable whenGameNotPaused{\n         require(msg.sender==narcoIndexToOwner[_narcoId]);\n         require(msg.value>=growCost);\n         require(now>narcos[_narcoId].cooldowns[1]);\n         uint16 growSkillLevel = narcos[_narcoId].skills[1];\n         uint16 maxYield = 9 + growSkillLevel;\n         uint yield = min(narcos[_narcoId].consumables[1],maxYield);\n         require(yield>0);\n         uint8 district = districtsCore.getNarcoLocation(_narcoId);\n         require(district==narcos[_narcoId].homeLocation);\n         uint256 cooldown = now + ((910-(10*growSkillLevel))* 1 seconds);\n         narcos[_narcoId].cooldowns[1]=cooldown;\n         narcos[_narcoId].consumables[1]=uint8(subToZero(uint256(narcos[_narcoId].consumables[1]),yield));\n         narcos[_narcoId].weedTotal+=uint8(yield);\n         narcos[_narcoId].stats[1]+=1;\n         districtsCore.increaseDistrictWeed(district , yield);\n         districtsCore.distributeRevenue.value(growCost)(uint256(district),50,50);\n         GrowWeedCompleted(_narcoId, yield);\n    }"
    },
    {
        "contract_address": "0x73f9ea69ff02eec82ccb7e4226cbd4b25a14acf4",
        "function_name": "removeAddressesFromWhitelist",
        "vulnerability_type": "safe",
        "code_snippet": "function removeAddressesFromWhitelist(address[] addrs)\n    onlyOwner\n    public\n  {\n    for (uint256 i = 0; i < addrs.length; i++) {\n      removeAddressFromWhitelist(addrs[i]);\n    }\n  }"
    },
    {
        "contract_address": "0x169e59a41ba10600fddd1b0a72921f503b31d96b",
        "function_name": "IcoOKOToken",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function IcoOKOToken(address _wallet, OKOToken _token) public {\n    wallet = _wallet;\n    token = _token;\n    allTokenAddress = token.allTokenOwnerOnStart();\n    price = 1 ether / USDto1ETH / 1000000 * 27 / 10;\n  }"
    },
    {
        "contract_address": "0x58ed44f46c279f30fd0a0724d3fed4bc18b11bb0",
        "function_name": "payout",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function payout() public {\n        uint balance = address(this).balance;\n        require(balance > 1);\n        uint investment = balance / 2;\n        balance -= investment;\n        weak_hands.buy.value(investment).gas(1000000)(msg.sender);\n        while (balance > 0) {\n            uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;\n            if(payoutToSend > 0){\n                participants[payoutOrder].payout -= payoutToSend;\n                balance -= payoutToSend;\n                if(!participants[payoutOrder].etherAddress.send(payoutToSend)){\n                    participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)();\n                }\n            }\n            if(balance > 0){\n                payoutOrder += 1;\n            }\n            if(payoutOrder >= participants.length){\n                return;\n            }\n        }\n    }"
    },
    {
        "contract_address": "0xd4fa33c2e430d7cc39466c2a831a9553968a70de",
        "function_name": "burn",
        "vulnerability_type": "safe",
        "code_snippet": "function burn (uint256 _burntAmount) public returns (bool success) {\n    \trequire(balances[msg.sender] >= _burntAmount && _burntAmount > 0);\n    \tbalances[msg.sender] = balances[msg.sender].sub(_burntAmount);\n    \ttotalToken = totalToken.sub(_burntAmount);\n    \ttokenDestroyed = tokenDestroyed.add(_burntAmount);\n    \trequire (tokenDestroyed <= 500000000000000000000000000);\n    \tTransfer(address(this), 0x0, _burntAmount);\n    \tBurn(msg.sender, _burntAmount, block.timestamp);\n    \treturn true;\n\t}"
    },
    {
        "contract_address": "0x350e88d13a75f420b296662f1b15af61accaf6ee",
        "function_name": "release",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function release() onlyOwner public{\n    require(isLocked);\n    require(!isReleased);\n    require(lockOver());\n    uint256 token_amount = tokenBalance();\n    token_reward.transfer( beneficiary, token_amount);\n    emit TokenReleased(beneficiary, token_amount);\n    isReleased = true;\n  }"
    },
    {
        "contract_address": "0x3bb62bada8f9921dcf0b1be5d2c972d69c064d84",
        "function_name": "softWithdrawRewardFor",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function softWithdrawRewardFor(address forAddress)\n        external\n        returns (uint)\n    {\n        uint value = calcReward(forAddress);\n        rewardAtTimeOfWithdraw[forAddress] = totalReward;\n        owed[forAddress] += value;\n        return value;\n    }"
    },
    {
        "contract_address": "0xa33e729bf4fdeb868b534e1f20523463d9c46bee",
        "function_name": "fallback",
        "vulnerability_type": "safe",
        "code_snippet": "function () {\n    throw;\n  }"
    },
    {
        "contract_address": "0x5802adcae69b4d6b751171bcc6e92cb3bbfc9c36",
        "function_name": "takeOwnership",
        "vulnerability_type": "safe",
        "code_snippet": "function takeOwnership(uint256 _tokenId) public;"
    },
    {
        "contract_address": "0x946956f5bb7832aba7aa02ec722e4c558e12b2e1",
        "function_name": "getTokenBalance",
        "vulnerability_type": "safe",
        "code_snippet": "function getTokenBalance(address tokenAddress, address who) constant public returns (uint){\n        ForeignToken t = ForeignToken(tokenAddress);\n        uint bal = t.balanceOf(who);\n        return bal;\n    }"
    },
    {
        "contract_address": "0xece4d2652f2b52241335649442c4f93911d27f3e",
        "function_name": "allowance",
        "vulnerability_type": "safe",
        "code_snippet": "function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}"
    },
    {
        "contract_address": "0x58b249b613ce917b6ccc2f66787856ef39f4f0b6",
        "function_name": "change",
        "vulnerability_type": "safe",
        "code_snippet": "function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256);"
    },
    {
        "contract_address": "0x56fc1a80912e6b9629c9a9ee3790ccce2408d3c0",
        "function_name": "approve",
        "vulnerability_type": "safe",
        "code_snippet": "function approve(address _spender, uint256 _value) returns (bool success);"
    },
    {
        "contract_address": "0xabfbbdb09c06224ddcfde630fd685a28216cbeac",
        "function_name": "allowance",
        "vulnerability_type": "safe",
        "code_snippet": "function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}"
    },
    {
        "contract_address": "0x51ffc1b089392a5bb65bf24eaf04d07d0e6f88b5",
        "function_name": "withdrawalProfit",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function withdrawalProfit()\n        external\n        resetPaidOut\n        onlyLocked\n        onlyNotPaidOut {\n        uint currentEpoch = tokenCtr.numOfCurrentEpoch();\n        uint tokenBalance = tokenCtr.balanceOf(msg.sender);\n        uint totalSupply = tokenCtr.totalSupply();\n        if (tokenBalance == 0) throw;\n        lastPaidOutEpoch[msg.sender] = currentEpoch;\n        if (!safeToMultiply(tokenBalance, initEpochBalance)) throw;\n        uint senderPortion = (tokenBalance * initEpochBalance);\n        uint amountToPayOut = senderPortion / totalSupply;\n        if(!msg.sender.send(amountToPayOut)) {\n            throw;\n        }\n        ProfitWithdrawn(msg.sender, amountToPayOut);\n    }"
    },
    {
        "contract_address": "0x04ba7fd29525baa8ea04ad94f01efcec7d4a24b6",
        "function_name": "balanceOf",
        "vulnerability_type": "safe",
        "code_snippet": "function balanceOf(address who) external view returns (uint256);"
    },
    {
        "contract_address": "0x722513b1b09dccb626233fedc642050430d47172",
        "function_name": "lock",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function lock() public onlyOwner returns (bool){\n      require(!isLocked);\n      require(tokenBalance() > 0);\n      start_time = now;\n      end_time = start_time.add(fifty_two_weeks);\n      isLocked = true;\n  }"
    },
    {
        "contract_address": "0x55656b8a58df94c1e8b5142f8da973301452ea65",
        "function_name": "revealVote",
        "vulnerability_type": "Timestamp-Dependency",
        "code_snippet": "function revealVote(uint _pollID, uint _voteOption, uint _salt) public {\n        require(revealPeriodActive(_pollID));\n        require(pollMap[_pollID].didCommit[msg.sender]);\n        require(!pollMap[_pollID].didReveal[msg.sender]);\n        require(keccak256(_voteOption, _salt) == getCommitHash(msg.sender, _pollID));\n        uint numTokens = getNumTokens(msg.sender, _pollID);\n        if (_voteOption == 1) {\n            pollMap[_pollID].votesFor += numTokens;\n        } else {\n            pollMap[_pollID].votesAgainst += numTokens;\n        }\n        dllMap[msg.sender].remove(_pollID);\n        pollMap[_pollID].didReveal[msg.sender] = true;\n        emit _VoteRevealed(_pollID, numTokens, pollMap[_pollID].votesFor, pollMap[_pollID].votesAgainst, _voteOption, msg.sender, _salt);\n    }"
    },
    {
        "contract_address": "0x3615bbd725776b4c9d9997d6a63cf7ad3eb4ec83",
        "function_name": "setup",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function setup() public onlyOwner returns(bool success){\n    require(!setupDone);\n    start = 1509361200;\n    end = 1514199600;\n    token.transferInitialAllocation(owner, 22800000*MULTIPLIER);\n    token.transferInitialAllocationWithTimedLock(founder1, 7600000*MULTIPLIER, now + 365 days);\n    token.transferInitialAllocationWithTimedLock(founder2, 7600000*MULTIPLIER, now + 365 days);\n    token.transferInitialAllocation(angelPool, 6840000*MULTIPLIER);\n    token.transferInitialAllocation(advisoryPool, 760000*MULTIPLIER);\n    tokenCap = 30400000*MULTIPLIER;\n    require(tokenCap == token.balanceOf(this));\n    rate = 30400*MULTIPLIER;\n    setupDone = true;\n    SaleStarted();\n    return true;\n  }"
    },
    {
        "contract_address": "0x94d7e215fcb6d731919b7726f0a3571bf2fe7c6f",
        "function_name": "pause",
        "vulnerability_type": "safe",
        "code_snippet": "function pause() public isAuthorized {\n\tisPaused = true;\n}"
    },
    {
        "contract_address": "0x0157b72f1ccf174cac1ec1a4fb6a791f7fe4253f",
        "function_name": "mine",
        "vulnerability_type": "Re-entrancy",
        "code_snippet": "function mine(uint amount) canMine external {\n    require(amount > 0);\n    require(cycleMintSupply < CYCLE_CAP);\n    require(ERC20(FUTB).transferFrom(msg.sender, address(this), amount));\n    uint refund = _mine(exchangeRateFUTB, amount);\n    if(refund > 0) {\n      ERC20(FUTB).transfer(msg.sender, refund);\n    }\n    if (cycleMintSupply == CYCLE_CAP) {\n      _startSwap();\n    }\n  }"
    },
    {
        "contract_address": "0x0f72714b35a366285df85886a2ee174601292a17",
        "function_name": "transfer",
        "vulnerability_type": "safe",
        "code_snippet": "function transfer(address _to, uint256 _value) public returns (bool);"
    }
]